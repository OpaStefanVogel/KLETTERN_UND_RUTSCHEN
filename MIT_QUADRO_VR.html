<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - roller coaster</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

		<div id="container"></div>

	<body>
<p id="Logfile"> </p> 
<div style="font-style:italic; white-space:pre-wrap;">

ANLEITUNG:

Die Knöpfe verraten es dir.


</div>
<div style="display:flex; align-items:flex-end">               
<span style="display:flex; flex-direction:row; align-items:flex-end">

<button onclick="Loeschen()">Löschen</button>
<button onclick="Farbe('green')" style="background-color:green">grün</button>
<button onclick="Farbe('mediumblue')" style="background-color:blue">blau</button>
<button onclick="Farbe('orange')" style="background-color:orange">orange</button>
<button onclick="Farbe('red')" style="background-color:red">rot</button>
<!--span id="link" style="position:relative; top:0px; left:60px; background-color:white"><small><small> Grafikprogramm=<a href="https://github.com/mrdoob/three.js">mrdoob/three.js</a>, QUADRO=<a href="https://quadro.com">quadro.com</a></small></small></span-->
  </span>
</div>               
<div id="Ausgabe Downloadtext" style="display:none; white-space:pre-wrap; font-size:50%"> </div>
<div id="Ausgabe zu tree.js"></div>               
<div>               
<button id="links"  style="background-color:ccbbff">links</button>
<button id="hoch"   style="background-color:f7f7f7">hoch</button>
<button id="rechts" style="background-color:ffeecc">rechts</button>
<button id="runter" style="background-color:777733">runter</button>
<button id="hinter" style="background-color:444444; color:777777">hinter</button>
<button id="vor"    style="background-color:ddddff">vor</button>
Länge=<span style="display:inline-flex; flex-direction:row; font-size:200%">
<span onclick="Faktor=10"><input type="radio" id="L10" name="Laenge" value="10"/><label for="L10">10</label></span>
<span onclick="Faktor=20"><input type="radio" id="L20" name="Laenge" value="20"/><label for="L20">20</label></span>
<span onclick="Faktor=40"><input type="radio" id="L40" name="Laenge" value="40" checked="checked"/><label for="L40">40</label></span>
<span onclick="Faktor=80"><input type="radio" id="L80" name="Laenge" value="80"/><label for="L80">80</label></span>
<button id="rollercoaster">zwischendurch im rollercoaster mitfahren</button>
<button id="weiter_mit_QUADRO">dann QUADRO weiter machen</button>
</span>
</div>               
<span id="Logpos" style="display:none"> </span>
<span id="Log"> </span>
<span id="Log2" style="white-space:pre-wrap"> </span>
<div>               
<button onclick="Richtung(-40,0,0,10)">Mini links</button>
<button onclick="Richtung(30,-30,0,Faktor)">schräg rechts hoch</button>
<button onclick="Richtung(30,30,0,Faktor)">schräg rechts runter</button>
<button onclick="Richtung(-40,0,0,10)">Mini links</button>
</div>               
<div>               
<button onclick="Richtung(40,0,0,10)">Mini rechts</button>
<button onclick="Richtung(-30,-30,0,Faktor)">schräg links hoch</button>
<button onclick="Richtung(-30,30,0,Faktor)">schräg links runter</button>
<button onclick="Richtung(40,0,0,10)">Mini rechts</button>
</div>
<div>               
<button onclick="Richtung(0,-40,0,10)">Mini hoch</button>
<button onclick="Richtung(0,40,0,10)">Mini runter</button>
</div>






<!--video id="video" loop muted crossOrigin="anonymous" playsinline style="display:non">
  <source src="./three.js/textures/pano.webm">
  <source src="./three.js/examples/textures/pano.mp4">
  </video-->
<!--p>Hallo</p-->
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<!--script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script-->

		<script type="importmap">
			{
				"imports": {
					"three": "./three.js/build/three.module.js",
					"three/addons/": "./three.js/examples/jsm/"
				}
			}
		</script>

		<script type="module">

/*
const video = document.getElementById( 'video' );
video.play();
const file = './three.js/examples/sounds/376737_Skullbeatz___Bad_Cat_Maste.mp3';
const mediaElement = new Audio( file );
mediaElement.play();
*/

			import * as THREE from 'three';

			import {
				RollerCoasterGeometry,
				RollerCoasterShadowGeometry,
				RollerCoasterLiftersGeometry,
				TreesGeometry,
				SkyGeometry
			} from 'three/addons/misc/RollerCoaster_geaendert.js';
			import { VRButton } from 'three/addons/webxr/VRButton.js';

			let mesh, material, geometry;

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.xr.enabled = true;
			renderer.xr.setReferenceSpaceType( 'local' );
			//document.body.appendChild( renderer.domElement );

			//document.body.appendChild( VRButton.createButton( renderer ) );
document.body.insertBefore( renderer.domElement, document.getElementById("Ausgabe zu tree.js") );
document.body.appendChild( VRButton.createButton( renderer ) );


			//

			const scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xf0f0ff );

			const light = new THREE.HemisphereLight( 0xfff0f0, 0x606066 );
			light.position.set( 1, 1, 1 );
			scene.add( light );

//			const train = new THREE.Object3D();
//			scene.add( train );
geometry = new THREE.BoxGeometry( 1,0.5,2 );
material = new THREE.MeshLambertMaterial( {color: 0x8080ff} );
const train = new THREE.Mesh( geometry, material );
scene.add(train);

			const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 500 );
			train.add( camera );

			// environment

			geometry = new THREE.PlaneGeometry( 500, 500, 15, 15 );
			geometry.rotateX( - Math.PI / 2 );

			const positions = geometry.attributes.position.array;
			const vertex = new THREE.Vector3();

			for ( let i = 0; i < positions.length; i += 3 ) {

				vertex.fromArray( positions, i );

				vertex.x += Math.random() * 10 - 5;
				vertex.z += Math.random() * 10 - 5;

				const distance = ( vertex.distanceTo( scene.position ) / 5 ) - 25;
				vertex.y = Math.random() * Math.max( 0, distance );

				vertex.toArray( positions, i );

			}

			geometry.computeVertexNormals();

			material = new THREE.MeshLambertMaterial( {
				color: 0x407000
			} );

			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new TreesGeometry( mesh );
//document.getElementById("Logfile").innerHTML=JSON.stringify(geometry.toJSON());
//alert (geometry.toJSON().data.attributes.position.array);
/*
"metadata":{"version":4.5,"type":"BufferGeometry","generator":"BufferGeometry.toJSON"},"uuid":"aa3de6ee-f19a-405a-aa9f-e021d61e4610","type":"BufferGeometry","data":{"attributes":{
  "position":{"itemSize":3,"type":"Float32Array","array":[
  -10.43908405303955,0.6611022353172302,147.7867431640625,
  -10.587079048156738,5.04817008972168,146.79776000976562,
  -10.735074043273926,0.6611022353172302,145.8087615966797,
  -9.598090171813965,0.6611022353172302,146.64976501464844,
  -10.587079048156738,5.04817008972168,146.79776000976562,
  -11.576066970825195,0.6611022353172302,146.9457550048828],"normalized":false},
  "color":{"itemSize":3,"type":"Float32Array","array":[
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0],"normalized":false}
  }}}
*/
			material = new THREE.MeshBasicMaterial( {
				side: THREE.DoubleSide, vertexColors: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new SkyGeometry();
			material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			//

			const PI2 = Math.PI * 2;

			const curve = ( function () {

				const vector = new THREE.Vector3();
				const vector2 = new THREE.Vector3();

				return {

					getPointAt: function ( t ) {

						t = t * PI2;

						const x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;
						const y = Math.sin( t * 10 ) * 2 + Math.cos( t * 17 ) * 2 + 5;
						const z = Math.sin( t ) * Math.sin( t * 4 ) * 50;

						return vector.set( x, y, z ).multiplyScalar( 2 );

					},

					getTangentAt: function ( t ) {

						const delta = 0.0001;
						const t1 = Math.max( 0, t - delta );
						const t2 = Math.min( 1, t + delta );

						return vector2.copy( this.getPointAt( t2 ) )
							.sub( this.getPointAt( t1 ) ).normalize();

					}

				};

			} )();

			geometry = new RollerCoasterGeometry( curve, 1500 );
			material = new THREE.MeshPhongMaterial( { 
				vertexColors: true,
			} );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new RollerCoasterLiftersGeometry( curve, 100 );
			material = new THREE.MeshPhongMaterial();
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 0.1;
			scene.add( mesh );

			geometry = new RollerCoasterShadowGeometry( curve, 500 );
			material = new THREE.MeshBasicMaterial( {
				color: 0x305000, depthWrite: false, transparent: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 0.1;
			scene.add( mesh );

			const funfairs = [];

			//

			geometry = new THREE.CylinderGeometry( 10, 10, 5, 15 );
			material = new THREE.MeshLambertMaterial( {
				color: 0xff8080
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.set( - 80, 10, - 70 );
			mesh.rotation.x = Math.PI / 2;
			scene.add( mesh );

			funfairs.push( mesh );

			geometry = new THREE.CylinderGeometry( 5, 6, 4, 6 );
			material = new THREE.MeshLambertMaterial( {
				color: 0x8080DD, roughness:0, metalness: 1
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.set( 55, 2, 30 );
			scene.add( mesh );

			funfairs.push( mesh );

			//

			window.addEventListener( 'resize', onWindowResize );
			renderer.domElement.addEventListener( 'onclick', function(){alert(8)} );

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			const position = new THREE.Vector3();
			const tangent = new THREE.Vector3();

			const lookAt = new THREE.Vector3();

			let velocity = 0;
			let progress = 0;

			let prevTime = performance.now();











//-------------------------------------------- aus MIT_QUADRO.html die Berechnungen
var aktuelle_Position=[0,0,0];
var vorherige_Position=[0,0,0];
var Stangen=[];
var Faktor=40; //40=normal, 80=doppelt, 20=mini, 10=Ansatzstück 
var Knoten=[];
var Downloadtext='<?xml version="1.0" encoding="utf-8" ?>\n<KLETTERN_UND_RUTSCHEN xmlns="https://github.com/OpaStefanVogel/KLETTERN_UND_RUTSCHEN">\n';
function Richtung(dr,dh,dv,Faktor) {
  vorherige_Position=aktuelle_Position.slice();
  aktuelle_Position[0]=aktuelle_Position[0]+dr*Faktor/40;
  aktuelle_Position[1]=aktuelle_Position[1]-dh*Faktor/40;
  aktuelle_Position[2]=aktuelle_Position[2]-dv*Faktor/40;
  document.getElementById("Logpos").firstChild.nodeValue=[aktuelle_Position[0].toFixed(0),aktuelle_Position[1].toFixed(0),aktuelle_Position[2].toFixed(0)];
  Downloadtext=Downloadtext+"Richtung("+dr+","+dh+","+dv+","+Faktor+");\n";
  document.getElementById("Ausgabe Downloadtext").firstChild.nodeValue=Downloadtext+"</KLETTERN_UND_RUTSCHEN>";
//return;
  var qalt=q.position.clone();
  q.position.x=q.position.x+dr*Faktor/40/40;
  q.position.y=q.position.y-dh*Faktor/40/40;
  q.position.z=q.position.z-dv*Faktor/40/40;
  q.visible=true;
  Knoten.push(q.position.clone());
  var qneu=q.position.clone();
  var st=new THREE.Mesh( (new THREE.CylinderGeometry( 0.05,0.05,0.1+Faktor/40,16)),(new THREE.MeshStandardMaterial( { color: 0xff0000, metalness: 0.2, roughness: 0 } )));
  st.position.x=(qalt.x+qneu.x)/2;
  st.position.y=(qalt.y+qneu.y)/2;
  st.position.z=(qalt.z+qneu.z)/2;
  st.Stange=[qalt.toArray(),qneu.toArray(),Faktor/40,"red"];
  st.lookAt(q.position);
  st.rotateX(Math.PI/2);
  //st.material.color.set(0x009900);
  Stangen.push(st);
  QUADRO.add( st );
  sminind=Stangen.length-1;
  s.position.copy(st.position);
  s.visible=true;
  }

var was_geloescht_werden_soll=0;
function Loeschknopf() {
  was_geloescht_werden_soll=event.target.parentNode;
  }

function Loeschen() {
  scene.remove(Stangen[sminind]);
  Stangen.splice(sminind,1);
  Knoten.splice(sminind+1,1);
  sminind=Stangen.length-1;
  q.position.copy(Knoten[sminind+1]);
  q.visible=true;
  s.visible=true;
  if (sminind>-1) {
    s.position.copy(Stangen[sminind].position);
    } else {
      s.position.cooy(q.position);
      }
  }

function Farbe(farbe) {
  Stangen[sminind].material.color.set(farbe);
  Stangen[sminind].Stange[3]=farbe;
  }

function Stange(qalt,qneu,Faktor,Farbe) {
  //alert(qalt+" "+qneu+" "+Faktor+" "+Farbe);
  var st=new THREE.Mesh( (new THREE.CylinderGeometry( 0.05,0.05,0.1+Faktor,16)),(new THREE.MeshStandardMaterial( { color: Farbe } )));
  q.position.x=qneu[0];
  q.position.y=qneu[1];
  q.position.z=qneu[2];
  Knoten.push(q.position.clone());
  st.position.x=(qalt[0]+qneu[0])/2;
  st.position.y=(qalt[1]+qneu[1])/2;
  st.position.z=(qalt[2]+qneu[2])/2;
  st.Stange=[qalt.slice(),qneu.slice(),Faktor,Farbe];
  st.lookAt(q.position);
  st.rotateX(Math.PI/2);
  //st.material.color.set(0x009900);
  Stangen.push(st);
  scene.add( st );
  sminind=Stangen.length-1;
  s.position.copy(st.position);
  s.visible=true;
  }



//---------------------------------------- aus MIT_QUADRO.html die Geometrie:
const QUADRO = new THREE.Object3D();
scene.add( QUADRO );
QUADRO.position.set( 4, 0.2, -34 );
QUADRO.rotateY(Math.PI);
//QUADRO.rotateZ(Math.PI);

const qGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
const qMaterial = new THREE.MeshStandardMaterial( { color: 0x00dddd, metalness: 0.2, roughness: 0} );
const q = new THREE.Mesh( qGeometry, qMaterial );
QUADRO.add( q );
Knoten.push(q.position.clone());

const sGeometry = new THREE.SphereGeometry( 0.06, 32, 32 );
const sMaterial = new THREE.MeshStandardMaterial( { color: 0xdddd00, metalness: 0.2, roughness: 0 } );
const s = new THREE.Mesh( sGeometry, sMaterial );
QUADRO.add( s );

QUADRO.add(camera);
var gamma=Math.PI/2.4;
var delta=0.2;
var distanz=6;
camera.position.setFromSphericalCoords(distanz,gamma,delta);
//camera.position.set( 2, 2, -40 );camera.lookAt(0,3,0);

let sminind=0;//fehlt oben
function Test() {
setTimeout(Richtung,2000,0,0,40,Faktor);//vor
setTimeout(Richtung,4000,0,-40,0,Faktor);//hoch
setTimeout(Richtung,6000,40,0,0,Faktor);//rechts
setTimeout(Richtung,8000,0,40,0,Faktor);//runter
setTimeout(Richtung,10000,0,0,40,Faktor);//vor
setTimeout(Richtung,12000,0,-40,0,Faktor);//hoch
setTimeout(Richtung,14000,-40,0,0,Faktor);//links
setTimeout(Richtung,16000,0,40,0,Faktor);//runter
setTimeout(Test,16000);
}
//Test();


//------------die Tasten
document.getElementById("links" ).addEventListener('click',function(){Richtung(-40,0,0,Faktor)});
document.getElementById("rechts").addEventListener('click',function(){Richtung(+40,0,0,Faktor)});
document.getElementById("hoch"  ).addEventListener('click',function(){Richtung(0,-40,0,Faktor)});
document.getElementById("runter").addEventListener('click',function(){Richtung(0,+40,0,Faktor)});
document.getElementById("hinter").addEventListener('click',function(){Richtung(0,0,-40,Faktor)});
document.getElementById("vor"   ).addEventListener('click',function(){Richtung(0,0,+40,Faktor)});
document.getElementById("rollercoaster").addEventListener('click',function(){train.add(camera);camera.position.set( 0, 0, 1); q.visible=false});
document.getElementById("weiter_mit_QUADRO").addEventListener('click',function(){QUADRO.add(camera);camera.position.copy(cp); q.visible=true});













//-----------------

var cl=q.position.clone();
var cp=camera.position.clone();
var Ausrichten=0.005;



//--------

			function render() {

				const time = performance.now();
				const delta = time - prevTime;

				for ( let i = 0; i < funfairs.length; i ++ ) {

					funfairs[ i ].rotation.y = time * 0.0004;

				}

				//

				progress += velocity;
				progress = progress % 1;

				position.copy( curve.getPointAt( progress ) );
				position.y += 0.3;

				train.position.copy( position );

				tangent.copy( curve.getTangentAt( progress ) );

				velocity -= tangent.y * 0.0000001 * delta;
				velocity = Math.max( 0.00004, Math.min( 0.0002, velocity ) );

				train.lookAt( lookAt.copy( position ).sub( tangent ) );

				//

//----QUADRO

  if (q.visible) {

    var diff=new THREE.Vector3();
    diff.subVectors(q.position,cl);
  
    if (diff.length()>0.01) {
      if (Ausrichten<1) diff.normalize().multiplyScalar(Ausrichten);
      cl.add(diff);
      camera.lookAt(QUADRO.localToWorld(cl.clone()));
      }

    var diff2=new THREE.Vector3();
//    diff2.subVectors(camera.position,q.position)
    diff2.subVectors(cp,q.position)
    
    document.getElementById("Log2").firstChild.nodeValue=diff2.length().toFixed(4)+" "+JSON.stringify(QUADRO.localToWorld(cl.clone()));

    if (Math.abs(diff2.length()-distanz)>0.01) {
      diff2.normalize().multiplyScalar(Ausrichten);
      cp.add(diff);
      camera.position.copy(cp);
      camera.lookAt(QUADRO.localToWorld(cl.clone()));
      }

    }





//----------



				renderer.render( scene, camera );

				prevTime = time;

			}

			renderer.setAnimationLoop( render );

		</script>

	</body>
</html>

