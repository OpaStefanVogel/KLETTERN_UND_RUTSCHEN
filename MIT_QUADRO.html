<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>QUADRO im three.js vr - roller coaster</title>
	  </head>

	<body>
<p id="Logfile" style="font-family:Courier,monospace; white-space:pre-wrap; overflow:auto"> </p> 
<div style="font-style:italic; white-space:pre-wrap;">
<u>ANLEITUNG:</u>

Die Knöpfe verraten es dir.

</div>
<span style="position:relative; top:35px; left:760px; color:teal" ><small><code>background: https://threejs.org/examples/webxr_vr_rollercoaster.html</code></small></span>
<div style="display:flex; align-items:flex-end">               
<span style="display:flex; flex-direction:row; align-items:flex-end">

<button id="Löschen">Löschen</button>
<button id="grün" style="background-color:green">grün</button>
<button id="blau" style="background-color:DeepSkyBlue">blau</button>
<button id="orange" style="background-color:Yellow">gelb</button>
<button id="rot" style="background-color:red">rot</button> -------
<button id="Demo" style="background-color:">Demo</button>
<button id="Demo_Lok">Lok</button>
<button id="Demo_Rauner_Lok">Rauner Lok</button>
<button id="Demo_Sommer_2023">Sommer_2023</button>
<button id="Demo_Diesellok">Diesellok</button>
<button id="Button_Test">Test</button>
<button id="alles_loeschen" style="background-color:">alles löschen</button>
<!--span id="link" style="position:relative; top:0px; left:60px; background-color:white"><small><small> Grafikprogramm=<a href="https://github.com/mrdoob/three.js">mrdoob/three.js</a>, QUADRO=<a href="https://quadro.com">quadro.com</a></small></small></span-->
  </span>
</div>               
<div id="Ausgabe Downloadtext" style="display:none; white-space:pre-wrap; font-size:50%"> </div>
<div id="Ausgabe zu tree.js"> </div>
<div style="position:fixed; bottom:120px; border:double; left:1060px; font-size: 100%; background-color: red; width:150px;">Drehen:
<div>
  <button id="Button_links"  style="background-color:ccbbff">links</button>
  <button id="Button_rechts" style="background-color:ffeecc">rechts</button>
  </div>
<div>
<button id="Button_hoch"   style="background-color:f7f7f7">hoch</button>
<button id="Button_runter" style="background-color:777733">runter</button>
  </div>
<div>
Einsetzen:
  </div>
<div>
<button id="Button_Stange_einsetzen"    style="background-color:lightgray">Stange</button>
  </div>
<div>
Weitergehen:
  </div>
<div>
  <button id="Button_weitergehen"    style="background-color:darkgray">vor</button>
  <button id="Button_halbweitergehen"    style="background-color:darkgray">1/2</button>
  </div>
<div>
<button id="Button_zurueckgehen"    style="background-color:darkgray">zurück</button>
<button id="Button_halbzurueckgehen"    style="background-color:darkgray">1/2</button>
  </div>
<div>
<button id="Button_nuebergehen"    style="background-color:darkgray">links</button>
<button id="Button_halbnuebergehen"    style="background-color:darkgray">1/2</button>
  </div>
<div>
<button id="Button_ruebergehen"    style="background-color:darkgray">rechts</button>
<button id="Button_halbruebergehen"    style="background-color:darkgray">1/2</button>
  </div>
<div>
<button id="Button_hochgehen"    style="background-color:darkgray">hoch</button>
<button id="Button_halbhochgehen"    style="background-color:darkgray">1/2</button>
  </div>
<div>
<button id="Button_runtergehen"    style="background-color:darkgray">runter</button>
<button id="Button_halbruntergehen"    style="background-color:darkgray">1/2</button>
  </div>
<div>
Länge:
  </div>
<div>
<button id="Button_verdoppeln"    style="background-color:darkgray">verdoppeln</button>
<button id="Button_halbieren"    style="background-color:darkgray">halbieren</button>
  </div>
</div>               
<div>               
<button id="links"  style="background-color:ccbbff">links</button>
<button id="hoch"   style="background-color:f7f7f7">hoch</button>
<button id="rechts" style="background-color:ffeecc">rechts</button>
<button id="runter" style="background-color:777733">runter</button>
<button id="hinter" style="background-color:444444; color:777777">hinter</button>
<button id="vor"    style="background-color:ddddff">vor</button>
Länge=<span style="display:inline-flex; flex-direction:row; font-size:200%">
<span onclick="Faktor=10"><input type="radio" id="L10" name="Laenge" value="10"/><label for="L10">10</label></span>
<span onclick="Faktor=20"><input type="radio" id="L20" name="Laenge" value="20"/><label for="L20">20</label></span>
<span onclick="Faktor=40"><input type="radio" id="L40" name="Laenge" value="40" checked="checked"/><label for="L40">40</label></span>
<span onclick="Faktor=80"><input type="radio" id="L80" name="Laenge" value="80"/><label for="L80">80</label></span>
<button id="rollercoaster">zwischendurch im rollercoaster mitfahren</button>
<button id="weiter_mit_QUADRO">dann QUADRO weiter machen</button>
</span>
</div>
<div style='display:none'>
  <span id="Logpos" style="display:none"> </span>
  <span id="Log"> </span>
  <span id="Log2" style="white-space:pre-wrap"> </span>
  <span id="Log3" style="white-space:pre-wrap"> </span>
  </div>
<div>               
<button id="Mini links1">Mini links</button>
<button id="schräg rechts hoch">schräg rechts hoch</button>
<button id="schräg rechts runter">schräg rechts runter</button>
<button id="Mini links2">Mini links</button>
</div>               
<div>               
<button id="Mini rechts1">Mini rechts</button>
<button id="schräg links hoch">schräg links hoch</button>
<button id="schräg links runter">schräg links runter</button>
<button id="Mini rechts2">Mini rechts</button>
</div>
<div>               
<button id="Mini hoch">Mini hoch</button>
<button id="Mini runter">Mini runter</button>
</div>

<hr/>
<hr/>
<div>
  Kamera ausrichten 
  <span onclick="Ausrichten=1"><input type="radio" id="K10" name="Ausrichten" value="10"/><label for="K10">sofort</label></span>
  <span onclick="Ausrichten=0.05"><input type="radio" id="K20" name="Ausrichten" value="20"/><label for="K20">schnell</label></span>
<span onclick="Ausrichten=0.005"><input type="radio" id="K40" name="Ausrichten" value="40" checked="checked"/><label for="K40">langsam</label></span>
  <span onclick="Ausrichten=0"><input type="radio" id="K80" name="Ausrichten" value="80"/><label for="K80">nur bei</label></span>
  <button id="Kamera ausrichten" onclick="Kamera_ausrichten()">Kamera ausrichten</button>
  </div>               




<hr/>
<hr/>
<div>
Als Datei <input id="Ausgabedateiname" value="Klettern_und_Rutschen.xml"> <button id="downloadstart">speichern</button>.
<span style="display:none">  <a id="download"> </a><small> (dieser Download erfolgt mit <a href="http://stackoverflow.com/questions/2897619/using-html5-javascript-to-generate-and-save-a-file">&lt;a href=... download=...&gt;</a>)</small></span>
  </div>

<div>
Zum Zurückladen <b><u>erst ganze Seite reload</u></b> und danach Datei auswählen: <input id="Datei öffnen" style="font-size:200%" type="file" id="files"/>
  </div>


		<script type="importmap">
			{
				"imports": {
					"three": "./threejs2024/build/three.module.js",
					"three/addons/": "./threejs2024/examples/jsm/"
				}
			}
		</script>

<script type="module">
import * as THREE from 'three';
import {
  RollerCoasterGeometry,
  RollerCoasterShadowGeometry,
  RollerCoasterLiftersGeometry,
  TreesGeometry,
  SkyGeometry
  } from 'three/addons/misc/RollerCoaster.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

			let mesh, material, geometry;
		let controller1, controller2;
		let controllerGrip1, controllerGrip2;
		let raycaster;
		const intersected = [];
		const tempMatrix = new THREE.Matrix4();
		let controls, group;


			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth*0.9, window.innerHeight*0.9);
			renderer.xr.enabled = true;
			renderer.xr.setReferenceSpaceType( 'local' );
			//document.body.appendChild( renderer.domElement );

			//document.body.appendChild( VRButton.createButton( renderer ) );

renderer.domElement.addEventListener("click",Bild_dblclick);
//renderer.domElement.addEventListener("dblclick",Bild_dblclick);
renderer.domElement.addEventListener("touchstart",Bild_touchstart);
renderer.domElement.addEventListener("touchmove",Bild_touchmove);
renderer.domElement.addEventListener("mousedown",Bild_dragstart);
renderer.domElement.addEventListener("mousemove",Bild_dragmove);
renderer.domElement.addEventListener("mouseup",Bild_dragend);
document.body.addEventListener("keydown",Bild_keydown);
renderer.domElement.addEventListener("wheel",Bild_wheel);
document.body.insertBefore( renderer.domElement, document.getElementById("Ausgabe zu tree.js") );
var VRButt=VRButton.createButton( renderer );
document.body.appendChild( VRButt);

			//

			const scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xf0f0ff );

			const light = new THREE.HemisphereLight( 0xfff0f0, 0x606066 );
			light.position.set( 1, 1, 1 );
			scene.add( light );

//			const train = new THREE.Object3D();
//			scene.add( train );
geometry = new THREE.BoxGeometry( 1,0.5,2 );
material = new THREE.MeshLambertMaterial( {color: 0x8080ff} );
const train = new THREE.Mesh( geometry, material );
scene.add(train);

			const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 500 );
			train.add( camera );

			// environment

			geometry = new THREE.PlaneGeometry( 500, 500, 15, 15 );
			geometry.rotateX( - Math.PI / 2 );

			const positions = geometry.attributes.position.array;
			const vertex = new THREE.Vector3();

			for ( let i = 0; i < positions.length; i += 3 ) {

				vertex.fromArray( positions, i );

				vertex.x += Math.random() * 10 - 5;
				vertex.z += Math.random() * 10 - 5;

				const distance = ( vertex.distanceTo( scene.position ) / 5 ) - 25;
				vertex.y = Math.random() * Math.max( 0, distance );

				vertex.toArray( positions, i );

			}

			geometry.computeVertexNormals();

			material = new THREE.MeshLambertMaterial( {
				color: 0x407000
			} );

			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new TreesGeometry( mesh );
//document.getElementById("Logfile").innerHTML=JSON.stringify(geometry.toJSON());
//alert (geometry.toJSON().data.attributes.position.array);
/*
"metadata":{"version":4.5,"type":"BufferGeometry","generator":"BufferGeometry.toJSON"},"uuid":"aa3de6ee-f19a-405a-aa9f-e021d61e4610","type":"BufferGeometry","data":{"attributes":{
  "position":{"itemSize":3,"type":"Float32Array","array":[
  -10.43908405303955,0.6611022353172302,147.7867431640625,
  -10.587079048156738,5.04817008972168,146.79776000976562,
  -10.735074043273926,0.6611022353172302,145.8087615966797,
  -9.598090171813965,0.6611022353172302,146.64976501464844,
  -10.587079048156738,5.04817008972168,146.79776000976562,
  -11.576066970825195,0.6611022353172302,146.9457550048828],"normalized":false},
  "color":{"itemSize":3,"type":"Float32Array","array":[
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0,
  0.23417016863822937,0.4341701567173004,0],"normalized":false}
  }}}
*/
			material = new THREE.MeshBasicMaterial( {
				side: THREE.DoubleSide, vertexColors: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new SkyGeometry();
			material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			//

			const PI2 = Math.PI * 2;

			const curve = ( function () {

				const vector = new THREE.Vector3();
				const vector2 = new THREE.Vector3();

				return {

					getPointAt: function ( t ) {

						t = t * PI2;

						const x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;
						const y = Math.sin( t * 10 ) * 2 + Math.cos( t * 17 ) * 2 + 5;
						const z = Math.sin( t ) * Math.sin( t * 4 ) * 50;

						return vector.set( x, y, z ).multiplyScalar( 2 );

					},

					getTangentAt: function ( t ) {

						const delta = 0.0001;
						const t1 = Math.max( 0, t - delta );
						const t2 = Math.min( 1, t + delta );

						return vector2.copy( this.getPointAt( t2 ) )
							.sub( this.getPointAt( t1 ) ).normalize();

					}

				};

			} )();

			geometry = new RollerCoasterGeometry( curve, 1500 );
			material = new THREE.MeshPhongMaterial( { 
				vertexColors: true,
			} );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new RollerCoasterLiftersGeometry( curve, 100 );
			material = new THREE.MeshPhongMaterial();
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 0.1;
			scene.add( mesh );

			geometry = new RollerCoasterShadowGeometry( curve, 500 );
			material = new THREE.MeshBasicMaterial( {
				color: 0x305000, depthWrite: false, transparent: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 0.1;
			scene.add( mesh );

			const funfairs = [];

			//

			geometry = new THREE.CylinderGeometry( 10, 10, 5, 15 );
			material = new THREE.MeshLambertMaterial( {
				color: 0xff8080
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.set( - 80, 10, - 70 );
			mesh.rotation.x = Math.PI / 2;
			scene.add( mesh );

			funfairs.push( mesh );

			geometry = new THREE.CylinderGeometry( 5, 6, 4, 6 );
			material = new THREE.MeshLambertMaterial( {
				color: 0x8080DD, roughness:0, metalness: 1
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.set( 55, 2, 30 );
			scene.add( mesh );

			funfairs.push( mesh );

			//

//			window.addEventListener( 'resize', onWindowResize );
//			renderer.domElement.addEventListener( 'click', function(){alert(8)} );

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

		// controllers
				
				controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'selectstart', onSelectStart );//CONT Stange greifen
				controller1.addEventListener( 'selectend', onSelectEnd );    //CONT Stange loslassen
controller1.addEventListener( 'touchstart', onClick );
controller1.addEventListener( 'mousedown', onClick );
controller1.addEventListener( 'keypress', onClick );
controller1.addEventListener( 'keyup', onClick );
controller1.addEventListener( 'squeezestart', function() {alert('squeezestart')} );
//for (let i in controller1) alert(i);
//for (let i in controller1._listeners) alert(i);
//Logfile.innerHTML=JSON.stringify(controller1);
				
				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'selectstart', onSelectStart );
				controller2.addEventListener( 'selectend', onSelectEnd );
controller2.addEventListener( 'touchstart', onClick );

				const controllerModelFactory = new XRControllerModelFactory();
//Logfile.innerHTML=controllerModelFactory.createControllerModel;
//for (let i in controllerModelFactory) alert(i);

				controllerGrip1 = renderer.xr.getControllerGrip( 0 );
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );

				controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );

				//

				const linegeometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				const line = new THREE.Line( linegeometry );
				line.name = 'line';
				line.scale.z = 5;

				controller1.add( line.clone() );
				controller2.add( line.clone() );

				raycaster = new THREE.Raycaster();

				//

let J_selected=false;
			function onSelectStart( event ) {
if (camera.parent==train) {weiter_mit_QUADRO.click();return}

				const controller = event.target;

				const intersections = getIntersections( controller );

				if ( intersections.length > 0 ) {

					const intersection = intersections[ 0 ];

					const object = intersection.object;
					object.material.emissive.b = 0;
//neu ab 2024__10_23 Joystick:♥
if (object.parent!=st) {
                    controller.attach( object ); 
					controller.userData.selected = object;
					} else {
					  J_selected=object;
					  if (J_selected==J_rollercoaster) rollercoaster.click();
					  }

				}

			}

			function onSelectEnd( event ) {
J_selected=false;//♥
				const controller = event.target;

				if ( controller.userData.selected !== undefined ) {

					const object = controller.userData.selected;
					object.material.emissive.b = 0.3;
					QUADRO.attach( object );

					controller.userData.selected = undefined;

				}


			}

function onClick( event ) {//alert(1111);return;
Logfile.innerHTML='onClick';
				const controller = event.target;

				if ( controller.userData.selected !== undefined ) {

					const object = controller.userData.selected;
					object.material.emissive.b = 0;
					QUADRO.attach( object );

					controller.userData.selected = undefined;

				}


			}

			function getIntersections( controller ) {

				tempMatrix.identity().extractRotation( controller.matrixWorld );

				raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
				raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

				return raycaster.intersectObjects( QUADRO.children.concat(st.children), false );

			}

			function intersectObjects( controller ) {//dauernd

				// Do not highlight when already selected

				if ( controller.userData.selected !== undefined ) return;

				const line = controller.getObjectByName( 'line' );
				const intersections = getIntersections( controller );

				if ( intersections.length > 0 ) {

					const intersection = intersections[ 0 ];

					const object = intersection.object;
					object.material.emissive.r = 1;
					intersected.push( object );

					line.scale.z = intersection.distance;

				} else {

					line.scale.z = 5;

				}

			}

			function cleanIntersected() {

				while ( intersected.length ) {

					const object = intersected.pop();
					object.material.emissive.r = 0;

				}

			}
			//

			const position = new THREE.Vector3();
			const tangent = new THREE.Vector3();

			const lookAt = new THREE.Vector3();

			let velocity = 0;
			let progress = 0;

			let prevTime = performance.now();











//-------------------------------------------- aus MIT_QUADRO.html die Berechnungen
var aktuelle_Position=[0,0,0];
var vorherige_Position=[0,0,0];
var Stangen=[];
var Faktor=40; //40=normal, 80=doppelt, 20=mini, 10=Ansatzstück 
var Knoten=[];
var Downloadtext='<?xml version="1.0" encoding="utf-8" ?>\n<KLETTERN_UND_RUTSCHEN xmlns="https://github.com/OpaStefanVogel/KLETTERN_UND_RUTSCHEN">\n';
function Richtung(dr,dh,dv,Faktor) {
  vorherige_Position=aktuelle_Position.slice();
  aktuelle_Position[0]=aktuelle_Position[0]+dr*Faktor/40;
  aktuelle_Position[1]=aktuelle_Position[1]-dh*Faktor/40;
  aktuelle_Position[2]=aktuelle_Position[2]-dv*Faktor/40;
  document.getElementById("Logpos").firstChild.nodeValue=[aktuelle_Position[0].toFixed(0),aktuelle_Position[1].toFixed(0),aktuelle_Position[2].toFixed(0)];
  Downloadtext=Downloadtext+"Richtung("+dr+","+dh+","+dv+","+Faktor+");\n";
  document.getElementById("Ausgabe Downloadtext").firstChild.nodeValue=Downloadtext+"</KLETTERN_UND_RUTSCHEN>";
//return;
  var qalt=q.position.clone();
  q.position.x=q.position.x+dr*Faktor/40/40;
  q.position.y=q.position.y-dh*Faktor/40/40;
  q.position.z=q.position.z-dv*Faktor/40/40;
  q.visible=true;
  Knoten.push(q.position.clone());
  var qneu=q.position.clone();
  var st=new THREE.Mesh( (new THREE.CylinderGeometry( 0.05,0.05,0.1+Faktor/40,16)),(new THREE.MeshStandardMaterial( { color: 0xee1100, metalness: 0.3, roughness: 0.1 } )));
  st.position.x=(qalt.x+qneu.x)/2;
  st.position.y=(qalt.y+qneu.y)/2;
  st.position.z=(qalt.z+qneu.z)/2;
  st.Stange=[qalt.toArray(),qneu.toArray(),Faktor/40,"red"];
  st.lookAt(q.position);
  st.rotateX(Math.PI/2);
  //st.material.color.set(0x009900);
  Stangen.push(st);
  QUADRO.add( st );
  sminind=Stangen.length-1;
  s.position.copy(st.position);
  s.visible=true;
  //document.getElementById("Log2").firstChild.nodeValue=JSON.stringify(QUADRO);
  }

var was_geloescht_werden_soll=0;
function Loeschknopf() {
  was_geloescht_werden_soll=event.target.parentNode;
  }

function Loeschen() {
  QUADRO.remove(Stangen[sminind]);
  Stangen.splice(sminind,1);
  Knoten.splice(sminind+1,1);
  sminind=Stangen.length-1;
  q.position.copy(Knoten[sminind+1]);
  q.visible=true;
  s.visible=true;
  if (sminind>-1) {
    s.position.copy(Stangen[sminind].position);
    } else {
      s.position.cooy(q.position);
      }
  }

function alles_loeschen() {
  while (Stangen.length>0) Loeschen();
  }


function Farbe(farbe) {
  Stangen[sminind].material.color.set(farbe);
  Stangen[sminind].Stange[3]=farbe;
  }

var Zylinderradius=0.05;
function Stange(qalt,qneu,Faktor,Farbe) {
  //alert(qalt+" "+qneu+" "+Faktor+" "+Farbe);
  var st=new THREE.Mesh( (new THREE.CylinderGeometry( Zylinderradius,Zylinderradius,0.1+Faktor,16)),(new THREE.MeshStandardMaterial( { color: Farbe, metalness: 0.3, roughness: 0.1} )));
  q.position.x=qneu[0];
  q.position.y=qneu[1];
  q.position.z=qneu[2];
  Knoten.push(q.position.clone());
  st.position.x=(qalt[0]+qneu[0])/2;
  st.position.y=(qalt[1]+qneu[1])/2;
  st.position.z=(qalt[2]+qneu[2])/2;
  st.Stange=[qalt.slice(),qneu.slice(),Faktor,Farbe];
  st.lookAt(q.position);
  st.rotateX(Math.PI/2);
  //st.material.color.set(0x009900);
  Stangen.push(st);
  QUADRO.add( st );
  sminind=Stangen.length-1;
  s.position.copy(st.position);
  s.visible=true;
  return st;
  }

function Stange_von_q_bis_q1(Farbe) {
  let qmerkpos=q.position.clone();
  Stange(q.position.toArray(),QUADRO.worldToLocal(q1.getWorldPosition(q.position.clone())).toArray(),q1.position.length()+0.1,Farbe);
  q.position.copy(qmerkpos);
  let schondrin=false;
  for (let i=0;i<Knoten.length;i++) if (Knoten[i].equals(q.position)) schondrin=true;
  if (schondrin==false) Knoten.push(q.position.clone());
  }

//---------------------------------------- aus MIT_QUADRO.html die Geometrie:
const QUADRO = new THREE.Object3D();
scene.add( QUADRO );
QUADRO.position.set( 4, 0.2, -34 );
QUADRO.rotateY(Math.PI);
//QUADRO.rotateZ(Math.PI);

//das ist meine Zuglok:
const qGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
const qMaterial = new THREE.MeshStandardMaterial( { color: 0x00dddd, metalness: 0.5, roughness: 0.1} );
const q = new THREE.Mesh( qGeometry, qMaterial );
QUADRO.add( q );
Knoten.push(q.position.clone());

//mit Schornstein dazu
const q1Geometry = new THREE.SphereGeometry( 0.05, 32, 32 );
const q1Material = new THREE.MeshStandardMaterial( { color: 0x00dddd, metalness: 0.5, roughness: 0.1} );
const q1 = new THREE.Mesh( q1Geometry, q1Material );
q1.position.set(0,0,-1);
q.add( q1 );
const q2Geometry = new THREE.SphereGeometry( 0.03, 32, 32 );
const q2Material = new THREE.MeshStandardMaterial( { color: 0x00dddd, metalness: 0.5, roughness: 0.1} );
const q2 = new THREE.Mesh( q2Geometry, q2Material );
q2.position.set(0,0.08,0.-1);
q.add( q2 );
const q3=new THREE.Mesh( (new THREE.CylinderGeometry( Zylinderradius*1.01,Zylinderradius*1.01,1,16)),(new THREE.MeshStandardMaterial( { color: "white", metalness: 0.3, roughness: 0.1, transparent:true, opacity:0.4 } )));
q3.rotateX(-Math.PI/2);
q3.translateY(0.5);
q.add( q3 );
q.yaw=0;
q.pitch=0;
q.roll=0;
q.GROT=function(yaw,pitch,roll) {q.FROT(q.yaw+yaw,q.pitch+pitch,q.roll+roll)}
q.FROT=function(yaw,pitch,roll) {
  q.yaw=yaw; q.pitch=pitch; q.roll=roll;
  q.setRotationFromEuler(new THREE.Euler(-pitch/180*Math.PI,yaw/180*Math.PI,-+roll/180*Math.PI,'YXZ'));
  }
//q.GROT(90,-30,30);

//Kantenmittelpunkt:
const sGeometry = new THREE.SphereGeometry( 0.06, 32, 32 );
const sMaterial = new THREE.MeshStandardMaterial( { color: 0xdddd00, metalness: 0.5, roughness: 0.1 } );
const s = new THREE.Mesh( sGeometry, sMaterial );
QUADRO.add( s );

//QUADRO.add(camera);
const st= new THREE.Object3D();
//st.position.set(0,10,13);
QUADRO.add(st);
//camera.rotateX(Math.Pi);
var gamma=Math.PI/2.4;
var delta2=0.2;//Math.PI/1;//war 0.2
var distanz=6;
st.position.setFromSphericalCoords(distanz,gamma,delta2);
var cl=q.position.clone();
st.lookAt(QUADRO.localToWorld(cl.clone()));
st.rotateY(-Math.PI);
st.add(camera);
//delta2=Math.PI/2;
//st.position.setFromSphericalCoords(distanz,gamma,delta2);
st.rotateY(-Math.PI/2*0);
//camera.rotateY(Math.PI);
//st.lookAt(QUADRO.localToWorld(cl.clone()));
//st.lookAt(QUADRO.localToWorld(cl.clone()));
//camera.lookAt(QUADRO.localToWorld(cl.clone()));
//camera.lookAt(QUADRO.localToWorld(cl.clone()));//zweimal sonst geht das nicht
				st.add( controller1 );
				st.add( controller2 );
				st.add( controllerGrip1 );
				st.add( controllerGrip2 );

//neu ab 2024__10_23 Joystick:♥
//const J_rechts_Geometry = new THREE.SphereGeometry( 0.11, 32, 32 );
//const J_rechts_Material = new THREE.MeshStandardMaterial( { color: 0xdddddd, metalness: 0.5, roughness: 0.1, side: THREE.DoubleSide} );
//const J_rechts_Material = new THREE.MeshBasicMaterial( { color: 0xdddddd, side: THREE.DoubleSide} );
const Pfeilgeometrie=  new THREE.ShapeGeometry(
    (new THREE.Shape)
    .moveTo(0,0)
    .lineTo(0,0.03)
    .lineTo(0.1,0.03)
    .lineTo(0.1,0.1)
    .lineTo(0.2,0)
    .lineTo(0.1,-0.1)
    .lineTo(0.1,-0.03)
    .lineTo(0,-0.03)
    .lineTo(0,0)
    );
const J_rechts_Material = new THREE.MeshStandardMaterial( { color: 0x654321, transparent: true, opacity:0.4} );
const J_rechts = new THREE.Mesh( Pfeilgeometrie, J_rechts_Material );
//J_rechts.position.copy(q.position.clone().add(st.position).divideScalar(2).add(new THREE.Vector3(0,0,0)));
//QUADRO.add( J_rechts );
J_rechts.position.copy(new THREE.Vector3(0,-0.2,-1));
st.add( J_rechts );

const J_links = new THREE.Mesh(
  Pfeilgeometrie,
  new THREE.MeshStandardMaterial( { color: 0x765432, transparent: true, opacity:0.4} )
  );
J_links.position.set(0,-0.2,-1);
J_links.rotateZ(Math.PI);
st.add( J_links );

const J_vor = new THREE.Mesh(
  Pfeilgeometrie,
  new THREE.MeshStandardMaterial( { color: 0x012345, transparent: true, opacity:0.4} )
  );
J_vor.position.set(+0.3,-0.2,-1);
J_vor.scale.set(1.5,1.5,1.5);
J_vor.rotateZ(+Math.PI/2);
J_vor.rotateY(+Math.PI/2);
st.add( J_vor );

const J_zurueck = new THREE.Mesh(
  Pfeilgeometrie,
  new THREE.MeshStandardMaterial( { color: 0x123456, transparent: true, opacity:0.4} )
  );
J_zurueck.position.set(+0.3,-0.2,-1);
J_zurueck.scale.set(1.5,1.5,1.5);
J_zurueck.rotateZ(-Math.PI/2);
J_zurueck.rotateY(-Math.PI/2);
st.add( J_zurueck );

const J_hoch = new THREE.Mesh(
  Pfeilgeometrie,
  new THREE.MeshStandardMaterial( { color: 0x234567, transparent: true, opacity:0.4} )
  );
J_hoch.position.set(-0.3,-0.2,-1);
J_hoch.rotateZ(Math.PI/2);
st.add( J_hoch );

const J_runter = new THREE.Mesh(
  Pfeilgeometrie,
  new THREE.MeshStandardMaterial( { color: 0x345678, transparent: true, opacity:0.4} )
  );
J_runter.position.set(-0.3,-0.2,-1);
J_runter.rotateZ(-Math.PI/2);
st.add( J_runter );


const J_rollercoaster = new THREE.Mesh(
  Pfeilgeometrie,
  new THREE.MeshStandardMaterial( { color: 0x456789, transparent: true, opacity:0.4} )
  );
J_rollercoaster.position.set(-0.4,-0.2,-1);
J_rollercoaster.rotateZ(Math.PI*0.8);
st.add( J_rollercoaster );




let sminind=0;//fehlt oben
function Demo1() {
var t=50;
setTimeout(Richtung,2*t,0,0,40,Faktor);//vor
setTimeout(Richtung,4*t,0,-40,0,Faktor);//hoch
setTimeout(Richtung,6*t,40,0,0,Faktor);//rechts
setTimeout(Richtung,8*t,0,40,0,Faktor);//runter
setTimeout(Richtung,10*t,0,0,40,Faktor);//vor
setTimeout(Richtung,12*t,0,-40,0,Faktor);//hoch
setTimeout(Richtung,14*t,-40,0,0,Faktor);//links
setTimeout(Richtung,16*t,0,40,0,Faktor);//runter
//setTimeout(Demo,18*t);
}

function Demo() {
Stange([0,0,0],[1,0,0],1,"Yellow");
Stange([1,0,0],[2,0,0],1,"Yellow");
Stange([2,0,0],[2,1,0],1,"Yellow");
Stange([2,1,0],[2,2,0],1,"Yellow");
Stange([2,2,0],[2,3,0],1,"red");
Stange([2,3,0],[1,3,0],1,"red");
Stange([1,3,0],[0,3,0],1,"red");
Stange([0,3,0],[0,2,0],1,"red");
Stange([0,2,0],[1,2,0],1,"red");
Stange([0,2,0],[0,1,0],1,"Yellow");
Stange([0,1,0],[0,0,0],1,"Yellow");
Stange([0,0,0],[0,0,1],1,"Yellow");
Stange([0,0,1],[0,1,1],1,"Yellow");
Stange([0,1,1],[0,1,0],1,"Yellow");
Stange([0,1,0],[1,1,0],1,"Yellow");
Stange([1,1,0],[1,2,0],1,"Yellow");
Stange([1,2,0],[1,3,0],1,"red");
Stange([1,2,0],[2,2,0],1,"red");
Stange([1,0,0],[1,1,0],1,"Yellow");
Stange([2,0,0],[2,0,-1],1,"red");
Stange([2,0,-1],[2,0,-2],1,"red");
Stange([2,0,-2],[2,1,-2],1,"red");
Stange([2,1,-2],[2,2,-2],1,"red");
Stange([2,2,-2],[2,3,-2],1,"red");
Stange([2,3,-2],[2,3,0],2,"red");
Stange([2,2,0],[2,2,-1],1,"red");
Stange([2,2,-1],[2,2,-2],1,"red");
Stange([2,1,0],[2,1,-1],1,"red");
Stange([2,1,-1],[2,1,-2],1,"red");
Stange([2,2,-1],[2,1,-1],1,"red");
Stange([2,1,-1],[2,0,-1],1,"red");
Stange([2,0,-1],[3,0,-1],1,"red");
Stange([3,0,-1],[3,0,-2],1,"red");
Stange([3,0,-2],[2,0,-2],1,"red");
Stange([3,0,-1],[3,1,-1],1,"red");
Stange([3,1,-1],[2,1,-1],1,"red");
Stange([3,1,-1],[3,1,-2],1,"red");
Stange([3,1,-2],[3,0,-2],1,"red");
Stange([3,1,-2],[2,1,-2],1,"red");
Stange([0,0,0],[0,0,-2],2,"red");
Stange([0,1,0],[0,1,-2],2,"red");
Stange([0,3,0],[0,3,-2],2,"red");
Stange([0,3,-2],[0,2,-2],1,"DeepSkyBlue");
Stange([0,2,-2],[0,1,-2],1,"DeepSkyBlue");
Stange([0,1,-2],[0,0,-2],1,"DeepSkyBlue");
Stange([0,2,0],[0,2,-1],1,"red");
Stange([0,2,-1],[0,2,-2],1,"red");
Stange([0,2,-2],[1,2,-2],1,"red");
Stange([1,2,-2],[1,3,-2],1,"red");
Stange([1,3,-2],[2,3,-2],1,"red");
Stange([1,3,-2],[1,3,-3],1,"red");
Stange([1,3,-3],[1,2,-3],1,"green");
Stange([1,2,-3],[1,1,-3],1,"green");
Stange([1,1,-3],[1,0,-3],1,"DeepSkyBlue");
Stange([1,0,-3],[0,0,-3],1,"DeepSkyBlue");
Stange([0,0,-3],[0,0,-2],1,"DeepSkyBlue");
Stange([0,0,-3],[0,1,-3],1,"DeepSkyBlue");
Stange([0,1,-3],[0,1,-2],1,"DeepSkyBlue");
Stange([0,1,-3],[1,1,-3],1,"DeepSkyBlue");
Stange([1,1,-3],[2,1,-3],1,"red");
Stange([2,1,-3],[3,1,-3],1,"red");
Stange([3,1,-3],[3,1,-2],1,"red");
Stange([3,1,-3],[3,0,-3],1,"red");
Stange([3,0,-3],[3,0,-2],1,"red");
Stange([2,0,-2],[1,0,-2],1,"red");
Stange([1,0,-2],[0,0,-2],1,"red");
Stange([1,0,-2],[1,1,-2],1,"red");
Stange([1,1,-2],[0,1,-2],1,"DeepSkyBlue");
Stange([1,1,-2],[1,1,-3],1,"DeepSkyBlue");
Stange([1,2,-2],[2,2,-2],1,"red");
Stange([2,2,-1],[1,2,-1],1,"red");
Stange([1,2,-1],[0,2,-1],1,"red");
Stange([1,2,0],[1,2,-1],1,"red");
Stange([1,2,-1],[1,2,-2],1,"red");
Stange([0,3,0],[-0.25,3,0],0.25,"red");
Stange([-0.25,3,0],[0.5,3.75,0],1,"green");
Stange([0.5,3.75,0],[1.25,4.5,0],1,"green");
Stange([1.25,4.5,0],[2,3.75,0],1,"green");
Stange([2,3.75,0],[2.75,3,0],1,"green");
Stange([2.75,3,0],[2.5,3,0],0.25,"red");
Stange([2.5,3,0],[2,3,0],0.5,"red");
Stange([0,3,-2],[-0.25,3,-2],0.25,"red");
Stange([-0.25,3,-2],[0.5,3.75,-2],1,"green");
Stange([0.5,3.75,-2],[1.25,4.5,-2],1,"green");
Stange([1.25,4.5,-2],[2,3.75,-2],1,"green");
Stange([2.75,3,-2],[2.5,3,-2],0.25,"red");
Stange([2.5,3,-2],[2,3,-2],0.5,"red");
Stange([0.5,3.75,0],[0.5,3.75,-2],2,"red");
Stange([1.25,4.5,0],[1.25,4.5,-2],2,"red");
Stange([2,3.75,0],[2,3.75,-1],1,"red");
Stange([2,3.75,-1],[2,3.75,-2],1,"red");
Stange([2,3.75,-2],[2.75,3,-2],1,"green");
Stange([1,0,-3],[1,0,-2],1,"DeepSkyBlue");
  }

function Demo_Lok() {
Stange([0,0,-1],[0,1,-1],1,"red");
Stange([0,1,-1],[-1,1,-1],1,"red");
Stange([-1,1,-1],[-1,0,-1],1,"red");
Stange([-1,0,-1],[-1,0,0],1,"red");
Stange([-1,0,0],[0,0,0],1,"red");
Stange([0,0,0],[0,1,0],1,"red");
Stange([0,1,0],[0,1,-1],1,"red");
Stange([0,1,0],[-1,1,0],1,"red");
Stange([-1,1,0],[-1,1,-1],1,"red");
Stange([-1,1,0],[-1,0,0],1,"red");
Stange([0,0,-1],[-1,0,-1],1,"red");
Stange([-1,0,-1],[-1,0,-2],1,"red");
Stange([-1,0,-2],[-1,1,-2],1,"red");
Stange([-1,1,-2],[0,1,-2],1,"red");
Stange([0,1,-2],[0,0,-2],1,"red");
Stange([0,0,-2],[-1,0,-2],1,"red");
Stange([0,0,-2],[0,0,-1],1,"red");
Stange([0,1,-1],[0,1,-2],1,"red");
Stange([-1,1,-1],[-1,1,-2],1,"red");
Stange([-1,1,-2],[-1,1,-3],1,"red");
Stange([-1,1,-3],[0,1,-3],1,"red");
Stange([0,1,-3],[0,1,-2],1,"red");
Stange([0,0,-2],[0,0,-3],1,"red");
Stange([0,0,-3],[-1,0,-3],1,"red");
Stange([-1,0,-3],[-1,0,-2],1,"red");
Stange([0,0,-3],[0,1,-3],1,"red");
Stange([-1,0,-3],[-1,1,-3],1,"red");
Stange([-1,1,-3],[-1,1,-4],1,"red");
Stange([-1,1,-4],[0,1,-4],1,"red");
Stange([0,1,-4],[0,1,-3],1,"red");
Stange([0,1,-4],[0,0,-4],1,"red");
Stange([0,0,-4],[0,0,-3],1,"red");
Stange([0,0,-4],[-1,0,-4],1,"red");
Stange([-1,0,-4],[-1,1,-4],1,"red");
Stange([-1,0,-4],[-1,0,-3],1,"red");
Stange([-1,1,0],[-2,1,0],1,"red");
Stange([1,1,0],[0,1,0],1,"red");
Stange([1,1,0],[1,0,0],1,"red");
Stange([1,0,0],[0,0,0],1,"red");
Stange([-1,0,0],[-2,0,0],1,"red");
Stange([-2,0,0],[-2,1,0],1,"red");
Stange([1,1,2],[1,0,2],1,"red");
Stange([1,0,2],[1,0,1],1,"red");
Stange([1,0,1],[1,0,0],1,"red");
Stange([1,0,2],[0,0,2],1,"red");
Stange([0,0,2],[-1,0,2],1,"red");
Stange([-1,0,2],[-2,0,2],1,"red");
Stange([-2,0,2],[-2,0,1],1,"red");
Stange([-2,0,1],[-2,0,0],1,"red");
Stange([-2,0,2],[-2,1,2],1,"red");
Stange([-1,1,2],[-1,0,2],1,"red");
Stange([0,1,2],[0,0,2],1,"red");
Stange([1,1,2],[1,1,1],1,"red");
Stange([1,1,1],[1,1,0],1,"red");
Stange([-2,1,2],[-2,1,1],1,"red");
Stange([-2,1,1],[-2,1,0],1,"red");
Stange([1,1,2],[0,1,2],1,"red");
Stange([-1,1,2],[-2,1,2],1,"red");
Stange([-2,1,1],[-1,1,1],1,"red");
Stange([-1,1,1],[-1,1,2],1,"red");
Stange([-1,1,1],[-1,0,1],1,"red");
Stange([-1,0,1],[-1,0,2],1,"red");
Stange([-1,0,1],[-2,0,1],1,"red");
Stange([0,0,2],[0,0,1],1,"red");
Stange([0,0,1],[0,1,1],1,"red");
Stange([0,1,1],[0,1,2],1,"red");
Stange([0,1,1],[1,1,1],1,"red");
Stange([1,0,1],[0,0,1],1,"red");
Stange([1,0,1],[1,1,1],1,"red");
Stange([-2,0,1],[-2,1,1],1,"red");
Stange([-2,1,2],[-2,3,2],2,"red");
Stange([-2,1,1],[-2,3,1],2,"red");
Stange([-2,1,0],[-2,3,0],2,"red");
Stange([-1,1,0],[-1,3,0],2,"red");
Stange([0,1,0],[0,3,0],2,"red");
Stange([1,1,0],[1,3,0],2,"red");
Stange([1,1,1],[1,3,1],2,"red");
Stange([0,1,2],[0,3,2],2,"red");
Stange([-1,1,2],[-1,3,2],2,"red");
Stange([1,0,2],[1,1,2],1,"red");
Stange([1,1,2],[1,3,2],2,"red");
Stange([1,3,2],[0,3,2],1,"red");
Stange([0,3,2],[-1,3,2],1,"red");
Stange([-1,3,2],[-2,3,2],1,"red");
Stange([-2,3,2],[-2,3,1],1,"red");
Stange([-2,3,1],[-2,3,0],1,"red");
Stange([-2,3,0],[-1,3,0],1,"red");
Stange([-1,3,0],[0,3,0],1,"red");
Stange([0,3,0],[1,3,0],1,"red");
Stange([1,3,0],[1,3,1],1,"red");
Stange([1,3,1],[1,3,2],1,"red");
Stange([0,3,2],[0,3,1],1,"red");
Stange([0,3,1],[1,3,1],1,"red");
Stange([-1,3,2],[-1,3,1],1,"red");
Stange([-1,3,1],[-2,3,1],1,"red");
Stange([-1,1,-3],[-0.5,1,-3],0.5,"red");
Stange([-0.5,1,-3],[-0.5,2,-3],1,"red");
Stange([-0.5,2,-3],[-0.5,3,-3],1,"red");
Stange([0,1,0],[0.5,1,0],0.5,"red");
Stange([0.5,1,0],[0.5,1.5,0],0.5,"red").wheel=stwheel;
Stange([-1,1,0],[-1.5,1,0],0.5,"red");
Stange([-1.5,1,0],[-1.5,1.5,0],0.5,"red").wheel=stwheel;
Stange([0,0,0],[0,0,-1],1,"red");
  }

function Demo_Rauner_Lok() {
var u0=1.5
var u=1/20*Math.sqrt(3)*u0;
var v=0.055;
var w=0.1;
Zylinderradius=Zylinderradius*u0;
Stange([-0.1*u0,0,0],[-0.1*u0,0,-2.2],2.2,"orange");
Stange([ 0.0*u0,0,0],[ 0.0*u0,0,-2.2],2.2,"orange");
Stange([ 0.1*u0,0,0],[ 0.1*u0,0,-2.2],2.2,"orange");
Stange([-0.15*u0,1*u,0],[-0.15*u0,1*u,-2.2],2.2,"orange");
Stange([-0.05*u0,1*u,0],[-0.05*u0,1*u,-2.2],2.2,"orange");
Stange([ 0.05*u0,1*u,0],[ 0.05*u0,1*u,-2.2],2.2,"orange");
Stange([ 0.15*u0,1*u,0],[ 0.15*u0,1*u,-2.2],2.2,"orange");
Stange([-0.1*u0,2*u,0],[-0.1*u0,2*u,-2.2],2.2,"orange");
Stange([ 0.0*u0,2*u,0],[ 0.0*u0,2*u,-2.2],2.2,"orange");
Stange([ 0.1*u0,2*u,0],[ 0.1*u0,2*u,-2.2],2.2,"orange");
Stange([-0.05*u0,3*u,0],[-0.05*u0,3*u,-2.2],2.2,"orange");
Stange([ 0.05*u0,3*u,0],[ 0.05*u0,3*u,-2.2],2.2,"orange");

Stange([ 0,3*u,-2],[ 0,3*u+0.4,-2],0.4,"orange");

Zylinderradius=Zylinderradius*u0;

//Räder
Stange([ -0.30,0,-2],[ -0.50,0,-2],0.1,"orange");
Stange([  0.30,0,-2],[  0.50,0,-2],0.1,"orange");
Stange([ -0.30,0,-1.6],[ -0.50,0,-1.6],0.1,"orange");
Stange([  0.30,0,-1.6],[  0.50,0,-1.6],0.1,"orange");
Stange([ -0.30,0,-1.2],[ -0.50,0,-1.2],0.1,"orange");
Stange([  0.30,0,-1.2],[  0.50,0,-1.2],0.1,"orange");
Stange([ -0.30,0,-0.8],[ -0.50,0,-0.8],0.1,"orange");
Stange([  0.30,0,-0.8],[  0.50,0,-0.8],0.1,"orange");
Stange([ -0.30,0,-0.4],[ -0.50,0,-0.4],0.1,"orange");
Stange([  0.30,0,-0.4],[  0.50,0,-0.4],0.1,"orange");

Zylinderradius=Zylinderradius/u0;
Zylinderradius=Zylinderradius/u0;
  for (var i=0;i<8;i++) {
    //hinten
    Stange([-1.1,2*i*v,2.1],[1.1,2*i*v,2.1],2.2,"orange");
    //vorn
    if (i<5||i>6) Stange([-1.1,2*i*v,0.1],[1.1,2*i*v,0.1],2.2,"orange"); else {
      Stange([-1.1,2*i*v,0.1],[-0.6,2*i*v,0.1],0.5,"orange"); 
      Stange([ 0.6,2*i*v,0.1],[ 1.1,2*i*v,0.1],0.5,"orange");   
      }
    //links
    Stange([-1.0,(1+2*i)*v,0.0],[-1.0,(1+2*i)*v,2.2],2.2,"orange");
    //rechts
    if (i<4) Stange([ 1.0,(1+2*i)*v,0.0],[ 1.0,(1+2*i)*v,1.6],1.6,"orange");
    if (i==4||i==5) {
      Stange([ 1.0,(1+2*i)*v,0.0],[ 1.0,(1+2*i)*v,0.4],0.4,"orange"); 
      Stange([ 1.0,(1+2*i)*v,1.2],[ 1.0,(1+2*i)*v,1.6],0.4,"orange"); 
      }
    if (i==4||i==5||i==6) {
      Stange([0.9,2*i*v,1.3],[1.1,2*i*v,1.3],0.2,"orange");
      Stange([0.9,2*i*v,0.3],[1.1,2*i*v,0.3],0.2,"orange");
      Stange([ 0.7,(1+2*i)*v,0.0],[ 0.7,(1+2*i)*v,0.2],0.2,"orange");
      Stange([-0.7,(1+2*i)*v,0.0],[-0.7,(1+2*i)*v,0.2],0.2,"orange");
      }
    if (i<6) {
      //rechts kurze Fortsetzung Tür
      Stange([ 1.0,(1+2*i)*v,2.0],[ 1.0,(1+2*i)*v,2.2],0.2,"orange");
      }
    if (i<7) {
      //rechts Abschluß Tür
      Stange([0.9,2*i*v,1.5],[1.1,2*i*v,1.5],0.2,"orange");
      }
    if (i>=6) Stange([ 1.0,(1+2*i)*v,0.0],[ 1.0,(1+2*i)*v,2.2],2.2,"orange");
    }

  for (var i=8;i<17;i++) {
    //hinten
    Stange([-1.1,2*i*v,2.1-(i-7)*w],[1.1,2*i*v,2.1-(i-7)*w],2.2,"orange");
    //vorn
    Stange([-1.1,2*i*v,0.1+(i-7)*w],[1.1,2*i*v,0.1+(i-7)*w],2.2,"orange");
    //links
    Stange([-1.0,(1+2*i)*v,0.0+(i-7)*w],[-1.0,(1+2*i)*v,2.2-(i-7)*w],2.2-(i-7)*w*2,"orange");
    //rechts
    Stange([ 1.0,(1+2*i)*v,0.0+(i-7)*w],[ 1.0,(1+2*i)*v,2.2-(i-7)*w],2.2-(i-7)*w*2,"orange");
    }
  i=17;  Stange([-1.1,2*i*v,2.1-(i-7)*w],[1.1,2*i*v,2.1-(i-7)*w],2.2,"orange");

  }

function Demo_Sommer_2023() {
Stange([0,0,0],[1,0,0],1,"red");
Stange([1,0,0],[2,0,0],1,"red");
Stange([2,0,0],[3,0,0],1,"red");
Stange([3,0,0],[3,0,-1],1,"red");
Stange([3,0,-1],[3,0,-2],1,"red");
Stange([3,0,-2],[3,0,-3],1,"red");
Stange([3,0,-3],[2,0,-3],1,"red");
Stange([2,0,-3],[1,0,-3],1,"red");
Stange([1,0,-3],[0,0,-3],1,"red");
Stange([0,0,-3],[0,0,-2],1,"red");
Stange([0,0,-2],[0,0,-1],1,"red");
Stange([0,0,-1],[0,0,0],1,"green");
Stange([1,0,0],[1,0,-1],1,"red");
Stange([1,0,-1],[0,0,-1],1,"red");
Stange([2,0,0],[2,0,-1],1,"red");
Stange([2,0,-1],[2,0,-2],1,"DeepSkyBlue");
Stange([2,0,-2],[2,0,-3],1,"Yellow");
Stange([0,0,-3],[-0.5,0,-3],0.5,"red");
Stange([0,0,-3],[0,2,-3],2,"red");
Stange([2,0,-2],[2,2,-2],2,"red");
Stange([1,0,0],[1,2,0],2,"red");
Stange([0,0,0],[0,1,0],1,"red");
Stange([0,1,0],[0,2,0],1,"red");
Stange([0,0,-1],[0,1,-1],1,"DeepSkyBlue");
Stange([0,1,-1],[0,2,-1],1,"red");
Stange([0,1,0],[0,1,-1],1,"red");
Stange([2,0,0],[2,1,0],1,"DeepSkyBlue");
Stange([2,1,0],[2,2,0],1,"red");
Stange([3,0,0],[3,1,0],1,"red");
Stange([3,0,-1],[3,1,-1],1,"red");
Stange([3,0,-2],[3,1,-2],1,"red");
Stange([3,0,-3],[3,1,-3],1,"red");
Stange([2,0,-3],[2,1,-3],1,"green");
Stange([2,1,-3],[2,2,-3],1,"green");
Stange([2,1,0],[3,1,0],1,"red");
Stange([3,1,0],[3,1,-1],1,"red");
Stange([3,1,-1],[3,1,-2],1,"DeepSkyBlue");
Stange([3,1,-2],[3,1,-3],1,"DeepSkyBlue");
Stange([3,1,-3],[2,1,-3],1,"red");
Stange([0,2,0],[0,2,-1],1,"DeepSkyBlue");
Stange([0,2,-1],[1,2,-1],1,"DeepSkyBlue");
Stange([1,2,-1],[2,2,-1],1,"red");
Stange([2,2,-1],[2,2,-2],1,"red");
Stange([2,2,-2],[2,2,-3],1,"red");
Stange([2,2,-3],[1,2,-3],1,"green");
Stange([1,2,-3],[0,2,-3],1,"red");
Stange([2,2,0],[2,2,-1],1,"DeepSkyBlue");
Stange([1,2,0],[1,2,-1],1,"Yellow");
Stange([0,2,0],[1,2,0],1,"Yellow");
Stange([1,2,0],[2,2,0],1,"red");
Stange([-0.5,0,-3],[-0.5,1,-3],1,"DeepSkyBlue");
Stange([-0.5,1,-3],[-0.5,2,-3],1,"Yellow");
Stange([-0.5,2,-3],[-0.5,2.5,-3],0.5,"red");
Stange([0,2,-3],[0,2.5,-3],0.5,"red");
Stange([2,2,-3],[2,2.5,-3],0.5,"red");
Stange([1,2,-3],[1,2.5,-3],0.5,"red");
Stange([2,2,-2],[2,2.5,-2],0.5,"red");
Stange([2,2,-1],[2,2.5,-1],0.5,"red");
Stange([2,2,0],[2,2.5,0],0.5,"red");
Stange([1,2,0],[1,2.5,0],0.5,"red");
Stange([1,2,-1],[1,2.5,-1],0.5,"red");
Stange([0,2,0],[0,2.5,0],0.5,"red");
Stange([0,2,-1],[0,2.5,-1],0.5,"red");
Stange([0,2.5,0],[0,2.5,-1],1,"Yellow");
Stange([0,2.5,-1],[1,2.5,-1],1,"red");
Stange([1,2.5,-1],[2,2.5,-1],1,"red");
Stange([2,2.5,-1],[2,2.5,-2],1,"DeepSkyBlue");
Stange([2,2.5,-2],[2,2.5,-3],1,"Yellow");
Stange([2,2.5,-3],[1,2.5,-3],1,"red");
Stange([1,2.5,-3],[0,2.5,-3],1,"Yellow");
Stange([0,2.5,-3],[-0.5,2.5,-3],0.5,"red");
Stange([0,2.5,0],[1,2.5,0],1,"Yellow");
Stange([1,2.5,0],[2,2.5,0],1,"Yellow");
Stange([2,2.5,0],[2,2.5,-1],1,"Yellow");
Stange([1,2.5,0],[1,2.5,-1],1,"red");
Stange([1,2,-3],[1,1,-3],1,"red");
Stange([1,1,-3],[1,0,-3],1,"Yellow");
Stange([1,1,-3],[2,1,-3],1,"red");
Stange([1,0,-1],[1,1,-1],1,"green");
Stange([1,1,-1],[1,2,-1],1,"DeepSkyBlue");
  }

function Demo_Diesellok() {
Stange([0,0,0],[1,0,0],1,"DeepSkyBlue");
Stange([1,0,0],[2,0,0],1,"DeepSkyBlue");
Stange([2,0,0],[3,0,0],1,"DeepSkyBlue");
Stange([3,0,0],[3,0,-1],1,"red");
Stange([3,0,-1],[3,0,-2],1,"red");
Stange([3,0,-2],[2,0,-2],1,"red");
Stange([2,0,-2],[2,0,-3],1,"red");
Stange([2,0,-3],[2,0,-4],1,"red");
Stange([2,0,-4],[1,0,-4],1,"red");
Stange([1,0,-4],[1,0,-3],1,"red");
Stange([1,0,-3],[1,0,-2],1,"red");
Stange([1,0,-2],[0,0,-2],1,"red");
Stange([0,0,-2],[0,0,-1],1,"red");
Stange([0,0,-1],[0,0,0],1,"red");
Stange([1,0,-2],[2,0,-2],1,"red");
Stange([0,0,-1],[1,0,-1],1,"red");
Stange([1,0,-1],[1,0,-1.5],0.5,"red");
Stange([1,0,-1.5],[0,0,-1.5],1,"red");
Stange([2,0,-2],[2,0,-1],1,"red");
Stange([2,0,-1],[3,0,-1],1,"red");
Stange([0,0,0],[0,1,0],1,"red");
Stange([1,0,0],[1,1,0],1,"red");
Stange([2,0,0],[2,1,0],1,"red");
Stange([3,0,0],[3,1,0],1,"red");
Stange([3,0,-1],[3,1,-1],1,"red");
Stange([3,0,-2],[3,1,-2],1,"red");
Stange([2,0,-2],[2,1,-2],1,"red");
Stange([1,0,-2],[1,1,-2],1,"red");
Stange([0,0,-2],[0,1,-2],1,"red");
Stange([2,0,-1],[2,1,-1],1,"red");
Stange([0,0,-1.5],[0,1,-1.5],1,"red");
Stange([0,0,-1],[0,1,-1],1,"red");
Stange([1,0,-1],[1,1,-1],1,"red");
Stange([1,0,-1.5],[1,1,-1.5],1,"red");
Stange([0,1,0],[1,1,0],1,"red");
Stange([1,1,0],[2,1,0],1,"red");
Stange([2,1,0],[3,1,0],1,"red");
Stange([3,1,-1],[3,1,-2],1,"red");
Stange([3,1,-2],[2,1,-2],1,"red");
Stange([2,1,-2],[1,1,-2],1,"red");
Stange([1,1,-2],[0,1,-2],1,"red");
Stange([0,1,-2],[0,1,-1.5],0.5,"red");
Stange([0,1,-1.5],[0,1,-1],0.5,"red");
Stange([0,1,-1],[1,1,-1],1,"red");
Stange([1,1,-1],[1,1,-1.5],0.5,"red");
Stange([1,1,-1.5],[0,1,-1.5],1,"red");
Stange([1,0,-3],[1,1,-3],1,"red");
Stange([2,0,-3],[2,1,-3],1,"red");
Stange([1,0,-4],[1,1,-4],1,"red");
Stange([2,0,-4],[2,1,-4],1,"red");
Stange([2,1,-2],[2,1,-3],1,"red");
Stange([2,1,-3],[2,1,-4],1,"red");
Stange([2,1,-4],[1,1,-4],1,"red");
Stange([1,1,-4],[1,1,-3],1,"red");
Stange([1,1,-3],[1,1,-2],1,"red");
Stange([2,1,-3],[1,1,-3],1,"red");
Stange([3,1,0],[3,3,0],2,"red");
Stange([2,1,0],[2,3,0],2,"red");
Stange([1,1,0],[1,3,0],2,"red");
Stange([0,1,0],[0,3,0],2,"red");
Stange([1,1,-1],[1,3,-1],2,"red");
Stange([2,1,-1],[2,3,-1],2,"red");
Stange([3,1,-1],[2,1,-1],1,"red");
Stange([2,1,-1],[2,1,-2],1,"red");
Stange([3,1,-1],[3,2,-1],1,"red");
Stange([3,2,-1],[3,2,-2],1,"red");
Stange([3,2,-1],[3,3,-1],1,"red");
Stange([3,2,-2],[3,1,-2],1,"red");
Stange([3,2,-2],[3,3,-2],1,"red");
Stange([2,1,-2],[2,2,-2],1,"red");
Stange([2,2,-2],[2,3,-2],1,"red");
Stange([1,1,-2],[1,2,-2],1,"red");
Stange([1,2,-2],[1,3,-2],1,"red");
Stange([0,1,-2],[0,2,-2],1,"red");
Stange([0,2,-2],[0,3,-2],1,"red");
Stange([0,1,-1],[0,2,-1],1,"red");
Stange([0,2,-1],[0,3,-1],1,"red");
Stange([0,2,-1],[0,2,-2],1,"red");
Stange([3,3,-2],[2,3,-2],1,"red");
Stange([2,3,-2],[1,3,-2],1,"red");
Stange([1,3,-2],[0,3,-2],1,"red");
Stange([0,3,-2],[0,3,-1],1,"red");
Stange([0,3,-1],[0,3,0],1,"red");
Stange([0,3,0],[1,3,0],1,"red");
Stange([1,3,0],[2,3,0],1,"red");
Stange([2,3,0],[3,3,0],1,"red");
Stange([3,3,0],[3,3,-1],1,"red");
Stange([3,3,-1],[3,3,-2],1,"red");
Stange([2,3,0],[2,3,-1],1,"red");
Stange([2,3,-1],[2,3,-2],1,"red");
Stange([1,3,0],[1,3,-1],1,"red");
Stange([1,3,-1],[1,3,-2],1,"red");
Stange([3,3,-1],[2,3,-1],1,"red");
Stange([2,3,-1],[1,3,-1],1,"red");
Stange([1,3,-1],[0,3,-1],1,"red");
Stange([1.5,1,-4],[1.5,2,-4],1.1,"Yellow");
Stange([1.5,2,-4],[1.5,2,-5],1.1,"Yellow");
Stange([1.5,2,-5],[1.5000000000000004,1.0000000000000002,-5],1.1,"Yellow");
Stange([1.5,1,-5],[0.5000000000000004,1,-5],1.1,"Yellow");
Stange([2.5,1,-5],[1.5,1,-5],1.1,"Yellow");
Stange([2.5,1,-5],[2.5,-5.551115123125783e-17,-5],1.1,"Yellow");
Stange([2.5,0,-5],[1.4999999999999996,0,-5],1.1,"green");
Stange([1.5,0,-5],[0.5000000000000004,0,-5],1.1,"green");
Stange([1.5,0,-5],[1.5000000000000004,1,-5],1.1,"Yellow");
Stange([0.5,0,-5],[0.5000000000000004,1,-5],1.1,"Yellow");
Stange([1.5,2,-4],[1.5,2,-3],1.1,"DeepSkyBlue");
Stange([1.4999999999999996,1.9999999999999998,-3],[1.4999999999999996,1.9999999999999998,-2],1.1,"DeepSkyBlue");
  }


function Test() {
  alert(Knoten.length+"\n"+Stangen.length);
  }
//Test();
//Richtung(0,0,40,Faktor);//ohne dem passt die Kameraposition nicht

//------------die Tasten
Button_links. addEventListener('click',function(){q.GROT(90,0,0)});
Button_rechts.addEventListener('click',function(){q.GROT(-90,0,0)});
Button_hoch.  addEventListener('click',function(){q.GROT(0,-90,0)});
Button_runter.addEventListener('click',function(){q.GROT(0,90,0)});
Button_Stange_einsetzen.addEventListener('click',function(){Stange_von_q_bis_q1("Yellow")});
Button_weitergehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( 0, 0.0, -q1.position.length() )).applyEuler(q.rotation))});
Button_halbweitergehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( 0, 0, -q1.position.length()/2 )).applyEuler(q.rotation))});
Button_zurueckgehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( 0, 0.0, q1.position.length() )).applyEuler(q.rotation))});
Button_halbzurueckgehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( 0, 0, q1.position.length()/2 )).applyEuler(q.rotation))});
Button_ruebergehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( Zylinderradius*2, 0.0, 0 )).applyEuler(q.rotation))});
Button_halbruebergehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( Zylinderradius, 0, 0 )).applyEuler(q.rotation))});
Button_nuebergehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( -Zylinderradius*2, 0.0, 0 )).applyEuler(q.rotation))});
Button_halbnuebergehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( -Zylinderradius, 0, 0 )).applyEuler(q.rotation))});
Button_hochgehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( 0, Zylinderradius*Math.sqrt(3)*2, 0 )).applyEuler(q.rotation))});
Button_halbhochgehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( 0, Zylinderradius*Math.sqrt(3), 0 )).applyEuler(q.rotation))});
Button_runtergehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( 0, -Zylinderradius*Math.sqrt(3)*2, 0 )).applyEuler(q.rotation))});
Button_halbruntergehen.addEventListener('click',function(){q.position.add((new THREE.Vector3( 0, -Zylinderradius*Math.sqrt(3), 0 )).applyEuler(q.rotation))});
Button_verdoppeln.addEventListener('click',function(){q2.position.add(q1.position); q1.position.multiplyScalar(2)});
Button_halbieren.addEventListener('click',function(){q1.position.divideScalar(2); q2.position.sub(q1.position)});
document.getElementById("links" ).addEventListener('click',function(){Richtung(-40,0,0,Faktor)});
document.getElementById("rechts").addEventListener('click',function(){Richtung(+40,0,0,Faktor)});
document.getElementById("hoch"  ).addEventListener('click',function(){Richtung(0,-40,0,Faktor)});
document.getElementById("runter").addEventListener('click',function(){Richtung(0,+40,0,Faktor)});
document.getElementById("hinter").addEventListener('click',function(){Richtung(0,0,-40,Faktor)});
document.getElementById("vor"   ).addEventListener('click',function(){Richtung(0,0,+40,Faktor)});
document.getElementById("rollercoaster").addEventListener('click',function(){train.add(camera);camera.position.set( 0, 0, 1); camera.lookAt(train.position); q.visible=false});
document.getElementById("weiter_mit_QUADRO").addEventListener('click',function(){st.add(camera);camera.position.set(0,0,0); camera.lookAt(QUADRO.localToWorld(cl.clone())); q.visible=true});
document.getElementById("L10").parentNode.addEventListener('click',function(){Faktor=10});
document.getElementById("L20").parentNode.addEventListener('click',function(){Faktor=20});
document.getElementById("L40").parentNode.addEventListener('click',function(){Faktor=40});
document.getElementById("L80").parentNode.addEventListener('click',function(){Faktor=80});
document.getElementById("Löschen").addEventListener('click',Loeschen);
document.getElementById("alles_loeschen").addEventListener('click',alles_loeschen);
document.getElementById("grün"  ).addEventListener('click',function(){Farbe('green')});
document.getElementById("blau"  ).addEventListener('click',function(){Farbe('DeepSkyBlue')});
document.getElementById("orange").addEventListener('click',function(){Farbe('Yellow')});
document.getElementById("rot"   ).addEventListener('click',function(){Farbe('red')});
document.getElementById("Demo").addEventListener('click',Demo);
document.getElementById("Demo_Lok").addEventListener('click',Demo_Lok);
document.getElementById("Demo_Rauner_Lok").addEventListener('click',Demo_Rauner_Lok);
document.getElementById("Demo_Sommer_2023").addEventListener('click',Demo_Sommer_2023);
document.getElementById("Demo_Diesellok").addEventListener('click',Demo_Diesellok);
document.getElementById("Button_Test").addEventListener('click',Test);
document.getElementById("Mini links1"   ).addEventListener('click',function(){Richtung(-40,0,0,10)});
document.getElementById("schräg rechts hoch"  ).addEventListener('click',function(){Richtung(30,-30,0,Faktor)});
document.getElementById("schräg rechts runter").addEventListener('click',function(){Richtung(30,30,0,Faktor)});
document.getElementById("Mini links2"   ).addEventListener('click',function(){Richtung(-40,0,0,10)});
document.getElementById("Mini rechts1"  ).addEventListener('click',function(){Richtung(40,0,0,10)});
document.getElementById("schräg links hoch"  ).addEventListener('click',function(){Richtung(-30,-30,0,Faktor)});
document.getElementById("schräg links runter").addEventListener('click',function(){Richtung(-30,30,0,Faktor)});
document.getElementById("Mini rechts2"  ).addEventListener('click',function(){Richtung(40,0,0,10)});
document.getElementById("Mini hoch"     ).addEventListener('click',function(){Richtung(0,-40,0,10)});
document.getElementById("Mini runter"   ).addEventListener('click',function(){Richtung(0,40,0,10)});
document.getElementById("K10").parentNode.addEventListener('click',function(){Ausrichten=1});
document.getElementById("K20").parentNode.addEventListener('click',function(){Ausrichten=0.05});
document.getElementById("K40").parentNode.addEventListener('click',function(){Ausrichten=0.005});
document.getElementById("K80").parentNode.addEventListener('click',function(){Ausrichten=0});
document.getElementById("Kamera ausrichten").addEventListener('click',function(){Kamera_ausrichten()});
document.getElementById("downloadstart").addEventListener('click',function(){download(document.getElementById("Ausgabedateiname").value,neuerDownloadtext());document.getElementById("download").click()});
document.getElementById("Datei öffnen").addEventListener('input',function(){reader.readAsText(event.target.files[0])});


//---------------- Lichter
// White directional light at half intensity shining from the top.
/*const directionalLight = new THREE.DirectionalLight( 0x44ffff, 0.1 );
QUADRO.add( directionalLight );
const directionalLight2 = new THREE.DirectionalLight( 0x888888, 1 );
directionalLight2.position.z=-20;
directionalLight2.position.y=5;
QUADRO.add( directionalLight2 );
const directionalLight3 = new THREE.DirectionalLight( 0x555555, 0.3 );
directionalLight3.position.y=5;
directionalLight3.position.z=20;
directionalLight3.position.x=-70;
QUADRO.add( directionalLight3 );
*/
//const light = new THREE.AmbientLight( 0xC0C0C0 ); // soft white light
//QUADRO.add( light );
// White directional light at half intensity shining from the top.
const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.6 );
directionalLight.position.set(-1,5,2);
scene.add( directionalLight );

const directionalLight2 = new THREE.DirectionalLight( 0xffff00, 0.4 );
directionalLight2.position.set(-4,3,-20);
scene.add( directionalLight2);

const directionalLight3 = new THREE.DirectionalLight( 0x00ffff, 0.2 );
directionalLight3.position.set(70,6,-20);
scene.add( directionalLight3);








//-----------------

var Ausrichten=0.005;
let Himmelsrichtung=0;
let worldDirection=new THREE.Vector3();
let Distanzrichtung=new THREE.Vector3();

//--------

			function render() {

				const time = performance.now();
				const delta = time - prevTime;

				for ( let i = 0; i < funfairs.length; i ++ ) {

					funfairs[ i ].rotation.y = time * 0.0004;

				}

				//

				progress += velocity;
				progress = progress % 1;

				position.copy( curve.getPointAt( progress ) );
				position.y += 0.3;

				train.position.copy( position );

				tangent.copy( curve.getTangentAt( progress ) );

				velocity -= tangent.y * 0.0000001 * delta;
				velocity = Math.max( 0.00004, Math.min( 0.0002, velocity ) );

				train.lookAt( lookAt.copy( position ).sub( tangent ) );

				//

//----QUADRO

  if (q.visible) {

    var diff=new THREE.Vector3();
    diff.subVectors(q.position,cl);
  
    if (diff.length()>0.01) {
      if (Ausrichten<1) diff.normalize().multiplyScalar(Ausrichten);
      cl.add(diff);
      st.position.setFromSphericalCoords(distanz,gamma,delta2).add(cl);
      st.lookAt(QUADRO.localToWorld(cl.clone()));
st.rotateY(-Math.PI);
//      camera.lookAt(QUADRO.localToWorld(cl.clone()));
      }

    //document.getElementById("Log2").firstChild.nodeValue=JSON.stringify(QUADRO.localToWorld(st.position.clone()))+"\n"+JSON.stringify(QUADRO.localToWorld(cl.clone()));
    //document.getElementById("Log2").firstChild.nodeValue=JSON.stringify(st.position.clone())+"\n"+JSON.stringify(QUADRO.localToWorld(st.position.clone()));
    //document.getElementById("Log2").firstChild.nodeValue=gamma+" "+delta2+" "+distanz;
    if (renderer.xr.isPresenting/*getCamera().cameras.length*/) document.getElementById("Log2").firstChild.nodeValue=renderer.xr.getCamera().cameras[0].matrixWorldInverse.elements.slice(12,15).join("  ")+"\n"+renderer.xr.getCamera().cameras[1].matrixWorld.elements.slice(12,15).join("  ");
    }

    //neu ab 2024__10_23:♥

if (J_selected) {
   //distanz=distanz+1.0;
   if (J_selected==J_rechts) delta2=delta2+0.01;
   if (J_selected==J_links) delta2=delta2-0.01;
   if (J_selected==J_hoch) gamma=gamma-0.01;
   if (J_selected==J_runter) gamma=gamma+0.01;
   if (J_selected==J_vor) distanz=distanz-0.01;
   if (J_selected==J_zurueck) distanz=distanz+0.01;
   st.position.setFromSphericalCoords(distanz,gamma,delta2).add(cl);//???gewagt
   //st.rotateY(0.01);//eigentlich müsste hier camera.lookAt(QUADRO.localToWorld(cl.clone())) stehen, geht aber nicht
   st.lookAt(QUADRO.localToWorld(cl.clone()))
st.rotateY(-Math.PI);
//was alles nicht geht:
//   camera.rotateZ(0.1);
//   camera.lookAt(QUADRO.localToWorld(cl.clone()));
//   camera.updateProjectionMatrix();
//   controller.lookAt(QUADRO.localToWorld(J_rechts.position.clone()));
//   renderer.xr.updateCamera(camera);//Richtung lookAt(q.position) funktioniert leider nicht
   }


    Himmelsrichtung=Math.atan2(st.position.x-cl.x,st.position.z-cl.z);
    Distanzrichtung=cl.clone().sub(st.position).normalize();
    camera.getWorldDirection(worldDirection)//nicht verwendet
    //J_rechts.position.set((st.position.x+q.position.x)/2+Math.cos(Himmelsrichtung),(st.position.y+q.position.y)/2,(st.position.z+q.position.z)/2-Math.sin(Himmelsrichtung));
    //J_rechts.position.set((st.position.x-worldDirection.x)+Math.cos(Himmelsrichtung)*0.2,(st.position.y+worldDirection.y),(st.position.z-worldDirection.z)-Math.sin(Himmelsrichtung)*0.2);
//    J_rechts.position.set((st.position.x+Distanzrichtung.x)+Math.cos(Himmelsrichtung)*0.1,(st.position.y+Distanzrichtung.y),(st.position.z+Distanzrichtung.z)-Math.sin(Himmelsrichtung)*0.1);
    Log3.innerHTML='q='+JSON.stringify(q.position)
      +';\n st='+JSON.stringify(st.position)
      +';\n QUADRO='+JSON.stringify(QUADRO.position)
      +';\n J_rechts='+JSON.stringify(J_rechts.position)
      +';\n Himmelsrichtung='+Himmelsrichtung      
      +';\n Distanzrichtung='+JSON.stringify(Distanzrichtung)
      +';\n camera.getWorldDirection()='+JSON.stringify(worldDirection) 
      +';\n st.position='+JSON.stringify(st.position) 
      +';\n st.getWorldDirection()='+JSON.stringify(st.getWorldDirection(worldDirection)) 
      ;




//----------


		cleanIntersected();

  if((VRButt.textContent!="ENTER VR")&&(VRButt.textContent!="VR NOT SUPPORTED")&&(J_selected==false)) {
		intersectObjects( controller1 );//CONT lässt die Stangen aufleuchten
		//intersectObjects( controller2 );
    }

				renderer.render( scene, camera );

				prevTime = time;

			}

			renderer.setAnimationLoop( render );
			
			


//------------------------touchevents

var TouchposX=0;
var TouchposY=0;
var Touch2posX=0;
var Touch2posY=0;
var cameraposalt=0;
var gammaalt=0;
var deltaalt=0;
var distanzalt=0;
var touchzahl=0;


function Bild_touchstart() {
  var Touch=event.targetTouches.item(0);
  //document.getElementById("Log").firstChild.nodeValue=Touch.clientX+" "+Touch.clientY;
  TouchposX=Touch.clientX;
  TouchposY=Touch.clientY;
  cameraposalt=st.position.clone();
  gammaalt=gamma;
  deltaalt=delta2;
  distanzalt=distanz;
  touchzahl=1;
  //event.preventDefault();
  }

function Bild_touchmove() {
	  //var Log=event.targetTouches.length;
  var Touch=event.targetTouches.item(0);
  if (event.targetTouches.length==1&&touchzahl==1) {
    gamma=Math.min(Math.PI-0.01,Math.max(0.01,gammaalt-(Touch.clientY-TouchposY)/8/180*Math.PI));
    delta2=deltaalt-(Touch.clientX-TouchposX)/4/180*Math.PI;
    //alert(distanz+" "+st.position.clone().sub(cl).length());
    st.position.setFromSphericalCoords(distanz,gamma,delta2).add(cl);//???gewagt
    st.lookAt(QUADRO.localToWorld(cl.clone()));//♥neu zusätzlich, sogar mit rotate
st.rotateY(-Math.PI);
//    camera.lookAt(QUADRO.localToWorld(cl.clone()));
    //document.getElementById("Log").firstChild.nodeValue=Touch.clientX+" "+Touch.clientY;
    //touchzahl=1;
    } else {
      var Touch2=event.targetTouches.item(1);
      if (touchzahl==1) {
        touchzahl=2;
        TouchposX=Touch.clientX;
        Touch2posX=Touch2.clientX;
        TouchposY=Touch.clientY;
        Touch2posY=Touch2.clientY;
        distanzalt=distanz;
        } else {
          distanz=distanzalt-(Math.sqrt((Touch.clientX-Touch2.clientX)**2+(Touch.clientY-Touch2.clientY)**2)-Math.sqrt((TouchposX-Touch2posX)**2+(TouchposY-Touch2posY)**2))/50;
          distanz=Math.min(Math.max(distanz,1),10);
          }
      st.position.setFromSphericalCoords(distanz,gamma,delta2).add(cl);
      st.lookAt(QUADRO.localToWorld(cl.clone()));//♥neu zusätzlich, sogar mit rotate
st.rotateY(-Math.PI);
//      camera.lookAt(QUADRO.localToWorld(cl.clone()));
      }
  //document.getElementById("Log2").firstChild.nodeValue=Log;
  event.preventDefault();
  }

//var sminind=0;//schon oben
function Bild_dblclick() {//let inputSourceList = xrSession.inputSources;alert(inputSourceList);
  var mouse=new THREE.Vector3();
  //var Log="mouse=["+(event.clientX-event.target.getBoundingClientRect().left)+","+(event.clientY-event.target.getBoundingClientRect().top)+"]"+event.target.getBoundingClientRect().width+" "+event.target.getBoundingClientRect().height+"\n";
  mouse.x = ( (event.clientX-event.target.getBoundingClientRect().left) / event.target.getBoundingClientRect().width ) * 2 - 1;//+0.34;
  mouse.y = - ( (event.clientY-event.target.getBoundingClientRect().top) / event.target.getBoundingClientRect().height ) * 2 + 1;// -0.31;
  mouse.z = 0.96;
  //Log=Log+"mouse=["+mouse.toArray()+"]; Knoten.length="+Knoten.length+";\n";
  var min=100000;
  var minind=0;
  for (var i=0;i<Knoten.length;i++) {
    //Log=Log+"Knoten "+i+" = "+Knoten[i].clone().toArray()+"; project="+QUADRO.localToWorld(Knoten[i].clone()).project(camera).toArray()+"\n";
    var dist=QUADRO.localToWorld(Knoten[i].clone()).project(camera).distanceToSquared(mouse);
    if (dist<min) {min=dist; minind=i}
    //Log=Log+minind+" "+dist+"\n";
    }

  //Log=Log+"q.position.project="+q.position.clone().project(camera).toArray()+"\n";
  //Log=Log+event.clientX+" "+event.clientY+" "/*+clock.getDelta()*/+"\n";
  //clock.start();
  if (min>0.1) { if (mouse.y>-0.7) q.visible=false; s.visible=false; } else {
    q.visible=true;
    q.position.copy(Knoten[minind]);
    s.visible=true;

    var smin=100000;
    sminind=0;
    for (var i=0;i<Stangen.length;i++) {
      //Log=Log+"Stange "+i+" = "+Stangen[i].position.toArray()+";nproject="+QUADRO.localToWorld(Stangen[i].position.clone()).project(camera).toArray()+"\n";
      var dist=QUADRO.localToWorld(Stangen[i].position.clone()).project(camera).distanceToSquared(mouse);
      if (dist<smin) {smin=dist; sminind=i}
      //Log=Log+"sminind="+sminind+", smin="+smin+"\n";
      }

    s.position.copy(Stangen[sminind].position);
    }
  //document.getElementById("Log2").firstChild.nodeValue=Log;
  }

function Kamera_ausrichten() {
  cl.copy(q.position);
  st.position.setFromSphericalCoords(distanz,gamma,delta2).add(q.position);
  st.lookAt(QUADRO.localToWorld(cl.clone()));//♥neu zusätzlich, sogar mit rotate
st.rotateY(-Math.PI);
//  camera.lookAt(QUADRO.localToWorld(cl.clone()));
  }


//------------------------dragevents laut https://uxdesign.cc/implementing-a-custom-drag-event-function-in-javascript-and-three-js-dc79ee545d85
var mouseDown = false, mouseX = 0, mouseY = 0;
function Bild_dragstart(event) {
  mouseDown=true;
  TouchposX=event.clientX;
  TouchposY=event.clientY;
  cameraposalt=st.position.clone();
  gammaalt=gamma;
  deltaalt=delta2;
  distanzalt=distanz;
  event.preventDefault();
  document.getElementById("Log").innerHTML=[TouchposX,TouchposY,gammaalt,deltaalt,distanzalt];
  }

function Bild_dragmove() { if (mouseDown==true) {
  document.getElementById("Log").innerHTML=[event.clientX,event.clientY];
  gamma=Math.min(Math.PI-0.01,Math.max(0.01,gammaalt-(event.clientY-TouchposY)/8/180*Math.PI));
  delta2=deltaalt-(event.clientX-TouchposX)/4/180*Math.PI;
  st.position.setFromSphericalCoords(distanz,gamma,delta2).add(cl);//???gewagt
  st.lookAt(QUADRO.localToWorld(cl.clone()));//♥neu zusätzlich, sogar mit rotate
st.rotateY(-Math.PI);
//  camera.lookAt(QUADRO.localToWorld(cl.clone()));
  event.preventDefault();
  document.getElementById("Log").innerHTML=[TouchposX,TouchposY,gamma,delta2];
  } }

function Bild_dragend(event) {
  mouseDown=false;
  document.getElementById("Log").innerHTML="mouseup";
  }

function Bild_keydown(event) {
  if (event.code=="Space") {
    do sminind=sminind+1; while (sminind<Stangen.length&&Stangen[sminind].wheel==undefined);
    if (sminind==Stangen.length) {
      sminind=0;
      do sminind=sminind+1; while (sminind<Stangen.length&&Stangen[sminind].wheel==undefined);
      }
    stwheel(0);
    event.preventDefault();
    }
  }

function stwheel(deltaY) {
  Stangen[sminind].translateY(-0.25).rotateX(Math.PI/24/53*deltaY).translateY(0.25);
  Stangen[sminind].updateMatrix();
  Stangen[sminind].updateMatrixWorld(true);
  s.position.copy(Stangen[sminind].position);
  q.position.copy(QUADRO.worldToLocal(Stangen[sminind].localToWorld(new THREE.Vector3(0,0.25,0))));
    }

function Bild_wheel(event) {
  document.getElementById("Log").innerHTML=[event.deltaX,event.deltaY,event.deltaZ];
  //distanz=distanzalt-(Math.sqrt((Touch.clientX-Touch2.clientX)**2+(Touch.clientY-Touch2.clientY)**2)-Math.sqrt((TouchposX-Touch2posX)**2+(TouchposY-Touch2posY)**2))/50;
  if (Stangen[sminind].wheel) {
   Stangen[sminind].wheel(event.deltaY);
    } else {
      if (event.deltaY<0) distanz=distanz-0.1; else distanz=distanz+0.1; 
      distanz=Math.min(Math.max(distanz,3),10);
      st.position.setFromSphericalCoords(distanz,gamma,delta2).add(q.position);
      }
  st.lookAt(QUADRO.localToWorld(cl.clone()));//♥neu zusätzlich, sogar mit rotate
st.rotateY(-Math.PI);
//  camera.lookAt(QUADRO.localToWorld(cl.clone()));
  event.preventDefault();
  }

//--------Download

var reader = new FileReader();
reader.onload = function(e) {
  var Eingabe=e.target.result;
  //document.getElementById("Log").firstChild.nodeValue=Eingabe;
  //alert("los");
  var l=Stangen.length;
  if (l>0) {alert("Erst ganze Seite neu laden, sonst geht es nicht"); return}
  //for (var i=0;i<l;i++) Loeschen();
  //alert("lösch");
  Stangen=[];
  Knoten=Knoten.slice(0,1);
  eval(Eingabe.slice(Eingabe.indexOf('N">')+3,-25));
  };

function download(filename, text) {
  //alert("als Datei "+filename+" wird gespeichert:\n\n"+text);
  //var pom = document.createElement('a');
  var pom=document.getElementById("download");
  pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  pom.setAttribute('download', filename);
  pom.firstChild.nodeValue="Download "+filename;
  }

function neuerDownloadtext() {
  //return Downloadtext+"</KLETTERN_UND_RUTSCHEN>\n";
  var Text='<?xml version="1.0" encoding="utf-8" ?>\n<KLETTERN_UND_RUTSCHEN xmlns="https://github.com/OpaStefanVogel/KLETTERN_UND_RUTSCHEN">\n';
  //alert(Stangen.length);
  for (var i=0;i<Stangen.length;i++) {
    Text=Text+"Stange(["+Stangen[i].Stange[0]+"],["+Stangen[i].Stange[1]+"],"+Stangen[i].Stange[2]+',"'+Stangen[i].Stange[3]+'");\n';
    }
  Text=Text+"</KLETTERN_UND_RUTSCHEN>\n";
  return Text;
  }

Demo(); //weil in body onload='Demo()' nicht funktioniert
		</script>
<!--
ok Knoten.push(q.position) nur wenn noch nicht dabei
  .. besser aber anstelle Array Knoten die Stangenenden durchsuchen
-->
	</body>
</html>
