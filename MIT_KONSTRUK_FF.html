<!DOCTYPE html>
<html>
<head>
  <!-- verwendete Vorlage: three-cookbook/.../01.05-setup-animation-loop.html -->
  <!-- was noch nicht geht:
.. Reihenfolge ASD soll positive Seite der Ebene bestimmen
.. die stimmt aber nicht beim Keil, deshalb auch -ASD
    -->
  <meta charset="utf-8"/>
  <title>MIT_KONSTRUK_FF.html</title>
  <script src="../libs/three.js"></script>
  <script src="../three.js/build/three.js"></script>
  <!--script src="../threejs-cookbook/libs/three.js"></script>
  <script src="../threejs-cookbook/libs/OrbitControls.js"></script>
  <script src="../threejs-cookbook/libs/Projector.js"></script>
  <script src="../threejs-cookbook/libs/dat.gui.min.js"></script>
  <script src="../threejs-cookbook/libs/clock.js"></script-->
  <script src="threejs-cookbook/libs/three.js"></script>
  <script src="threejs-cookbook/libs/OrbitControls.js"></script>
  <script src="threejs-cookbook/libs/Projector.js"></script>
  <script src="threejs-cookbook/libs/dat.gui.min.js"></script>
  <script src="threejs-cookbook/libs/clock.js"></script>
  <style>
     body {
       margin: 1;
       overflow: auto;
       }

    button {font-size:200%}
    </style>
  </head>
<body onload="Beispiel4()">
<!--canvas id="Uhr"> </canvas-->
<div>zur Zeit 3 Eingabebeispiele: 
  <button onclick="Beispiel1()">REST5</button>,
  <button onclick="Beispiel2()">GOKART</button> und
  <button onclick="Beispiel3()">DACH</button>.
  <button onclick="Beispiel4()">QUADER</button>.
  </div>
<button onclick='TA()'>TA()</button>
<button onclick='TS()'>TS()</button>
<button onclick='TD()'>TD()</button>

<button onclick='TUmdrehen()'>umdrehen</button>
<button onclick='TMerken()'>merken</button>
<button onclick='TKopieren()'>kopieren</button>
<button onclick='TVerschieben()'>verschieben</button>
<button onclick='TDrehen()'>drehen</button>
<button onclick='TSchneiden()'>schneiden</button>
<button onclick='TLoeschen()'>löschen</button>




<div style="max-width:90%;max-height:80%; height:550px; border:solid; border-color:red; overflow:hidden" id="canvas"	>hier kommt das render.domElement rein</div>
<button onclick='alert(JSON.stringify(VAS.geometry.vertices));alert(document.getElementById("canvas").scrollHeight)'>Test</button>
<button onclick='contr.target.copy(q.position)'>Zentrieren</button>
<button onclick='Einzelobjekt()'>einzeln</button>
<span id="Pdisp">...</span>;
  </div>
<div id="Log2" style="display:flex; overflow:auto; border:solid; width:90%; height:200px"> div</div>
<div id="Log" style="display:flex; overflow:auto; border:solid; width:90%; height:200px"> div</div>
<div id="KPLOTelement">KPLOT</div>

<script src="QWASNEU/KONSTRUK_javascript.js"></script>

<script>
//var Uhr = document.getElementById('Uhr'); 
//Uhr.width=51; Uhr.height=51; 
//clock(Uhr);
  </script>

<script>//globale Variablen
var renderer;
var scene;
var camera;
//var raycaster = new THREE.Raycaster(); //aus three.js.pdf
var mouse = { x : 0, y : 0 }; 
var Castlist=[];
var q; //PUNKT_Q;
var PA,PS,PD;
var VAS;
var EASD;
var canvas_height=0;
var canvas_width=0;
var zoom=20;
var Linientyp=0;
var cube;
var REST5;
var cmin=0;
var OBJ_X=cmin;
var OBJ_Y=cmin;
var SCHNITTEBENE;
var SAMMELEBENE=[[],[],[],[]];
var Logtext2=[];
var LT=[];
var SCHNITTVEKTOR_AS=0;
var SCHNITTEBENE_ASD=0;
var MERKOBJEKT=[[],[],[],[]];
var History=[];
  </script>

<script>//globale Funktionen
function init() {
  zoom=20;
  Linientyp=0;
  PUNKT_A=[0,0,0,1];
  Castlist=[];

  // create a scene, that will hold all our elements such as objects, cameras and lights.
  scene = new THREE.Scene();
  canvas_height=window.innerHeight;//document.getElementById("canvas").clientHeight;
  canvas_width=window.innerWidth;  //document.getElementById("canvas").clientWidth;
  //alert(canvas_width+" "+canvas_height);

  // create a camera, which defines where we‘re looking at.
  //camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera = new THREE.PerspectiveCamera(45, canvas_width / canvas_height, 0.1, 1000);
  //alert(THREE.WebGLRenderer); //geht nicht bei MINT

  // create a render, sets the background color and the size
  renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(0xCCCC00, 1.0);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.addEventListener( 'click', raycast, false );

        // add light
        var light = new THREE.DirectionalLight();
        light.position.set(1200, 1200, 1200);
        scene.add(light);

  // create a cube and add to scene
  var cubeGeometry = new THREE.BoxGeometry(0.1 /* 10 * Math.random()*/, 0.1, 0.1);
//alert(JSON.stringify(cubeGeometry.faces));
  var cubeMaterial = new THREE.MeshNormalMaterial();
  cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  cube.name = 'cube';
  cube.position.x=0;
  scene.add(cube);

  //Pointer Q
  //var qGeometry = new THREE.SphereGeometry( 0.14, 32, 32 );
  var qGeometry = new THREE.BoxGeometry(0.17, 0.17, 0.17);
  var qMaterial = new THREE.MeshBasicMaterial( { color: 0xFFFF00, opacity:0.5, transparent:true } );
  q = new THREE.Mesh( qGeometry, qMaterial );
  q.position.x=205/zoom;
  q.position.z=150/zoom;
  scene.add( q );
  //Knoten.push(q.position.clone());

  var AGeometry = new THREE.SphereGeometry( 0.09, 32, 32 );
  var AMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity:0.5, transparent:true } );
  PA = new THREE.Mesh( AGeometry, AMaterial );
  PA.position.x=20/zoom;
  PA.position.z=0/zoom;
  scene.add( PA );
  
  var SGeometry = new THREE.SphereGeometry( 0.095, 32, 32 );
  var SMaterial = new THREE.MeshBasicMaterial( { color: 0x0000FF, opacity:0.5, transparent:true } );
  PS = new THREE.Mesh( SGeometry, SMaterial );
  PS.position.x=10/zoom;
  PS.position.y=30/zoom;
  PS.position.z=10/zoom;
  scene.add( PS );

  var DGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
  var DMaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, opacity:0.5, transparent:true } );
  PD = new THREE.Mesh( DGeometry, DMaterial );
  PD.position.x=0/zoom;
  PD.position.z=40/zoom;
  scene.add( PD );

  var VASmaterial = new THREE.LineBasicMaterial({ color: 0x778899, linewidth:4});
  var VASgeometry = new THREE.Geometry();
  VASgeometry.vertices = [PA.position,PS.position];
  //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
  VAS = new THREE.Line(VASgeometry, VASmaterial);
  scene.add( VAS );

  var EASDmaterial = new THREE.LineBasicMaterial({ color: 0x996633, linewidth:3});
  var EASDgeometry = new THREE.Geometry();
  EASDgeometry.vertices = [PA.position,PD.position];
  //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
  EASD = new THREE.Line(EASDgeometry, EASDmaterial);
  scene.add( EASD );

  // position and point the camera to the center of the scene
  camera.position.x = 5; //15;
  camera.position.y = 5; //16;
  camera.position.z = -12; //13
  camera.lookAt(scene.position);

  // add the output of the renderer to the html element
  document.getElementById("canvas").replaceChild(renderer.domElement,document.getElementById("canvas").firstChild);

  contr = new THREE.OrbitControls( camera ,document.getElementById("canvas"));

  scene.add(Testspline());
  }
  </script>

<script>
var DrehenASD=function(OBJ_X) {

  var RET=TRANSFORM(OBJ_X,[[1,0,0,PA.position.x*zoom],[0,1,0,PA.position.y*zoom],[0,0,1,PA.position.z*zoom],[0,0,0,1]]);

  var alpha=0; 
  if((PS.position.z-PA.position.z)**2+(PS.position.x-PA.position.x)**2>0.00001) {
    alpha=-Math.atan2(PS.position.x-PA.position.x,PS.position.z-PA.position.z);
    }
  if (Logflag==true) alert("Drehen mit alpha="+(alpha*180/Math.PI));
  var ca=Math.cos(alpha); 
  var sa=Math.sin(alpha); 
  RET=TRANSFORM(RET,[[ca,0,-sa,0],[0,1,0,0],[sa,0,ca,0],[0,0,0,1]]); 

  var beta=0;
  if(((PD.position.z-PA.position.z)**2+(PD.position.y-PA.position.y)**2>0.00001)/*&&((PS.position.z-PA.position.z)**2+(PS.position.y-PA.position.y)**2>0.00001)*/) {
    beta=-Math.atan2(Math.sqrt((PD.position.z-PA.position.z)**2+(PD.position.x-PA.position.x)**2),PD.position.y-PA.position.y);
    beta=beta+Math.atan2(Math.sqrt((PS.position.z-PA.position.z)**2+(PS.position.x-PA.position.x)**2),PS.position.y-PA.position.y);
    }
  if (Logflag==true) alert("beta="+(beta*180/Math.PI));
  var cb=Math.cos(beta); 
  var sb=Math.sin(beta); 
  RET=TRANSFORM(RET,[[1,0,0,0],[0,cb,-sb,0],[0,sb,cb,0],[0,0,0,1]]);

  var gamma=0; 
  if((PD.position.z-PA.position.z)**2+(PD.position.x-PA.position.x)**2>0.00001) {
    gamma=Math.atan2(PD.position.x-PA.position.x,PD.position.z-PA.position.z);
    }
  var cc=Math.cos(gamma); 
  var sc=Math.sin(gamma); 
  RET=TRANSFORM(RET,[[cc,0,-sc,0],[0,1,0,0],[sc,0,cc,0],[0,0,0,1]]); 

  RET=TRANSFORM(RET,[[1,0,0,-PA.position.x*zoom],[0,1,0,-PA.position.y*zoom],[0,0,1,-PA.position.z*zoom],[0,0,0,1]]); 

  return RET;
  }

  </script>

<script>
var neuen_Balken_plazieren=function(x,y,z,l,b,h) {
  PUNKT_A=[x,y,z,1];
  var RET=QUADER(l,b,h);
  KFILL(RET);
  KDUMP(RET);
  KPLOT([RET]);
  AddObjekt(scene,RET);
  return RET;
  }
  </script>

<script>
var Beispiel1=function() {
  init();
  Linientyp=0; //Röhren
  Logtext2=[];
  OBJ_Y=0;
  History=[];

var BALKEN1=QUADER(200,100,150); KFILL(BALKEN1);
var SCHNITT2=EBENE([100,0,0,1],[200,50,150,1],[200,0,90,1]);
var REST1=RUMPS(BALKEN1,SCHNITT2,1);
TRANSFORM(REST1,A);
TRANSFORM(SCHNITT2,CDF);
var REST2=RUMPS(REST1,SCHNITT2,1);
var BALKEN2=QUADER(60,60,60); KFILL(BALKEN2);
var C=[[1,0,0,10],[0,1,0,10],[0,0,1,10],[0,0,0,1]];
TRANSFORM(BALKEN2,C);
var REST3=RUMPS(BALKEN1,BALKEN2,1);
var REST4=RUMPS(REST2,BALKEN2,1);
PUNKT_A=[-10,75,-10,1];
var BALKEN3=QUADER(100,15,100); KFILL(BALKEN3);
Logflag=true;
REST5=RUMPS(REST4,BALKEN3,1);
//REST5=BALKEN1;
Logtext=Logtext+"REST5="+JSON.stringify(REST5)+"\n";
Logtext=Logtext+"BALKEN3="+JSON.stringify(BALKEN3)+"\n";
KPLOT([REST1]);
KPLOT([REST4]);
KPLOT([REST5]);
Castlist.push(REST5);
cube.geometry.faces[0].color = new THREE.Color(0x000000); 
AddObjekt(scene,REST5);
TQ(20,0,0,0);
TA();
TQ(10,30,10,0);
TS();
TQ(0,0,40,0);
TD();
/*6*/ TQ(73.0598058481,54.6307707698,36.8107501871,0);
/*7*/ TA();
/*8*/ TQ(5,50,150,0);
/*9*/ TS();
/*10*/ TQ(50,0,25,0);
/*11*/ TD();
/*12*/ TMerken();
/*13*/ TQ(47.5,75,90,0);
/*14*/ TA();
/*15*/ TQ(45.9008335412,75,41.8945745584,0);
/*16*/ TS();
/*17*/ TQ(82.1589723069,17.1307707698,0,0);
/*18*/ TD();
/*19*/ TSchneiden();
/*20*/ TQ(25.4504167706,75,26.0311116505,0);
/*21*/ TA();
/*22*/ TQ(86.5448886333,87.9124259819,90,0);
/*23*/ TS();
/*24*/ TQ(67.6002792229,95,84.4040152164,0);
/*25*/ TD();
/*26*/ //TSchneiden();

Logtext=JSON.stringify(cube.geometry.faces)+"\n"+Logtext;

  Logfile();
  Logfile2();

  //var xm=new XMLSerializer();
  //alert(xm.serializeToString(renderer.domElement));
  //alert(renderer.domElement);
 
  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }

  </script>

<script>
var Beispiel2=function() {
  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  
  // position and point the camera to the center of the scene
  camera.position.x = -5; //5; //15;
  camera.position.y = 5; //5; //16;
  camera.position.z = -12; //-12; //13
  camera.lookAt(scene.position);

/*
  PA.position.x=0/zoom;
  PA.position.y=0/zoom;
  PA.position.z=0/zoom;

  PS.position.x=0/zoom;
  PS.position.y=0/zoom;
  PS.position.z=1700/zoom;

  PD.position.x=130/zoom;
  PD.position.y=120/zoom;
  PD.position.z=1250/zoom;
*/

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//      " >P -250 0 0 Anlegepunkt" INTERPRET
//      " >Q 18 1700 180 rechtesBrett" INTERPRET
var rechtes_Brett=neuen_Balken_plazieren(-250,0,0,18,180,1700);

//      " >P -500 0 0 Anlegepunkt" INTERPRET
//      " >Q 30 700 180 HochzuBrett" INTERPRET
var Hochzubrett=neuen_Balken_plazieren(-500,0,0,30,180,700);

//      " >P -750 0 0 Anlegepunkt" INTERPRET
//      " >Q 20 2000 20 Bügel" INTERPRET
var Buegel=neuen_Balken_plazieren(-750,0,0,20,20,2000);




//Logflag=true;
//Testflag=true;
LT=[
"TQ(-232,0,0,2)",
"TA()",
"TQ(0,0,0,0)",
"TS()",
"TQ(-250,180,1700,2)",
"TKopieren()",
"TVerschieben()",
"TQ(-250,0,0,2)",
"TA()",
"TQ(355,0,0,0)",
"TS()",
"TQ(-232,180,1700,2)",
"TVerschieben()",
"TQ(0,0,0,0)",
"TA()",
"TQ(0,0,1700,5)",
"TS()",
"TQ(130,0,1250,1)",
"TD()",
"TQ(-18,180,1700,5)",
"TDrehen()",
"TQ(130,120,1250,1)",
"TS()",
"TQ(130,0,1250,1)",
"TD()",
"TQ(250,120,1620,1)",
"TSchneiden()",
"TQ(177.5,115,0,0)",
"TSchneiden()",
"TQ(355,0,0,0)",
"TA()",
"TQ(355,0,1700,2)",
"TS()",
"TQ(250,0,1250,1)",
"TD()",
"TQ(373,180,1700,2)",
"TDrehen()",
"TQ(250,0,1250,1)",
"TS()",
"TQ(250,120,1250,1)",
"TD()",
"TQ(190,120,1250,1)",
"TSchneiden()",
"TQ(183.48,0,115,0)",
"TSchneiden()",
"TQ(193.7,120,1620,1)",
"TA()",
"TQ(218.92,60,1620,1)",
"TS()",
"TQ(168.48000000000002,60,1620,1)",
"TD()",
"TQ(212.70114787936444,180,1694.0339538170856,2)",
"TSchneiden()",
"TQ(157.94811390479882,0,1692.7422701976568,5)",
"TSchneiden()",
"TQ(-500,90,0,3)",
"TA()",
"TQ(177.5,0,0,0)",
"TS()",
"TQ(-485,180,0,3)",
"TVerschieben()",
"TQ(177.5,0,0,0)",
"TA()",
"TQ(177.5,0,700,3)",
"TS()",
"TQ(177.5,90,0,3)",
"TD()",
"TQ(177.5,-90,0,3)",
"TDrehen()",
"TQ(177.5,5.5109105961630896e-15,-90,3)",
"TS()",
"TQ(0,0,0,0)",
"TD()",
"TQ(207.5,350,90.00000000000003,3)",
"TDrehen()",
"TQ(-750,0,0,4)",
"TA()",
"TQ(-750,20,0,4)",
"TA()",
"TQ(87.5,700,-29.999999999999986,3)",
"TS()",
"TQ(-730,0,1000,4)",
"TKopieren()",
"TVerschieben()",
"TQ(-730,20,0,4)",
"TA()",
"TQ(267.50000000000006,700,-30.000000000000018,3)",
"TS()",
"TQ(-730,0,1000,4)",
"TVerschieben()",
"TQ(87.5,700,-29.99999999999999,6)",
"TA()",
"TQ(87.5,700,1970,6)",
"TS()",
"TQ(168.48000000000002,120,1620,1)",
"TD()",
"TQ(87.5,700,1970,6)",
"TDrehen()",
"TQ(267.5000000000001,700,-30.000000000000014,4)",
"TA()",
"TQ(267.5000000000001,700,1970,4)",
"TS()",
"TQ(218.92,120,1620,1)",
"TD()",
"TQ(267.5000000000001,700,1970,4)",
"TDrehen()",
"TQ(190,120,1250,1)",
"TA()",
"TQ(193.7,120,1620,1)",
"TS()",
"TQ(218.92,120,1620,1)",
"TD()",
"TQ(179.84152492372203,28.027354163578536,1851.495630083249,6)",
"TSchneiden()",
"TQ(211.96875676696882,37.008623401441696,1856.0961575648632,4)",
"TSchneiden()",
"TQ(87.50000000000001,700.0000000000001,-29.999999999999943,6)",
"TA()",
"TQ(97.1632037211084,681.1292704136066,-37.10760569542027,6)",
"TS()",
"TVerschieben()",
"TQ(267.50000000000006,700,-30.000000000000018,3)",
"TA()",
"TQ(257.69944764911827,681.130865323084,-36.92133875504069,4)",
"TS()",
"TVerschieben()",
"TQ(267.50000000000006,700,-15.000000000000018,3)",
"TA()",
"TQ(87.50000000000004,700,-14.999999999999984,3)",
"TS()",
"TQ(87.5,5.5109105961630896e-15,-14.999999999999984,3)",
"TD()",
"TQ(106.82640744221679,662.2585408272132,-44.215211390840565,6)",
"TSchneiden()",
"TQ(247.89889529823643,662.261730646168,-43.84267751008141,4)",
"TSchneiden()",
"TQ(118.27229099826182,651.8166393945107,-14.999999999999993,6)",
"TA()",
"TQ(177.50000000000006,700,-4.733165431326071e-30,3)",
"TSchneiden()",
"TQ(237.04536360786378,652.0196427372484,-15.000000000000014,4)",
"TA();//Testflag=true",
"TQ(177.50000000000006,700,-4.733165431326071e-30,3)",
"TSchneiden()",
"TQ(190,0,1250,1)",
"TA()",
"TQ(190,120,1250,1)",
"TS()",
"TQ(193.7,0,1620,1)",
"TD()",
"TQ(233.0867389713242,387.27802396613663,799.0393306224815,4)",
"TSchneiden()",
"TQ(193.7,0,1620,1)",
"TS()",
"TQ(190,120,1250,1)",
"TD()",
"TQ(156.715966119015,376.4729549040578,768.305309326288,6)",
"TSchneiden()",
"TQ(193.7,0,1620,1)",
"TA()",
"TQ(138.19571096632518,387.24369123077435,798.9461971522918,6)",
"TA()",
"TQ(193.7,0,1620,1)",
"TSchneiden()",
"TQ(233.0867389713242,387.27802396613663,799.0393306224815,4)",
"TA()",
"TQ(193.7,0,1620,1)",
"TSchneiden()",

"TQ(900,0,0,0)",
"TNeu(160,210,2,'Schusterburg neues Dachfenster')",
"TQ(0,0,0,0)",
"TA()",
"TQ(0,115,0,0)",
"TS()",
"TQ(5.98,115,57.5,0)",
"TD()",
"TQ(900,0,2,7)",
"TDrehen()",
"TQ(-900,0,0,0)",
"TNeu(200,500,5,'neuer Putz')",
"TQ(-900,0,5,0)",
"TNeu(5,500,2000,'neuer Putz')",
  ];
  
  
  
  
  
  
  
  
  
  
  
  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel2");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }
  </script>

<script>//Beispiel3
var Beispiel3=function() {
  init();
  zoom=20;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  Logflag=false;
  History=[];
  
  // position and point the camera to the center of the scene
  camera.position.x = -70; //5; //15;
  camera.position.y = 30; //5; //16;
  camera.position.z = 60; //-12; //13
  camera.lookAt(scene.position);

/*
  PA.position.x=0/zoom;
  PA.position.y=0/zoom;
  PA.position.z=0/zoom;

  PS.position.x=0/zoom;
  PS.position.y=0/zoom;
  PS.position.z=1700/zoom;

  PD.position.x=130/zoom;
  PD.position.y=120/zoom;
  PD.position.z=1250/zoom;
*/

var Dach=[[
  DREIPUNKTE([0,0,0,1],[2000,0,0,1],[250,750,250,1]),
  DREIPUNKTE([0,0,500,1],[250,750,250,1],[1000,0,500,1]),
  DREIPUNKTE([0,0,0,1],[250,750,250,1],[0,0,500,1]),
  DREIPUNKTE([0,0,0,1],[0,0,500,1],[2000,0,500,1]),
  DREIPUNKTE([2000,0,0,1],[2000,0,500,1],[1750,750,250,1]),
  ],
  [TEBN,TEBN,TAND,TEBN,TAND,TEBN,TAND,TEBN,TAND],
  [],[]];
  QFILL(Dach);
  KFILL(Dach);
  AddObjekt(scene,Dach);

var Balken=neuen_Balken_plazieren(0,0,50,2500,24,12);










LT=[
"/*0*/ TQ(0,0,500,0)",
"/*1*/ TA()",
"/*2*/ TQ(0,0,0,0)",
"/*3*/ TS()",
"/*4*/ TQ(0,0,500,0)",
"/*5*/ TVerschieben()",
"/*6*/ TQ(0,24,56,1)",
"/*7*/ TA()",
"/*8*/ TQ(0,0,0,0)",
"/*9*/ TS()",
"/*10*/ TQ(0,0,12,1)",
"/*11*/ TKopieren()",
"/*12*/ TVerschieben()",
"/*13*/ TQ(0,0,0,0)",
"/*14*/ TA()",
"/*15*/ TQ(2000,0,0,0)",
"/*16*/ TS()",
"/*17*/ TQ(250,750,-250,0)",
"/*18*/ TD()",
"/*19*/ TQ(0,0,0,2)",
"/*20*/ TDrehen()",
"/*21*/ TQ(0,0,-250,0)",
"/*22*/ TA()",
"/*23*/ TA()",
"/*24*/ TQ(2000,0,-250,0)",
"/*25*/ TS()",
"/*26*/ TQ(1750,750,-250,0)",
"/*27*/ TD()",
"/*28*/ TQ(758.0210021315,2261.3350843332,-749.5357207573,2)",
"/*29*/ TSchneiden()",
"/*30*/ TQ(0,24,56,1)",
"/*31*/ TKopieren()",
"/*32*/ TA()",
"/*33*/ TQ(0,0,-500,0)",
"/*34*/ TS()",
"/*35*/ TQ(0,24,62,1)",
"/*36*/ TVerschieben()",
"/*37*/ TQ(0,0,-500,0)",
"/*38*/ TA()",
"/*39*/ TQ(2500,0,-500,1)",
"/*40*/ TS()",
"/*41*/ TQ(2500,0,-494,1)",
"/*42*/ TA()",
"/*43*/ TQ(0,0,-500,0)",
"/*44*/ TA()",
"/*45*/ TQ(2500,0,-500,1)",
"/*46*/ TS()",
"/*47*/ TS()",
"/*48*/ TS()",
"/*49*/ TS()",
"/*50*/ TQ(250,750,-250,0)",
"/*51*/ TD()",
"/*52*/ TQ(2500,-24,-500,1)",
"/*53*/ TDrehen()",
"/*54*/ TQ(0,0,-250,0)",
"/*55*/ TA()",
"/*56*/ TA()",
"/*57*/ TA()",
"/*58*/ TQ(1750,750,-250,0)",
"/*59*/ TS()",
"/*60*/ TQ(2000,0,-250,0)",
"/*61*/ TD()",
"/*62*/ TQ(758.0210021315,2261.3350843332,249.5357207573,1)",
"/*63*/ TSchneiden()",
"/*64*/ TQ(0,24,56,3)",
"/*65*/ TA()",
"/*66*/ TQ(250,750,-250,2)",
"/*67*/ TS()",
"/*68*/ TQ(2500,24,62,3)",
"/*69*/ TKopieren()",
"/*70*/ TVerschieben()",
"/*71*/ TQ(250,750,-244,4)",
"/*72*/ TA()",
"/*73*/ TQ(250,726,-244,4)",
"/*74*/ TS()",
"/*75*/ TVerschieben()",
"/*76*/ TQ(250,726,-244,4)",
"/*77*/ TA()",
"/*78*/ TQ(250,714,-244,4)",
"/*79*/ TS()",
"/*80*/ TVerschieben()",
"/*81*/ TVerschieben()",
"/*82*/ TQ(1750,750,-250,0)",
"/*83*/ TA()",
"/*84*/ TQ(1000,750,-250,0)",
"/*85*/ TS()",
"/*86*/ TQ(2750,678,-244,4)",
"/*87*/ TSchneiden()",
"/*88*/ TQ(250,702,-244,4)",
"/*89*/ TA()",
"/*90*/ TQ(-4.2426406871,0,-4.7573593129,2)",
"/*91*/ TSchneiden()",
"/*92*/ TQ(-4.2426406871,0,-495.7573593129,1)",
"/*93*/ TSchneiden()",
"/*94*/ TQ(0,0,0,0)",
"/*95*/ TA()",
"/*96*/ TQ(1000,750,-250,0)",
"/*97*/ TS()",
"/*98*/ TQ(1875,375,-125,0)",
"/*99*/ TD()",
"/*100*/ TQ(11.1078108905,-10.2336343851,-19.5930922647,2)",
"/*101*/ TSchneiden()",
"/*102*/ TQ(0,0,-250,0)",
"/*103*/ TA()",
"/*104*/ TQ(250,750,-250,1)",
"/*105*/ TS()",
"/*106*/ TQ(0,0,0,0)",
"/*107*/ TD()",
"/*108*/ TQ(-4.2426406871,0,-4.2426406871,2)",
"/*109*/ TSchneiden()",
"/*110*/ TQ(4.2426406871,0,-504.2426406871,1)",
"/*111*/ TSchneiden()",
"/*112*/ TQ(2000,0,-250,0)",
"/*113*/ TA()",
"/*114*/ TQ(2000,0,-500,0)",
"/*115*/ TS()",
"/*116*/ TQ(1000,0,-500,0)",
"/*117*/ TA()",
"/*118*/ TQ(2000,0,-500,0)",
"/*119*/ TS()",
"/*120*/ TQ(1875,375,-375,0)",
"/*121*/ TD()",
"/*122*/ TQ(19.5930922647,-10.2336343851,-488.8921891095,1)",
"/*123*/ TSchneiden()",
"/*124*/ TQ(0,0,-500,1)",
"/*125*/ TA()",
"/*126*/ TKopieren()",
"/*127*/ TQ(2000,0,0,0)",
"/*128*/ TS()",
"/*129*/ TQ(0,0,-500,1)",
"/*130*/ TVerschieben()",
"/*131*/ TQ(2000,0,0,1)",
"/*132*/ TA()",
"/*133*/ TQ(1000,0,0,0)",
"/*134*/ TS()",
"/*135*/ TQ(2000,0,-500,0)",
"/*136*/ TD()",
"/*137*/ TQ(2258.4852813742,750,250,1)",
"/*138*/ TDrehen()",
"/*139*/ TDrehen()",
"/*140*/ TQ(19.5930922647,-10.2336343851,-11.1078108905,2)",
"/*141*/ TKopieren()",
"/*142*/ TQ(0,0,0,0)",
"/*143*/ TA()",
"/*144*/ TQ(2000,0,-500,0)",
"/*145*/ TS()",
"/*146*/ TQ(11.1078108905,-10.2336343851,-19.5930922647,2)",
"/*147*/ TVerschieben()",
"/*148*/ TQ(2000,0,-500,2)",
"/*149*/ TA()",
"/*150*/ TQ(2000,0,-250,0)",
"/*151*/ TS()",
"/*152*/ TQ(1000,0,-500,0)",
"/*153*/ TD()",
"/*154*/ TQ(2258.4852813742,750,-750,2)",
"/*155*/ TDrehen()",
"/*156*/ TDrehen()",
"/*157*/ TQ(0,24,56,3)",
"/*158*/ TA()",
"/*159*/ TQ(1000,0,0,0)",
"/*160*/ TS()",
"/*161*/ TQ(0,24,56,3)",
"/*162*/ TKopieren()",
"/*163*/ TVerschieben()",
"/*164*/ TQ(1000,0,0,0)",
"/*165*/ TA()",
"/*166*/ TQ(2000,0,0,1)",
"/*167*/ TS()",
"/*168*/ TQ(1000,750,-250,0)",
"/*169*/ TD()",
"/*170*/ TQ(3500,-12,6,7)",
"/*171*/ TDrehen()",
"/*172*/ TQ(2000,0,-250,0)",
"/*173*/ TA()",
"/*174*/ TQ(1000,750,-250,0)",
"/*175*/ TS()",
"/*176*/ TQ(0,0,-250,0)",
"/*177*/ TD()",
"/*178*/ TQ(994,2371.7082451263,-790.5694150421,7)",
"/*179*/ TSchneiden()",
"/*180*/ TQ(1000,702,-256,4)",
"/*181*/ TA()",
"/*182*/ TQ(1006,375,-125,7)",
"/*183*/ TSchneiden()",
"/*184*/ TQ(1000,0,0,0)",
"/*185*/ TA()",
"/*186*/ TQ(1250,24,62,3)",
"/*187*/ TS()",
"/*188*/ TQ(1006,352.2316008468,-142.7087548969,7)",
"/*189*/ TS()",
"/*190*/ TQ(1006,352.2316008468,-142.7087548969,7)",
"/*191*/ TS()",
"/*192*/ TQ(1000,0,-500,0)",
"/*193*/ TS()",
"/*194*/ TQ(994,375,-125,7)",
"/*195*/ TKopieren()",
"/*196*/ TVerschieben()",
"/*197*/ TQ(1000,0,-500,0)",
"/*198*/ TA()",
"/*199*/ TQ(2000,0,-500,2)",
"/*200*/ TS()",
"/*201*/ TQ(1000,0,0,0)",
"/*202*/ TD()",
"/*203*/ TQ(1000,-7.5894663844,-522.7683991532,8)",
"/*204*/ TDrehen()",
"/*205*/ TDrehen()",
"/*206*/ TQ(0,0,56,3)",
"/*207*/ TA()",
"/*208*/ TQ(250,678,-250,4)",
"/*209*/ TS()",
"/*210*/ TQ(0,24,62,3)",
"/*211*/ TKopieren()",
"/*212*/ TVerschieben()",
"/*213*/ TQ(241.5147186258,680.9870888208,-250,5)",
"/*214*/ TA()",
"/*215*/ TQ(126.3112647581,335.3767272178,-134.7965461324,6)",
"/*216*/ TS()",
"/*217*/ TQ(2750,702,-244,9)",
"/*218*/ TKopieren()",
"/*219*/ TVerschieben()",
"/*220*/ TQ(2634.7965461324,356.3896383971,-128.7965461324,10)",
"/*221*/ TKopieren()",
"/*222*/ TVerschieben()",
"/*223*/ TQ(134.7965461324,356.3896383971,-128.7965461324,10)",
"/*224*/ TA()",
"/*225*/ TQ(125,375,-125,6)",
"/*226*/ TSchneiden()",
"/*227*/ TQ(19.5930922647,-13.2207232058,-25.5930922647,11)",
"/*228*/ TA()",
"/*229*/ TQ(5.1682108373,-6.2739010163,-13.6534922116,6)",
"/*230*/ TSchneiden()",
"/*231*/ TQ(2750,678,-244,9)",
"/*232*/ TLoeschen()",
"/*233*/ TQ(1000,0,0,0)",
"/*234*/ TA()",
"/*235*/ TA()",
"/*236*/ TQ(2000,0,0,1)",
"/*237*/ TS()",
"/*238*/ TQ(0,0,0,0)",
"/*239*/ TD()",
"/*240*/ TQ(19.5930922647,-13.2207232058,-25.5930922647,9)",
"/*241*/ TDrehen()",
"/*242*/ TQ(2634.7965461324,356.3896383971,-140.7965461324,10)",
"/*243*/ TDrehen()",
"/*244*/ TQ(19.5930922647,10.7792767942,-25.1164183433,6)",
"/*245*/ TA()",
"/*246*/ TQ(19.5930922647,10.7792767942,-13.5930922647,6)",
"/*247*/ TS()",
"/*248*/ TQ(19.5930922647,-6.5057123237,-13.5930922647,6)",
"/*249*/ TD()",
"/*250*/ TQ(-519.5930922647,10.7792767942,25.5930922647,9)",
"/*251*/ TSchneiden()",
"/*252*/ TQ(134.7965461324,356.3896383971,-140.3198722109,6)",
"/*253*/ TA()",
"/*254*/ TQ(134.7965461324,356.3896383971,-128.7965461324,6)",
"/*255*/ TS()",
"/*256*/ TQ(134.7965461324,339.1046492792,-128.7965461324,6)",
"/*257*/ TD()",
"/*258*/ TQ(-634.7965461324,332.3896383971,140.7965461324,10)",
"/*259*/ TSchneiden()",
"/*260*/ TQ(1000,0,0,0)",
"/*261*/ TA()",
"/*262*/ TQ(2000,0,0,1)",
"/*263*/ TS()",
"/*264*/ TQ(0,0,0,0)",
"/*265*/ TD()",
"/*266*/ TQ(19.5930922647,-1.2207232058,13.5930922647,9)",
"/*267*/ TDrehen()",
"/*268*/ TQ(134.7965461323,332.3896383971,134.7965461324,10)",
"/*269*/ TDrehen()",
"/*270*/ TQ(1865.2034538677,356.3896383971,-128.7965461324,10)",
"/*271*/ TA()",
"/*272*/ TQ(1866.9004132337,373.8429161762,-124.6143053921,1)",
"/*273*/ TSchneiden()",
"/*274*/ TQ(1980.4069077353,10.7792767942,-13.5930922647,9)",
"/*275*/ TA()",
"/*276*/ TQ(1992.2861078416,-2.3141676475,0.7713892158,1)",
"/*277*/ TSchneiden()",
"/*278*/ TQ(1000,750,-250,0)",
"/*279*/ TA()",
"/*280*/ TQ(1750,750,-250,1)",
"/*281*/ TS()",
"/*282*/ TQ(250,750,-250,5)",
"/*283*/ TD()",
"/*284*/ TQ(134.7965461324,332.3896383971,-140.7965461324,10)",
"/*285*/ TKopieren()",
"/*286*/ TDrehen()",
"/*287*/ TQ(19.5930922647,-13.2207232058,-25.5930922647,9)",
"/*288*/ TKopieren()",
"/*289*/ TDrehen()",
"/*290*/ TQ(19.5930922647,-13.2207232058,-474.4069077353,12)",
"/*291*/ TA()",
"/*292*/ TQ(-0.7713892158,-2.3141676475,-492.2861078416,5)",
"/*293*/ TSchneiden()",
"/*294*/ TQ(134.7965461323,332.3896383971,-359.2034538676,11)",
"/*295*/ TA()",
"/*296*/ TQ(120.371664705,361.1149941149,-371.1430539208,5)",
"/*297*/ TSchneiden()",
"/*298*/ TQ(1865.2034538676,344.3896383971,-359.2034538676,11)",
"/*299*/ TA()",
"/*300*/ TQ(1866.9004132337,373.8429161762,-375.3856946079,2)",
"/*301*/ TSchneiden()",
"/*302*/ TQ(1980.4069077353,-13.2207232058,-474.4069077353,12)",
"/*303*/ TA()",
"/*304*/ TQ(1980.4069077353,-10.2336343851,-488.8921891095,2)",
"/*305*/ TSchneiden()",
"/*306*/ TQ(2500,24,62,3)",
"/*307*/ TLoeschen()",
"/*308*/ TQ(1000,356.3896383971,-140.7965461324,10)",
"/*309*/ TA()",
"/*310*/ TQ(994,375,-125,7)",
"/*311*/ TSchneiden()",
"/*312*/ TQ(1000,356.3896383971,-371.2034538676,11)",
"/*313*/ TA()",
"/*314*/ TQ(994,375,-375,8)",
"/*315*/ TSchneiden()",
"/*316*/ TQ(1000,10.7792767942,-13.5930922647,9)",
"/*317*/ TA()",
"/*318*/ TQ(1006,-7.5894663844,-22.7683991532,7)",
"/*319*/ TSchneiden()",
"/*320*/ TQ(1000,10.7792767942,-474.4069077353,3)",
"/*321*/ TA()",
"/*322*/ TQ(1000,10.7792767942,-486.4069077353,3)",
"/*323*/ TSchneiden()",
"/*324*/ TQ(994,-7.5894663844,-477.2316008468,8)",
"/*325*/ TSchneiden()",
"/*326*/ TQ(1006,0,0,7)",
"/*327*/ TA()",
"/*328*/ TQ(994,0,0,7)",
"/*329*/ TA()",
"/*330*/ TQ(1006,0,0,7)",
"/*331*/ TS()",
"/*332*/ TKopieren()",
"/*333*/ TVerschieben()",
"/*334*/ TVerschieben()",
"/*335*/ TVerschieben()",
"/*336*/ TVerschieben()",
"/*337*/ TVerschieben()",
"/*338*/ TVerschieben()",
"/*339*/ TVerschieben()",
"/*340*/ TVerschieben()",
"/*341*/ TVerschieben()",
"/*342*/ TVerschieben()",
"/*343*/ TVerschieben()",
"/*344*/ TVerschieben()",
"/*345*/ TQ(1006,0,0,7)",
"/*346*/ TA()",
"/*347*/ TQ(1150,0,0,12)",
"/*348*/ TS()",
"/*349*/ TKopieren()",
"/*350*/ TVerschieben()",
"/*351*/ TKopieren()",
"/*352*/ TVerschieben()",
"/*353*/ TKopieren()",
"/*354*/ TVerschieben()",
"/*355*/ TKopieren()",
"/*356*/ TVerschieben()",
"/*357*/ TQ(1150,0,0,12)",
"/*358*/ TA()",
"/*359*/ TA()",
"/*360*/ TQ(1006,0,0,7)",
"/*361*/ TS()",
"/*362*/ TKopieren()",
"/*363*/ TVerschieben()",
"/*364*/ TKopieren()",
"/*365*/ TVerschieben()",
"/*366*/ TKopieren()",
"/*367*/ TVerschieben()",
"/*368*/ TKopieren()",
"/*369*/ TVerschieben()",
"/*370*/ TKopieren()",
"/*371*/ TVerschieben()",
"/*372*/ TQ(1006,0,-500,8)",
"/*373*/ TA()",
"/*374*/ TQ(994,0,-500,8)",
"/*375*/ TS()",
"/*376*/ TKopieren()",
"/*377*/ TVerschieben()",
"/*378*/ TVerschieben()",
"/*379*/ TVerschieben()",
"/*380*/ TVerschieben()",
"/*381*/ TVerschieben()",
"/*382*/ TVerschieben()",
"/*383*/ TVerschieben()",
"/*384*/ TVerschieben()",
"/*385*/ TVerschieben()",
"/*386*/ TVerschieben()",
"/*387*/ TVerschieben()",
"/*388*/ TVerschieben()",
"/*389*/ TQ(994,0,-500,8)",
"/*390*/ TA()",
"/*391*/ TQ(850,0,-500,22)",
"/*392*/ TS()",
"/*393*/ TKopieren()",
"/*394*/ TVerschieben()",
"/*395*/ TKopieren()",
"/*396*/ TVerschieben()",
"/*397*/ TKopieren()",
"/*398*/ TVerschieben()",
"/*399*/ TKopieren()",
"/*400*/ TVerschieben()",
"/*401*/ TQ(850,0,-500,22)",
"/*402*/ TA()",
"/*403*/ TQ(994,0,-500,8)",
"/*404*/ TS()",
"/*405*/ TKopieren()",
"/*406*/ TVerschieben()",
"/*407*/ TKopieren()",
"/*408*/ TVerschieben()",
"/*409*/ TKopieren()",
"/*410*/ TVerschieben()",
"/*411*/ TKopieren()",
"/*412*/ TVerschieben()",
"/*413*/ TKopieren()",
"/*414*/ TVerschieben()",
];
  
  
  
  
  
  

  
  LTeval(LT,0);
  Logfile("das war Beispiel3");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }
  </script>

<script>
var Beispiel4=function() {
  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  
  // position and point the camera to the center of the scene
  camera.position.x = -5; //5; //15;
  camera.position.y = 5; //5; //16;
  camera.position.z = -12; //-12; //13
  camera.lookAt(scene.position);

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//Logflag=true;
//Testflag=true;
LT=[
"/*0*/ TQ(355,0,0,0)",
"/*1*/ TA()",
"/*2*/ TQ(250,0,1250,1)",
"/*3*/ TS()",
"/*4*/ TQ(250,120,1250,1)",
"/*5*/ TD()",
"/*6*/ TQ(177.5,0,0,0)",
"/*7*/ TSchneiden()",
"/*8*/ TQ(0,0,0,0)",
"/*9*/ TA()",
"/*10*/ TQ(130,120,1250,1)",
"/*11*/ TS()",
"/*12*/ TQ(130,0,1250,1)",
"/*13*/ TD()",
"/*14*/ TQ(177.5,0,0,0)",
"/*15*/ TSchneiden()",
"/*16*/ TQ(11.96,115,115,0)",
"/*17*/ TA()",
"/*18*/ TQ(350.17,115,57.5,0)",
"/*19*/ TS()",
"/*20*/ TQ(345.34,57.5,115,0)",
"/*21*/ TD()",
"/*22*/ TSchneiden()",
"/*23*/ TQ(11.96,115,115,0)",
"/*24*/ TA()",
"/*25*/ TQ(250,120,1250,1)",
"/*26*/ TS()",
"/*27*/ TQ(190,0,1250,1)",
"/*28*/ TD()",
"/*29*/ TQ(177.5,0,0,0)",
"/*30*/ TSchneiden()",
];
  
  
 
  
  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel2");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }
  </script>


<script>
var Beispiel5=function() {
  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  
  // position and point the camera to the center of the scene
  camera.position.x = -5; //5; //15;
  camera.position.y = 5; //5; //16;
  camera.position.z = -12; //-12; //13
  camera.lookAt(scene.position);

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//Logflag=true;
//Testflag=true;
LT=[
"/*0*/ TQ(0,0,0,0)",
"/*1*/ TA()",
"/*2*/ TQ(130,120,1250,1)",
"/*3*/ TS()",
"/*4*/ TQ(130,0,1250,1)",
"/*5*/ TD()",
"/*6*/ TQ(177.5,0,0,0)",
"/*7*/ TSchneiden()",
"/*8*/ TQ(355,0,0,0)",
"/*9*/ TA()",
"/*10*/ TQ(250,0,1250,1)",
"/*11*/ TS()",
"/*12*/ TQ(250,120,1250,1)",
"/*13*/ TD()",
"/*14*/ TQ(177.5,0,0,0)",
"/*15*/ TSchneiden()",
];  


  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel5");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }
  </script>


<script>//Eingabefunktionen für Log2
var gerundet=function(x) { return Math.round(x*10000000000)/10000000000 }

var TQ=function(x,y,z,cmin) {//setzt Koordinaten von q und damit OBJ_X
  if ((Logtext2.length>0)&&(Logtext2[Logtext2.length-1]).slice(0,2)=="TQ") Logtext2.pop();
  Logtext2.push("TQ("+gerundet(x)+","+gerundet(y)+","+gerundet(z)+","+cmin+")");
  q.position.x=x/zoom;
  q.position.y=y/zoom;
  q.position.z=z/zoom;
  OBJ_X=Castlist[cmin];
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  History_update();
  Logfile();
  Logfile2();
  }

var TA=function() {//setzt Punkt A auf Punkt Q
  Logtext2.push("TA()");
  PA.position.copy(q.position); OBJ_Y=OBJ_X;
  History_update();
  Logfile2();
  }

var TS=function() {//setzt Punkt S auf Punkt Q
  Logtext2.push("TS()");
  PS.position.copy(q.position);
  VAS.geometry.verticesNeedUpdate = true;
  OBJ_Y=0;
  SCHNITTVEKTOR_AS=[[EGGT([PA.position.x-PS.position.x,PA.position.y-PS.position.y,PA.position.z-PS.position.z,-((PA.position.x-PS.position.x)*PA.position.x+(PA.position.y-PS.position.y)*PA.position.y+(PA.position.z-PS.position.z)*PA.position.z)*zoom])],[TEBN],[],[]];
  KDUMP(SCHNITTVEKTOR_AS);
  History_update();
  Logfile();
  Logfile2();
  }

var TD=function() {//setzt Punkt D auf Punkt Q
  Logtext2.push("TD()");
  PD.position.copy(q.position);
  EASD.geometry.verticesNeedUpdate = true;
  OBJ_Y=0;
  SCHNITTVEKTOR_AS=0;
  SCHNITTEBENE_ASD=[[DREIPUNKTE([PA.position.x*zoom,PA.position.y*zoom,PA.position.z*zoom,1],[PD.position.x*zoom,PD.position.y*zoom,PD.position.z*zoom,1],[PS.position.x*zoom,PS.position.y*zoom,PS.position.z*zoom,1])],[TEBN],[],[]];
  History_update();
  Logfile2();
  }

var TUmdrehen=function() {//AS oder AD umdrehen
  Logtext2.push("TUmdrehen()");
  if (SCHNITTVEKTOR_AS!=0) {
    SCHNITTVEKTOR_AS[0][0][0]=-SCHNITTVEKTOR_AS[0][0][0];
    SCHNITTVEKTOR_AS[0][0][1]=-SCHNITTVEKTOR_AS[0][0][1];
    SCHNITTVEKTOR_AS[0][0][2]=-SCHNITTVEKTOR_AS[0][0][2];
    SCHNITTVEKTOR_AS[0][0][3]=-SCHNITTVEKTOR_AS[0][0][3];
    PS.position.x=2*PA.position.x-PS.position.x;
    PS.position.y=2*PA.position.y-PS.position.y;
    PS.position.z=2*PA.position.z-PS.position.z;
    VAS.geometry.verticesNeedUpdate = true;
    Logtext="SCHNITTVEKTOR_AS nach -AS:\n";KDUMP(SCHNITTVEKTOR_AS);Logfile();
    } else if (SCHNITTEBENE_ASD!=0) {
      SCHNITTEBENE_ASD[0][0][0]=-SCHNITTEBENE_ASD[0][0][0];
      SCHNITTEBENE_ASD[0][0][1]=-SCHNITTEBENE_ASD[0][0][1];
      SCHNITTEBENE_ASD[0][0][2]=-SCHNITTEBENE_ASD[0][0][2];
      SCHNITTEBENE_ASD[0][0][3]=-SCHNITTEBENE_ASD[0][0][3];
      PD.position.x=2*PA.position.x-PD.position.x;
      PD.position.y=2*PA.position.y-PD.position.y;
      PD.position.z=2*PA.position.z-PD.position.z;
      EASD.geometry.verticesNeedUpdate = true;
      Logtext="SCHNITTEBENE_ASD nach -AD:\n";KDUMP(SCHNITTEBENE_ASD);Logfile();
      }
  History_update();
  }

var TMerken_Hilfsfunktion=function() {//
  if (SCHNITTVEKTOR_AS!=0) {
    MERKOBJEKT[0].push(SCHNITTVEKTOR_AS[0][0]);
    MERKOBJEKT[1].push(TEBN);
    if (MERKOBJEKT[0].length>1) MERKOBJEKT[1].push(TAND);
    } else if (SCHNITTEBENE_ASD!=0) {
      MERKOBJEKT[0].push(SCHNITTEBENE_ASD[0][0]);
      MERKOBJEKT[1].push(TEBN);
      if (MERKOBJEKT[0].length>1) MERKOBJEKT[1].push(TAND);
      }
  }

var TMerken=function() {//legt Ebene ASD fest
  Logtext2.push("TMerken()");
  TMerken_Hilfsfunktion();
  Logtext="MERKEBENE nach TMerken():\n";
  KDUMP(MERKOBJEKT);
  History_update();
  Logfile();
  Logfile2();
  }

var TKopieren=function() {//verschiebt OBJ_X um Vektor AS
  Logtext2.push("TKopieren()");
  //OBJ_X=OBJ_X.slice();
  //OBJ_X[4]=[]; 
  OBJ_X=JSON.parse(JSON.stringify(OBJ_X.slice(0,4)));
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);
  SAMMELEBENE=[[],[],[],[]];
  History_update();
  Logfile();
  Logfile2();
  }

var TVerschieben=function() {//verschiebt OBJ_X um Vektor AS
  Logtext2.push("TVerschieben()");
  scene.remove(OBJ_X[4]); 
  var cind=Castlist.indexOf(OBJ_X);
  OBJ_X=TRANSFORM(OBJ_X,[[1,0,0,(PA.position.x-PS.position.x)*zoom],[0,1,0,(PA.position.y-PS.position.y)*zoom],[0,0,1,(PA.position.z-PS.position.z)*zoom],[0,0,0,1]]);
  KDUMP(OBJ_X);KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X); Castlist.pop(); 
  Castlist[cind]=OBJ_X;
  SAMMELEBENE=[[],[],[],[]];
  History_update();
  Logfile();
  Logfile2();
  }

var TDrehen=function() {//dreht OBJ_X aus Vektor AS in Richtung AD erst yaw dann pitch
  Logtext2.push("TDrehen()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  OBJ_X=DrehenASD(OBJ_X);
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);Castlist.pop();
  Castlist[cind]=OBJ_X;
  SAMMELEBENE=[[],[],[],[]]
  History_update();
  Logfile();
  Logfile2();
  }

var TSchneiden=function() {//schneidet von OBJ_X das Objekt SAMMELEBENE ab
  Logtext2.push("TSchneiden()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  if (OBJ_Y!=0) SAMMELEBENE=OBJ_Y; else {
    TMerken_Hilfsfunktion();
    SAMMELEBENE=MERKOBJEKT;
    }
  OBJ_X=RUMPS(OBJ_X,SAMMELEBENE,1);
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);Castlist.pop();
  Castlist[cind]=OBJ_X;
  MERKOBJEKT=[[],[],[],[]];
  History_update();
  Logfile();
  Logfile2();
  }

var TLoeschen=function() {//schneidet von OBJ_X das Objekt SAMMELEBENE ab
  Logtext2.push("TLoeschen()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  Castlist[cind]=Castlist.pop();
  MERKOBJEKT=[[],[],[],[]];
  History_update();
  Logfile();
  Logfile2();
  }

var TNeu=function(l,b,h,name) {
  Logtext2.push("TNeu("+l+","+b+","+h+")");
  PUNKT_A=[q.position.x*zoom,q.position.y*zoom,q.position.z*zoom,1];
  var NEU=QUADER(l,b,h); 
  KFILL(NEU); 
  NEU[5]=name;
  AddObjekt(scene,NEU);
  History_update();
  Logfile();
  Logfile2();
  }
  </script>

<script>//nur ein enes Objekt zeigen
var einzeln=0;
function Einzelobjekt() {
  //alert(Castlist[3]);
  for (var i=0;i<Castlist.length;i++) {
    if (einzeln==0) if (i!=cmin) Castlist[i][4].visible=false;
    if (einzeln==1) Castlist[i][4].visible=true;
    }
  einzeln=1-einzeln;
  }
  </script>

<script>//Logfile
//gesammelten Logtext ausgeben
function Logfile(Resttext) {
  if (!Resttext) var Resttext="";
  document.getElementById("Log").innerHTML='<span style="white-space:pre; font-family:monospace">'+Logtext+Resttext+"</span>";
  Logtext="";
  document.getElementById("KPLOTelement").innerHTML=KPLOTtext;
  }

function Logfile2(Resttext) {
  if (!Resttext) var Resttext="";
  var Log2element=document.getElementById("Log2");
  var Log2element_innerHTML='<span style="white-space:pre; font-family:monospace">\nLT=[\n';
  for (t in Logtext2) Log2element_innerHTML=Log2element_innerHTML+'<span onclick="History_t('+t+')">"/*'+t+"*/ "+Logtext2[t]+'",</span>\n';
  Log2element_innerHTML=Log2element_innerHTML+Resttext+'];\n\  \n  </span>';
  Log2element.innerHTML=Log2element_innerHTML;
  Log2element.scrollTo({//mit dem geht Kopieren nicht
    top: 100000,
    left: 0,
    //behavior: 'smooth'
    });
  selectText("Log2");
  }

function selectText(element) { //Quelle: https://gist.github.com/gubatron/6599366
    var doc = document
        , text = doc.getElementById(element)
        , range, selection
    ;    
    if (doc.body.createTextRange) { //ms
        range = doc.body.createTextRange();
        range.moveToElementText(text);
        range.select();
    } else if (window.getSelection) { //all others
        selection = window.getSelection();        
        range = doc.createRange();
        range.selectNodeContents(text);
        selection.removeAllRanges();
        selection.addRange(range);
    }
}

var LTeval=function(LT,ltind) {
  eval(LT[ltind]);
  ltind=ltind+1;
  if (ltind<LT.length) setTimeout(LTeval,20,LT,ltind);
  }
  </script>
  
<script>//raycast
function raycast ( e ) {
  //raycaster.setFromCamera( mouse, camera ) aus three.pdf ging nicht
  //1. sets the mouse position with a coordinate system where the center
  //   of the screen is the origin
  //for (var i in e) alert(i);
  //mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
  //mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
  mouse.x = ( (event.clientX-event.target.getBoundingClientRect().left) / window.innerWidth ) * 2 - 1;
  mouse.y = - ( (event.clientY-event.target.getBoundingClientRect().top) / window.innerHeight/*event.target.height*/ ) * 2 + 1;
  mouse.z = 1;

  cmin=0;
  var dmin=0;
  var pk="p";
  var pmin=[[0,0,0,1],[0,0,0,1]];
  var mindist=Infinity;
  for (var c in Castlist) {
    for (var d in Castlist[c][2]) {
      var p=Castlist[c][2][d][3];
      var dist=(new THREE.Vector3(p[0]/zoom,p[1]/zoom,p[2]/zoom)).project(camera).distanceToSquared(mouse);
      if (dist<mindist) {pk="p"; mindist=dist; cmin=c; dmin=d; pmin=[p.slice(),p.slice()];}
      }
    for (var d in Castlist[c][3]) {
      var p=Castlist[c][2];
      var k=Castlist[c][3][d];
      var dist=(new THREE.Vector3(
        (p[k[0]][3][0]+p[k[1]][3][0])/2/zoom,
        (p[k[0]][3][1]+p[k[1]][3][1])/2/zoom,
        (p[k[0]][3][2]+p[k[1]][3][2])/2/zoom
        )).project(camera).distanceToSquared(mouse);
      if (dist<mindist) {pk="k"; mindist=dist; cmin=c; dmin=d; pmin=[p[k[0]][3].slice(),p[k[1]][3].slice()];}
      }
    }
  //alert("cmin="+cmin+", dmin="+dmin+",pmin="+JSON.stringify(pmin)+", mindist="+mindist);
  TQ((pmin[0][0]+pmin[1][0])/2,(pmin[0][1]+pmin[1][1])/2,(pmin[0][2]+pmin[1][2])/2,cmin);
  document.getElementById("Pdisp").firstChild.nodeValue=pk+dmin+"=["+[(q.position.x*zoom).toFixed(2),(q.position.y*zoom).toFixed(2),(q.position.z*zoom).toFixed(2)]+'] in "'+Castlist[cmin][5]+'"';
  }

  </script>
  
<script>//markObj war in KONSTRUK_javascript.js vordefiniert als alert
markObj=function(cmin,ekpi,i,value) {
  //alert("Hallo "+[cmin,ekpi,i,value].join("---"));
  var OBJC=Castlist[cmin];
  var PC=OBJC[2]; //Punkte
  var KC=OBJC[3]; //Kanten
  var EC=OBJC[0]; //Ebenen
  if (ekpi==2) TQ(value[3][0],value[3][1],value[3][2],cmin);
  if (ekpi==1) {
    TQ(PC[value[0]][3][0],Castlist[cmin][2][value[0]][3][1],Castlist[cmin][2][value[0]][3][2],cmin);
    TA();
    TQ(Castlist[cmin][2][value[1]][3][0],Castlist[cmin][2][value[1]][3][1],Castlist[cmin][2][value[1]][3][2],cmin);
    TS();
    }
  if (ekpi==0) { 
    var KLISTE=[];
    var PLISTE=[];
    var d="M0,0 ";
    for (var j=0;j<KC.length;j++) {
      if (KC[j][2]==i||KC[j][3]==i) {
        KLISTE.push(j); 
        PLISTE.push([KC[j][0],KC[j][1]]);
        var P1=PUNKT2D(PC[KC[j][0]][3]);
        var P2=PUNKT2D(PC[KC[j][1]][3]);
        d=d+"L"+P1[0]+","+P1[1]+" L"+P2[0]+","+P2[1]+" L0,0 ";
        }
      }
    //alert(KLISTE);
    //alert(PLISTE.join("\n"));
    d=d+"Z";
    document.getElementById("Eiderdaus").setAttribute("d",d);    
    }
  }
  </script>
  
<script>//History
var History_update=function() {
  var hist="";
  for (var i in Castlist) hist=hist+"AddObjekt(scene,"+JSON.stringify(Castlist[i].slice(0,4))+");\n";
  History.push(hist);
  return hist;
  }
  
var History_t=function(t) {
  for (var i in Castlist) scene.remove(Castlist[i][4]);
  Castlist=[];  
  eval(History[t]);
  }
  </script>

<!--script>//sonstige bisher vergebliche Versuche

//create a blue LineBasicMaterial
const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
const points = [];
points.push( new THREE.Vector3( - 10, 0, 0 ) );
points.push( new THREE.Vector3( 0, 10, 0 ) );
points.push( new THREE.Vector3( 10, 0, 0 ) );

var geometry = new THREE.BufferGeometry();//.setFromPoints( points );
var line = new THREE.Line( geometry, material );
scene.add( line );

//Bezier aus three-cookbook S.100?
var numPoints = 33;   
var start = new THREE.Vector3(-2, 1, 0);   
var middle = new THREE.Vector3(0, 0, 0);   
var end = new THREE.Vector3(2, 3, 0);
var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end); 
var tube = new THREE.TubeGeometry(curveQuad, numPoints, 0.1, 44, false);   
var mesh11 = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({opacity: 0.6,     transparent: true   }));   
cube.add(mesh11);

/*aus three.js/dok/edgesgeometry, will nicht gehen
var geometry9 = new THREE.BoxGeometry( 4, 7, 9 );alert(THREE.EdgesGeometry);
var edges9 = new THREE.EdgesGeometry( geometry9 );alert(8);
const line9 = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
  cube.add(line9);
*/

//von irgendwoher:
  var geometry = new THREE.BufferGeometry();
  var material = new THREE.LineBasicMaterial( { vertexColors: true } );
  //alert(JSON.stringify(material));
  var positions = [];
  var colors = [];
  var segments=6;
  var r=1;
  for ( var i = 0; i < segments; i ++ ) {
    var x = Math.random() * r - r / 2;
    var y = Math.random() * r - r / 2;
    var z = Math.random() * r - r / 2;
    // positions
    positions.push( x, y, z );
    // colors
    colors.push( ( x / r ) + 0.5 );
	colors.push( ( y / r ) + 0.5 );
	colors.push( ( z / r ) + 0.5 );
    }
//alert(geometry.setAttribute);
//				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
//				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
//				generateMorphTargets( geometry );
//				geometry.computeBoundingSphere();
				var line = new THREE.Line( geometry, material );
//				scene.add( line );




  </script-->

<script>
//alert(THREE.LineBasicMaterial);
function AddObjekt(OBJ1,OBJ2) {
  var temp_material = new THREE.LineBasicMaterial({ color: 0x0077f0, linewidth:2});
  var temp_geometry = new THREE.Geometry();
  temp_geometry.vertices = [new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0)];
  var temp = new THREE.Line(temp_geometry, temp_material);
  for (var iK in OBJ2[3]) { var K=OBJ2[3][iK];
    var numPoints = 2;   
    var start = new THREE.Vector3(OBJ2[2][K[0]][3][0]/zoom, OBJ2[2][K[0]][3][1]/zoom, OBJ2[2][K[0]][3][2]/zoom);   
    var middle = new THREE.Vector3(OBJ2[2][K[0]][3][0]/zoom, OBJ2[2][K[0]][3][1]/zoom, OBJ2[2][K[0]][3][2]/zoom);   
    var end = new THREE.Vector3(OBJ2[2][K[1]][3][0]/zoom, OBJ2[2][K[1]][3][1]/zoom, OBJ2[2][K[1]][3][2]/zoom);

    if (Linientyp==0) {
      var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end); 
      var tube = new THREE.TubeGeometry(curveQuad, numPoints, 0.05, 33, false);   
      var mesh11 = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({opacity: 0.99,     transparent: true   }));   
      temp.add(mesh11);
      } else {
        var materialline = new THREE.LineBasicMaterial({ color: 0x0077f0, linewidth:2});
        var geometryline = new THREE.Geometry();
        geometryline.vertices = [start,end];
        //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
        var obj2line = new THREE.Line(geometryline, materialline);
        temp.add(obj2line);
        }

    }
  OBJ2[4]=temp;
  OBJ1.add(temp);
  Castlist.push(OBJ2);
  }
  </script>

<script>
function Testspline() {

var spline = new THREE.SplineCurve3([
     new THREE.Vector3(-10, -2, 10),
     new THREE.Vector3(-4, -2, 2),
     new THREE.Vector3(0, -2, -10),
     new THREE.Vector3(2, -2, -10),
     new THREE.Vector3(0,-4,0),
     new THREE.Vector3(7, -2, 1),
     new THREE.Vector3(10, -2, 3),
     new THREE.Vector3(-10, -2, 10)]);

   var geometry = new THREE.Geometry();
   var splinePoints = spline.getPoints(50);
   var material = new THREE.LineBasicMaterial({ color: 0xff00f0   });
//   geometry.vertices = [new THREE.Vector3(0, 2, 0),new THREE.Vector3(2, 0, 2)]; //splinePoints;
   geometry.vertices = splinePoints;
   var sline = new THREE.Line(geometry, material);
   sline.name='sline';
   return sline;
  }

  </script>

<script>
/*
  DRU X wählt ein OBJEKT X
  DRU C kopiert OBJEKT X an die gleiche Stelle
  DRU A wählt einen PUNKT A.
  DRU S wählt zu A einen VEKTOR AS.
  DRU D wählt zu AS eine EBENE ASD.
  DRU E verschiebt X entlang AS
  DRU Q dreht X von AS in Richtung AD
  DRU W AS pendelt um AD bis AS2
  DRU F EBENE ASD sägt OBJEKT X rechterhand ab
  DRU R VEKTOR AS sägt OBJEKT X linkerhand ab
  DRU Y wählt OBJEKT Y
  DRU T OBJEKT Y spart OBJEKT X aus.
  DRU mit Shifttaste ‹:
  DRU ‹C löscht Objekt X
  DRU ‹E dreht Vektor AS um.
  DRU ‹R hebt Sägeebene auf bis R oder F
  DRU ‹F hebt Sägeebene auf bis R oder F
  DRU ‹T Durchschnitt von Objekt X und Y
  DRU weitere Eingaben
  DRU G zur einzelnen Darstellung X und Y
  DRU 4 Vergrößerung (4:1)
  DRU 3 Vergrößerung (3:2)
  DRU 2 Verkleinerung (2:3)
  DRU 1 Verkleinerung (1:4)
  DRU J Blick von weiter links
  DRU K Blick von weiter rechts
  ;
*/



/*
FEHLERTEXT ( nr --> adr n )
  DUP 500 < IF FEHLERTEXT ELSE >R
    R 502 = IF U" OBJEKT X ist nicht markiert" ENDIF
    R 503 = IF U" OBJEKT Y ist nicht markiert" ENDIF
    R 504 = IF U" VEKTOR AS ist nicht markiert oder A fällt mit S zusammen" ENDIF
    R 505 = IF U" EBENE ASD ist nicht markiert oder A fällt mit S oder D zusammen" ENDIF
    R 506 = IF U" AS und AD sind parallel" ENDIF
    R 507 = IF U" AS2 und AD sind parallel" ENDIF
    R 508 = IF U" Wurzel aus negativer ganzen Zahl" ENDIF
    R 500 = IF U" Wurzel aus negativer rationalen Zahl" ENDIF
    R 501 = IF U" Fehler im Rechenausdruck" ENDIF
    R 508 > IF " ???" ENDIF
    R> DROP ENDIF
  ;
  */
  </script>
<svg height="300px">
<path d="M0,0 L100,100 L100,200 L0,0 L200,100 L100,100 L0,0 L200,200 L200,100 L0,0 L200,200 L100,200 L0,0 L130,180 L150,120 L0,0 L170,180 L130,180 L0,0 L170,180 L150,120 L0,0 Z" stroke="none" fill="orange" fill-rule="evenodd"/>
<path d="M10,10 L20,10 M20,20 L20,20 L10,20" stroke="green" fill="orange" fill-rule="evenodd"/>
  </svg>
</body>
</html>
