<!DOCTYPE html>
<html>
<head>
  <!-- verwendete Vorlage: three-cookbook/.../01.05-setup-animation-loop.html -->
  <!-- was noch nicht geht:
.. Reihenfolge ASD soll positive Seite der Ebene bestimmen
.. die stimmt aber nicht beim Keil, deshalb auch -ASD
    -->
  <meta charset="utf-8"/>
  <title>MIT_KONSTRUK_FF.html</title>
  <script src="../libs/three.js"></script>
  <script src="../three.js/build/three.js"></script>
  <script src="../threejs-cookbook/libs/three.js"></script>
  <script src="../threejs-cookbook/libs/OrbitControls.js"></script>
  <script src="../threejs-cookbook/libs/Projector.js"></script>
  <script src="../threejs-cookbook/libs/dat.gui.min.js"></script>
  <script src="../threejs-cookbook/libs/clock.js"></script>
  <style>
     body {
       margin: 1;
       overflow: auto;
       }

    button {font-size:200%}
    </style>
  </head>
<body onload="Beispiel2()">
<!--canvas id="Uhr"> </canvas-->
<button onclick="Beispiel1()">REST5</button>
<button onclick="Beispiel2()">GOKART</button>
<button onclick='PA.position.set(q.position.x,q.position.y,q.position.z)'>A</button>
<button onclick='PS.position.copy(q.position); VAS.geometry.verticesNeedUpdate = true;'>S</button>
<button onclick='PD.position.copy(q.position); EASD.geometry.verticesNeedUpdate = true;'>D</button>

<button onclick='SAMMELEBENE[0].push(EGGT([PS.position.x-PA.position.x,PS.position.y-PA.position.y,PS.position.z-PA.position.z,-((PS.position.x-PA.position.x)*PA.position.x*zoom+(PS.position.y-PA.position.y)*PA.position.y*zoom+(PS.position.z-PA.position.z)*PA.position.z*zoom)]));SAMMELEBENE[1].push(TEBN);if (SAMMELEBENE[0].length>1) SAMMELEBENE[1].push(TAND);Logtext="SAMMELEBENE nach AS:\n";KDUMP(SAMMELEBENE);Logfile()'>AS</button>

<button onclick='SAMMELEBENE[0].push(EGGT([PA.position.x-PS.position.x,PA.position.y-PS.position.y,PA.position.z-PS.position.z,-((PA.position.x-PS.position.x)*PA.position.x*zoom+(PA.position.y-PS.position.y)*PA.position.y*zoom+(PA.position.z-PS.position.z)*PA.position.z*zoom)]));SAMMELEBENE[1].push(TEBN);if (SAMMELEBENE[0].length>1) SAMMELEBENE[1].push(TAND);Logtext="SAMMELEBENE nach -AS:\n";KDUMP(SAMMELEBENE);Logfile()'>-AS</button>

<button onclick='SAMMELEBENE[0].push(DREIPUNKTE([PA.position.x*zoom,PA.position.y*zoom,PA.position.z*zoom,1],[PD.position.x*zoom,PD.position.y*zoom,PD.position.z*zoom,1],[PS.position.x*zoom,PS.position.y*zoom,PS.position.z*zoom,1]));SAMMELEBENE[1].push(TEBN);if (SAMMELEBENE[0].length>1) SAMMELEBENE[1].push(TAND);Logtext="SAMMELEBENE nach ASD:\n";KDUMP(SAMMELEBENE);Logfile()'>ASD</button>

<button onclick='scene.remove(OBJ_X[4]); var cind=Castlist.indexOf(OBJ_X); OBJ_X=RUMPS(OBJ_X,SAMMELEBENE,1);KDUMP(OBJ_X);KPLOT([OBJ_X]);AddObjekt(scene,OBJ_X);Castlist.pop(); Castlist[cind]=OBJ_X;Logfile();SAMMELEBENE=[[],[],[],[]]'>Schnitt</button>

<button onclick='scene.remove(OBJ_X[4]); var cind=Castlist.indexOf(OBJ_X); OBJ_X=TRANSFORM(OBJ_X,[[1,0,0,(PA.position.x-PS.position.x)*zoom],[0,1,0,(PA.position.y-PS.position.y)*zoom],[0,0,1,(PA.position.z-PS.position.z)*zoom],[0,0,0,1]]);KDUMP(OBJ_X);KPLOT([OBJ_X]);AddObjekt(scene,OBJ_X);Castlist.pop(); Castlist[cind]=OBJ_X;Logfile();SAMMELEBENE=[[],[],[],[]]'>MOVE</button>

<button onclick='scene.remove(OBJ_X[4]); var cind=Castlist.indexOf(OBJ_X); OBJ_X=DrehenASD(OBJ_X); KDUMP(OBJ_X);KPLOT([OBJ_X]);AddObjekt(scene,OBJ_X);Castlist.pop(); Castlist[cind]=OBJ_X;Logfile();SAMMELEBENE=[[],[],[],[]]'>Drehen</button>

<div style="max-width:90%; min-height:100%; max-height:400px; border:solid; border-color:red; overflow:hidden" id="canvas"	>hier kommt das render.domElement rein</div>
<span id="Pdisp">...</span>;
<button onclick='alert(JSON.stringify(VAS.geometry.vertices));alert(document.getElementById("canvas").scrollHeight)'>Test</button>
  </div>
<div id="Log" style="display:flex; overflow:auto; border:solid; width:90%; height:400px"> div</div>

<script src="QWASNEU/KONSTRUK_javascript.js"></script>

<script>
//var Uhr = document.getElementById('Uhr'); 
//Uhr.width=51; Uhr.height=51; 
//clock(Uhr);
  </script>

<script>//globale Variablen
var renderer;
var scene;
var camera;
//var raycaster = new THREE.Raycaster(); //aus three.js.pdf
var mouse = { x : 0, y : 0 }; 
var Castlist=[];
var q; //PUNKT_Q;
var PA,PS,PD;
var VAS;
var EASD;
var canvas_height=0;
var canvas_width=0;
var zoom=20;
var Linientyp=0;
var cube;
var REST5;
var cmin=0;
var OBJ_X=cmin;
var SCHNITTEBENE;
var SAMMELEBENE=[[],[],[],[]];
//SAMMELEBENE=[[[-0.8846517369293828,-0.14744195615489714,-0.4423258684646914,17.693034738587656]],[1],[],[]];
//SAMMELEBENE=[[[-0.8846517369293828,-0.14744195615489714,-0.4423258684646914,17.693034738587656],[-0.3841106397986879,-0.7682212795973759,-0.5121475197315839,38.41106397986879]],[1,1,2],[],[]];
  </script>

<script>//globale Funktionen
function init() {
  zoom=20;
  Linientyp=0;
  PUNKT_A=[0,0,0,1];
  Castlist=[];

  // create a scene, that will hold all our elements such as objects, cameras and lights.
  scene = new THREE.Scene();
  canvas_height=window.innerHeight;//document.getElementById("canvas").clientHeight;
  canvas_width=window.innerWidth;  //document.getElementById("canvas").clientWidth;
  //alert(canvas_width+" "+canvas_height);

  // create a camera, which defines where weâ€˜re looking at.
  //camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera = new THREE.PerspectiveCamera(45, canvas_width / canvas_height, 0.1, 1000);
  //alert(THREE.WebGLRenderer); //geht nicht bei MINT

  // create a render, sets the background color and the size
  renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(0xCCCC00, 1.0);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.addEventListener( 'click', raycast, false );

        // add light
        var light = new THREE.DirectionalLight();
        light.position.set(1200, 1200, 1200);
        scene.add(light);

  // create a cube and add to scene
  var cubeGeometry = new THREE.BoxGeometry(0.1 /* 10 * Math.random()*/, 0.1, 0.1);
//alert(JSON.stringify(cubeGeometry.faces));
  var cubeMaterial = new THREE.MeshNormalMaterial();
  cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  cube.name = 'cube';
  cube.position.x=0;
  scene.add(cube);

  //Pointer Q
  //var qGeometry = new THREE.SphereGeometry( 0.14, 32, 32 );
  var qGeometry = new THREE.BoxGeometry(0.17, 0.17, 0.17);
  var qMaterial = new THREE.MeshBasicMaterial( { color: 0xFFFF00 } );
  q = new THREE.Mesh( qGeometry, qMaterial );
  q.position.x=205/zoom;
  q.position.z=150/zoom;
  scene.add( q );
  //Knoten.push(q.position.clone());

  var AGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
  var AMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
  PA = new THREE.Mesh( AGeometry, AMaterial );
  PA.position.x=20/zoom;
  PA.position.z=0/zoom;
  scene.add( PA );
  
  var SGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
  var SMaterial = new THREE.MeshBasicMaterial( { color: 0x0000FF } );
  PS = new THREE.Mesh( SGeometry, SMaterial );
  PS.position.x=10/zoom;
  PS.position.y=30/zoom;
  PS.position.z=10/zoom;
  scene.add( PS );

  var DGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
  var DMaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000 } );
  PD = new THREE.Mesh( DGeometry, DMaterial );
  PD.position.x=0/zoom;
  PD.position.z=40/zoom;
  scene.add( PD );

  var VASmaterial = new THREE.LineBasicMaterial({ color: 0x778899, linewidth:4});
  var VASgeometry = new THREE.Geometry();
  VASgeometry.vertices = [PA.position,PS.position];
  //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
  VAS = new THREE.Line(VASgeometry, VASmaterial);
  scene.add( VAS );

  var EASDmaterial = new THREE.LineBasicMaterial({ color: 0x996633, linewidth:3});
  var EASDgeometry = new THREE.Geometry();
  EASDgeometry.vertices = [PA.position,PD.position];
  //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
  EASD = new THREE.Line(EASDgeometry, EASDmaterial);
  scene.add( EASD );

  // position and point the camera to the center of the scene
  camera.position.x = 5; //15;
  camera.position.y = 5; //16;
  camera.position.z = -12; //13
  camera.lookAt(scene.position);

  // add the output of the renderer to the html element
  document.getElementById("canvas").replaceChild(renderer.domElement,document.getElementById("canvas").firstChild);

  contr = new THREE.OrbitControls( camera ,document.getElementById("canvas"));

  scene.add(Testspline());
  }
  </script>

<script>
var DrehenASD=function(OBJ_X) {
  var RET=TRANSFORM(OBJ_X,[[1,0,0,PA.position.x*zoom],[0,1,0,PA.position.y*zoom],[0,0,1,PA.position.z*zoom],[0,0,0,1]]);

  var alpha=0; 
  if(((PD.position.z-PA.position.z)**2+(PD.position.x-PA.position.x)**2>0.00001)&&((PS.position.z-PA.position.z)**2+(PS.position.x-PA.position.x)**2>0.00001)) {
    alpha=-Math.atan2(PD.position.z-PA.position.z,PD.position.x-PA.position.x);
    alpha=alpha+Math.atan2(PS.position.z-PA.position.z,PS.position.x-PA.position.x);
    }
  var ca=Math.cos(alpha); 
  var sa=Math.sin(alpha); 
  RET=TRANSFORM(RET,[[ca,0,-sa,0],[0,1,0,0],[sa,0,ca,0],[0,0,0,1]]); 
  var beta=0;
  if(((PD.position.z-PA.position.z)**2+(PD.position.y-PA.position.y)**2>0.00001)&&((PS.position.z-PA.position.z)**2+(PS.position.y-PA.position.y)**2>0.00001)) {
    beta=-Math.atan2(PD.position.z-PA.position.z,PD.position.y-PA.position.y);
    beta=beta+Math.atan2(PS.position.z-PA.position.z,PS.position.y-PA.position.y);
    }
  var cb=Math.cos(beta); 
  var sb=Math.sin(beta); 
  RET=TRANSFORM(RET,[[1,0,0,0],[0,cb,-sb,0],[0,sb,cb,0],[0,0,0,1]]);
  RET=TRANSFORM(RET,[[1,0,0,-PA.position.x*zoom],[0,1,0,-PA.position.y*zoom],[0,0,1,-PA.position.z*zoom],[0,0,0,1]]); 
  return RET;
  }
  </script>

<script>
var neuen_Balken_plazieren=function(x,y,z,l,b,h) {
  PUNKT_A=[x,y,z,1];
  var RET=QUADER(l,b,h);
  KFILL(RET);
  KDUMP(RET);
  KPLOT([RET]);
  AddObjekt(scene,RET);
  return RET;
  }
  </script>

<script>
var Beispiel1=function() {
  init();

var BALKEN1=QUADER(200,100,150); KFILL(BALKEN1);
var SCHNITT2=EBENE([100,0,0,1],[200,50,150,1],[200,0,90,1]);
var REST1=RUMPS(BALKEN1,SCHNITT2,1);
TRANSFORM(REST1,A);
TRANSFORM(SCHNITT2,CDF);
var REST2=RUMPS(REST1,SCHNITT2,1);
var BALKEN2=QUADER(60,60,60); KFILL(BALKEN2);
var C=[[1,0,0,10],[0,1,0,10],[0,0,1,10],[0,0,0,1]];
TRANSFORM(BALKEN2,C);
var REST3=RUMPS(BALKEN1,BALKEN2,1);
var REST4=RUMPS(REST2,BALKEN2,1);
PUNKT_A=[-10,75,-10,1];
var BALKEN3=QUADER(100,15,100); KFILL(BALKEN3);
Logflag=true;
REST5=RUMPS(REST4,BALKEN3,1);
//REST5=BALKEN1;
Logtext=Logtext+"REST5="+JSON.stringify(REST5)+"\n";
Logtext=Logtext+"BALKEN3="+JSON.stringify(BALKEN3)+"\n";
KPLOT([REST1]);
KPLOT([REST4]);
KPLOT([REST5]);
Castlist.push(REST5);
cube.geometry.faces[0].color = new THREE.Color(0x000000); 
AddObjekt(scene,REST5);
Logtext=JSON.stringify(cube.geometry.faces)+"\n"+Logtext;

  Logfile(Logtext);

  //var xm=new XMLSerializer();
  //alert(xm.serializeToString(renderer.domElement));
  //alert(renderer.domElement);
 
  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }

  </script>

<script>
var Beispiel2=function() {
  init();
  zoom=200;
  Linientyp=1;
  
  // position and point the camera to the center of the scene
  camera.position.x = -5; //5; //15;
  camera.position.y = 5; //5; //16;
  camera.position.z = -12; //-12; //13
  camera.lookAt(scene.position);

  PA.position.x=0/zoom;
  PA.position.y=0/zoom;
  PA.position.z=0/zoom;

  PS.position.x=0/zoom;
  PS.position.y=0/zoom;
  PS.position.z=1700/zoom;

  PD.position.x=130/zoom;
  PD.position.y=120/zoom;
  PD.position.z=1250/zoom;

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//      " >P -250 0 0 Anlegepunkt" INTERPRET
//      " >Q 18 1700 180 rechtesBrett" INTERPRET
//var rechtes_Brett=neuen_Balken_plazieren(-250,0,0,18,180,1700);
var rechtes_Brett=neuen_Balken_plazieren(-18,0,0,18,180,1700);

//      " >P -500 0 0 Anlegepunkt" INTERPRET
//      " >Q 30 700 180 HochzuBrett" INTERPRET
var Hochzubrett=neuen_Balken_plazieren(-500,0,0,30,180,700);

//      " >P -750 0 0 Anlegepunkt" INTERPRET
//      " >Q 20 2000 20 BÃ¼gel" INTERPRET
var Buegel=neuen_Balken_plazieren(-750,0,0,20,20,2000);

  Logfile("das war Beispiel2");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }
  </script>

<script>//Logfile
//gesammelten Logtext ausgeben
function Logfile(Resttext) {
  if (!Resttext) var Resttext="";
  document.getElementById("Log").innerHTML='<span style="white-space:pre; font-family:monospace">'+Logtext+Resttext+"</span>";
  Logtext="";
  }

  </script>
  
  
<script>//raycast
function raycast ( e ) {
  //raycaster.setFromCamera( mouse, camera ) aus three.pdf ging nicht
  //1. sets the mouse position with a coordinate system where the center
  //   of the screen is the origin
  //for (var i in e) alert(i);
  //mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
  //mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
  mouse.x = ( (event.clientX-event.target.getBoundingClientRect().left) / window.innerWidth ) * 2 - 1;
  mouse.y = - ( (event.clientY-event.target.getBoundingClientRect().top) / window.innerHeight/*event.target.height*/ ) * 2 + 1;
  mouse.z = 1;

  cmin=0;
  var dmin=0;
  var pk="p";
  var pmin=[[0,0,0,1],[0,0,0,1]];
  var mindist=Infinity;
  for (var c in Castlist) {
    for (var d in Castlist[c][2]) {
      var p=Castlist[c][2][d][3];
      var dist=(new THREE.Vector3(p[0]/zoom,p[1]/zoom,p[2]/zoom)).project(camera).distanceToSquared(mouse);
      if (dist<mindist) {pk="p"; mindist=dist; cmin=c; dmin=d; pmin=[p.slice(),p.slice()];}
      }
    for (var d in Castlist[c][3]) {
      var p=Castlist[c][2];
      var k=Castlist[c][3][d];
      var dist=(new THREE.Vector3(
        (p[k[0]][3][0]+p[k[1]][3][0])/2/zoom,
        (p[k[0]][3][1]+p[k[1]][3][1])/2/zoom,
        (p[k[0]][3][2]+p[k[1]][3][2])/2/zoom
        )).project(camera).distanceToSquared(mouse);
      if (dist<mindist) {pk="k"; mindist=dist; cmin=c; dmin=d; pmin=[p[k[0]][3].slice(),p[k[1]][3].slice()];}
      }
    }
  //alert("cmin="+cmin+", dmin="+dmin+",pmin="+JSON.stringify(pmin)+", mindist="+mindist);
  q.position.x=(pmin[0][0]+pmin[1][0])/2/zoom;
  q.position.y=(pmin[0][1]+pmin[1][1])/2/zoom;
  q.position.z=(pmin[0][2]+pmin[1][2])/2/zoom;
  OBJ_X=Castlist[cmin];
  document.getElementById("Pdisp").firstChild.nodeValue=pk+dmin+"=["+[(q.position.x*zoom).toFixed(2),(q.position.y*zoom).toFixed(2),(q.position.z*zoom).toFixed(2)]+"]";
  }

  </script>

<!--script>//sonstige bisher vergebliche Versuche

//create a blue LineBasicMaterial
const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
const points = [];
points.push( new THREE.Vector3( - 10, 0, 0 ) );
points.push( new THREE.Vector3( 0, 10, 0 ) );
points.push( new THREE.Vector3( 10, 0, 0 ) );

var geometry = new THREE.BufferGeometry();//.setFromPoints( points );
var line = new THREE.Line( geometry, material );
scene.add( line );

//Bezier aus three-cookbook S.100?
var numPoints = 33;   
var start = new THREE.Vector3(-2, 1, 0);   
var middle = new THREE.Vector3(0, 0, 0);   
var end = new THREE.Vector3(2, 3, 0);
var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end); 
var tube = new THREE.TubeGeometry(curveQuad, numPoints, 0.1, 44, false);   
var mesh11 = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({opacity: 0.6,     transparent: true   }));   
cube.add(mesh11);

/*aus three.js/dok/edgesgeometry, will nicht gehen
var geometry9 = new THREE.BoxGeometry( 4, 7, 9 );alert(THREE.EdgesGeometry);
var edges9 = new THREE.EdgesGeometry( geometry9 );alert(8);
const line9 = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
  cube.add(line9);
*/

//von irgendwoher:
  var geometry = new THREE.BufferGeometry();
  var material = new THREE.LineBasicMaterial( { vertexColors: true } );
  //alert(JSON.stringify(material));
  var positions = [];
  var colors = [];
  var segments=6;
  var r=1;
  for ( var i = 0; i < segments; i ++ ) {
    var x = Math.random() * r - r / 2;
    var y = Math.random() * r - r / 2;
    var z = Math.random() * r - r / 2;
    // positions
    positions.push( x, y, z );
    // colors
    colors.push( ( x / r ) + 0.5 );
	colors.push( ( y / r ) + 0.5 );
	colors.push( ( z / r ) + 0.5 );
    }
//alert(geometry.setAttribute);
//				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
//				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
//				generateMorphTargets( geometry );
//				geometry.computeBoundingSphere();
				var line = new THREE.Line( geometry, material );
//				scene.add( line );




  </script-->

<script>
//alert(THREE.LineBasicMaterial);
function AddObjekt(OBJ1,OBJ2) {
  var temp_material = new THREE.LineBasicMaterial({ color: 0x0077f0, linewidth:2});
  var temp_geometry = new THREE.Geometry();
  temp_geometry.vertices = [new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0)];
  var temp = new THREE.Line(temp_geometry, temp_material);
  for (var iK in OBJ2[3]) { var K=OBJ2[3][iK];
    var numPoints = 2;   
    var start = new THREE.Vector3(OBJ2[2][K[0]][3][0]/zoom, OBJ2[2][K[0]][3][1]/zoom, OBJ2[2][K[0]][3][2]/zoom);   
    var middle = new THREE.Vector3(OBJ2[2][K[0]][3][0]/zoom, OBJ2[2][K[0]][3][1]/zoom, OBJ2[2][K[0]][3][2]/zoom);   
    var end = new THREE.Vector3(OBJ2[2][K[1]][3][0]/zoom, OBJ2[2][K[1]][3][1]/zoom, OBJ2[2][K[1]][3][2]/zoom);

    if (Linientyp==0) {
      var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end); 
      var tube = new THREE.TubeGeometry(curveQuad, numPoints, 0.05, 33, false);   
      var mesh11 = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({opacity: 0.99,     transparent: true   }));   
      temp.add(mesh11);
      } else {
        var materialline = new THREE.LineBasicMaterial({ color: 0x0077f0, linewidth:2});
        var geometryline = new THREE.Geometry();
        geometryline.vertices = [start,end];
        //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
        var obj2line = new THREE.Line(geometryline, materialline);
        temp.add(obj2line);
        }

    }
  OBJ2[4]=temp;
  OBJ1.add(temp);
  Castlist.push(OBJ2);
  }
  </script>

<script>
function Testspline() {

var spline = new THREE.SplineCurve3([
     new THREE.Vector3(-10, -2, 10),
     new THREE.Vector3(-4, -2, 2),
     new THREE.Vector3(0, -2, -10),
     new THREE.Vector3(2, -2, -10),
     new THREE.Vector3(0,-4,0),
     new THREE.Vector3(7, -2, 1),
     new THREE.Vector3(10, -2, 3),
     new THREE.Vector3(-10, -2, 10)]);

   var geometry = new THREE.Geometry();
   var splinePoints = spline.getPoints(50);
   var material = new THREE.LineBasicMaterial({ color: 0xff00f0   });
//   geometry.vertices = [new THREE.Vector3(0, 2, 0),new THREE.Vector3(2, 0, 2)]; //splinePoints;
   geometry.vertices = splinePoints;
   var sline = new THREE.Line(geometry, material);
   sline.name='sline';
   return sline;
  }

  </script>

<script>
/*
( nun weiter mit QUADER2
 0 CONSTANT TEND
 1 CONSTANT TEBN
 2 CONSTANT TAND
 3 CONSTANT TNOT
 4 CONSTANT TNOP
: EBENE ( <bezeichnung>  p1xa p1xb p1ya p1yb p1za p1zb p2... p3...  --> )
  0 VARIABLE HERE RAMP1 @ 1 - !
  1 , ( 1 Ebene
  2 , ( 2 VerknÃ¼pfungsangaben
  0 , ( 0 Eckpunkte zu je 28 Byte
  0 , ( 0 Kanten zu je 8 Byte
  ( Ebenenliste, ax-d>0 fÃ¼rs innere:
  EBENE0
  >R >R 2ROT B, 2SWAP B, B, R> R> B,
  TEBN , TEND ,
  ;

DECIMAL
100,0 0,0 0,0
200,0 50,0 150,0
200,0 0,0 100,0
EBENE Schnitt1
  0,0  0,0   0,0
  2,0  0,0   0,0
  0,0  2,0   0,0
  EBENE E0
  0,0  0,0   0,0
  0,0  1,0   1,0
  1,0  0,0   0,0
  EBENE E1
  1,0  0,0   0,0
  0,0  0,0   1,0
  1,0  1,0   0,0
  EBENE E2
  0,0  1,0   0,0
  1,0  1,0   1,0
  0,0  0,0   0,0
  EBENE E3
  1,0  2,0   0,0
  1,0  1,0   1,0
  0,0  2,0   0,0
  EBENE E4
HEX

  */


/*
EINGABEFENS
  Eingabefenster @ gUSE
  2
  DRU X wÃ¤hlt ein OBJEKT X
  DRU C kopiert OBJEKT X an die gleiche Stelle
  DRU A wÃ¤hlt einen PUNKT A.
  DRU S wÃ¤hlt zu A einen VEKTOR AS.
  DRU D wÃ¤hlt zu AS eine EBENE ASD.
  DRU E verschiebt X entlang AS
  DRU Q dreht X von AS in Richtung AD
  DRU W AS pendelt um AD bis AS2
  DRU F EBENE ASD sÃ¤gt OBJEKT X rechterhand ab
  DRU R VEKTOR AS sÃ¤gt OBJEKT X linkerhand ab
  DRU Y wÃ¤hlt OBJEKT Y
  DRU T OBJEKT Y spart OBJEKT X aus.
  DRU mit Shifttaste â€¹:
  DRU â€¹C lÃ¶scht Objekt X
  DRU â€¹E dreht Vektor AS um.
  DRU â€¹R hebt SÃ¤geebene auf bis R oder F
  DRU â€¹F hebt SÃ¤geebene auf bis R oder F
  DRU â€¹T Durchschnitt von Objekt X und Y
  DRU weitere Eingaben
  DRU G zur einzelnen Darstellung X und Y
  DRU 4 VergrÃ¶ÃŸerung (4:1)
  DRU 3 VergrÃ¶ÃŸerung (3:2)
  DRU 2 Verkleinerung (2:3)
  DRU 1 Verkleinerung (1:4)
  DRU J Blick von weiter links
  DRU K Blick von weiter rechts
  ;

: EINGABEFENS ;

: STARTEN
      INIT
      0 PLOTOBJ !
[ DECIMAL ]
      200 100 VERSCHIEB 2!
      1 1 SCAL 2!
      0 DREHRICHTUNG !
      1 1 5 16 0 1 PARRA1 V!
      0 1 5 16 1 1 PARRA2 V!
      ( T . 0 0 )
      00 -28 09 -28 -1 1 PARRA2 V!
      28  28 09  28  0 1 PARRA1 V!
      0 OBJEKT1 ! 0 OBJEKT2 !
      0 DISPOBJEKT !
      0 VONSCHNAPPER !
      0 0 KOSCHNAPPER1 2!
      KOSCHNAPPER2 12 0 FILL
      0 SCHIFTSTELLER !
[ HEX ] 
      SCHNAPPKANTTLISTE 8000 0 FILL ( wegen ALTSCHNAPPER @ 8 + @ GUCKOBJEKT
      SCHNAPPKANTTLISTE ALTSCHNAPPER !
      SCHNAPPKANTTLISTE NEUSCHNAPPER !
      " KONSTRUKTION LINK-OFF FORGET Eins KONSTRUKTION LINK-ON 1,0 1,0 1,0 QUADER Eins" 
      INTERPRET
      ( 11 EMIT ( setzt AUSG%=1 fÃ¼r SPOOL, neuerdings nichmehr
      SPOOL ." 5 ANWEND!" CR ." STARTEN" CR
(      " T . 0 0 " INTERPRET
(  0 DREHTAPPER
      SPOOLOFF
      ll
  ;

TAPP: N STARTEN ;
TAPP: O 1 SCHIFTSTELLER !
  TAPP ASC C CASEOF ;
TAPP: U 1 SCHIFTSTELLER !
  TAPP ASC E CASEOF 0 SCHIFTSTELLER ! ;
TAPP: P 1 SCHIFTSTELLER !
  TAPP ASC R CASEOF ;
TAPP: L 1 SCHIFTSTELLER !
  TAPP ASC F CASEOF ;
TAPP: V 1 SCHIFTSTELLER !
  TAPP ASC T CASEOF ;

: QUADER111
      " >S 0,6 VergrÃ¶ÃŸerung" INTERPRET
      " >P 0 0 0 Anlegepunkt" INTERPRET
      " >Q 355 115 115 Hinterbalken" INTERPRET
      " >P 130 1250 0 Anlegepunkt" INTERPRET
      " >Q 120 370 120 Vorderbalken" INTERPRET
      " >P -250 0 0 Anlegepunkt" INTERPRET
      " >Q 18 1700 180 rechtesBrett" INTERPRET
      " >P -500 0 0 Anlegepunkt" INTERPRET
      " >Q 30 700 180 HochzuBrett" INTERPRET
      " >P -750 0 0 Anlegepunkt" INTERPRET
      " >Q 20 2000 20 BÃ¼gel" INTERPRET
      " >T X 0 0" INTERPRET
      " >T . 0 0" INTERPRET
(  " >P 0 0 0 " INTERPRET
(  " >Q 1 1 1 " INTERPRET
(  " >T X 0 0 " INTERPRET
  ;

: TAB ;


KONSTRUKTION VOCABULARY-END


DECIMAL
*/



/*
FEHLERTEXT ( nr --> adr n )
  DUP 500 < IF FEHLERTEXT ELSE >R
    R 502 = IF U" OBJEKT X ist nicht markiert" ENDIF
    R 503 = IF U" OBJEKT Y ist nicht markiert" ENDIF
    R 504 = IF U" VEKTOR AS ist nicht markiert oder A fÃ¤llt mit S zusammen" ENDIF
    R 505 = IF U" EBENE ASD ist nicht markiert oder A fÃ¤llt mit S oder D zusammen" ENDIF
    R 506 = IF U" AS und AD sind parallel" ENDIF
    R 507 = IF U" AS2 und AD sind parallel" ENDIF
    R 508 = IF U" Wurzel aus negativer ganzen Zahl" ENDIF
    R 500 = IF U" Wurzel aus negativer rationalen Zahl" ENDIF
    R 501 = IF U" Fehler im Rechenausdruck" ENDIF
    R 508 > IF " ???" ENDIF
    R> DROP ENDIF
  ;
  */
  </script>
</body>
</html>
