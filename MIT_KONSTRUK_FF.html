<!DOCTYPE html>
<html>
<head>
  <!-- verwendete Vorlage: three-cookbook/.../01.05-setup-animation-loop.html -->
  <!-- was noch nicht geht:
.. Reihenfolge ASD soll positive Seite der Ebene bestimmen
.. die stimmt aber nicht beim Keil, deshalb auch -ASD
    -->
  <meta charset="utf-8"/>
  <title>MIT_KONSTRUK_FF.html</title>

  <!--script src="./threejs-cookbook/libs/three.js"></script-->
  <!--script src="./threejs-cookbook/libs/OrbitControls.js"></script-->
  </head>
<body>
<!--canvas id="Uhr"> </canvas-->
<div>zur Zeit 8 Eingabebeispiele: 
  <button id='button_Beispiel1'>REST5</button>,
  <button id='button_Beispiel2'>GOKART</button> und
  <button id='button_Beispiel3'>DACH</button>.
  <button id='button_Beispiel4'>QUADER</button>.
  <button id='button_Beispiel5'>FLÄCHEN</button>.
  <button id='button_Beispiel6'>WINKEL</button>.
  <button id='button_Beispiel7'>SCHUSTERBURG</button>.
  <button id='button_Beispiel8'>NUT_UND_FEDER</button>.
  <button id='button_Beispiel9'>NUT_UND_FEDER_extrem</button>.
  <button id='button_Beispiel10'>QUADER_defekt</button>.
  </div>
<hr/>
<button id='button_TA'>TA()</button>
<button id='button_TS'>TS()</button>
<button id='button_TD'>TD()</button>

<button id='button_TUmdrehen'>umdrehen</button>
<button id='button_TMerken'>merken</button>
<button id='button_TKopieren'>kopieren</button>
<button id='button_TVerschieben'>verschieben</button>
<button id='button_TDrehen'>drehen</button>
<button id='button_TSchneiden'>schneiden</button>
<button id='button_TLoeschen'>löschen</button>
<span id="mouse"> </span>



<div style="max-width:86%; border:solid; border-color:red; overflow:hidden" id="canvas"	>hier kommt das render.domElement rein</div>
<button id='button_Test'>Test</button>
<button id='button_Zentrieren'>Zentrieren</button>
<button id='button_einzeln'>einzeln</button>
<button id='button_ANF_Test'>gefüllt</button>
schaue_von_und_nach(<span id="camerapos">...</span>);
<span id="Pdisp">...</span>;
  </div>
<div id="Log2" style="display:flex; overflow:auto; border:solid; width:90%; height:200px"> div</div>
<div id="Log" style="display:flex; overflow:auto; border:solid; width:90%; height:200px"> div</div>
<div id="KPLOTelement">KPLOT</div>
<div>Export zu freeCAD: 
  <button id='button_Auswaehlen'>ausgewähltes Objekt</button>, 
  <button id='button_Verlauf'>Verlauf</button>
  </div>
<div id="exportiere" style="display:flex; white-space:pre; font-family:monospace; overflow:auto; border:solid; width:90%; height:368px"> export</div>

<!--script src="QWASNEU/KONSTRUK_javascript.js"></script-->
<!--script src="QWASNEU/ANF.js"></script-->

<script>
//var Uhr = document.getElementById('Uhr'); 
//Uhr.width=51; Uhr.height=51; 
//clock(Uhr);
  </script>

		<script type="importmap">
			{
				"imports": {
					"three": "./threejs2024/build/three.module.js",
					"three/addons/": "./threejs2024/examples/jsm/"
				}
			}
		</script>

<script type='module'>





//--------------------♥KONSTRUK_javascript.js



//Veränderungen zu GAP:
//1.PGGT ohne /-P[3]
//in KFILL if (PZZS[2*PNR][1]<=PZZS[2*PNR+1][1])
//in TFIND if (Math.abs(A)<0.00001) return 2; //Rand
//ok neues EGGT normalisiert und gerichtet, bisheriges EGGT ist jetzt PGGT.
//..
//sonst zu machen noch:
//.. in svg-KPLOT noch width und height anpassen
//.. überflüssige Ebenen entfernen
//ok warum in KFILL das if drinbeiben muss, ok ist raus
//.. wie es zu dem U==[0,0,0,0] kommt, parrallel vielleicht?
//.. bei AUFDERKANTE muß wohl ein AUFDERFLAECHE auch mit dazu
//.. wenn sich mehr als 3 Ebenen in einem Punkt schneiden ist nur behelfsweise gelöst
//.. Keil auch nur behelfsmäßig in GERADEXEBENE, bis jetzt nur 2 Ebenen
//.. doppeltes TEbeneASD() vermeiden
//.. und fast übereinanderliegende Ebenen zusammenfassen

let Logtext="";
let Logflag=false;
Logtext=Logtext+"KONSTRUK_javascript.js laden...\n";
var Testflag=false;

var TEBN=1;
var TAND=2;
var TNOT=3;

var TSETZ=function(A) {
  if (Math.abs(A)<0.000005) return 2; //Rand
  if (A<0) return 3;  //draussen
  if (A>0) return 1;  //innen
  }
//alert(TSETZ(-7));

//1
var PUNKTWERT=function(EBENE,PUNKT) { //Funktionswert der Ebenengleichung für einen Punkt P
  return PUNKT[0]*EBENE[0]+PUNKT[1]*EBENE[1]+PUNKT[2]*EBENE[2]+PUNKT[3]*EBENE[3];
  }
//alert("PUNKTWERT 1 "+PUNKTWERT([1,0,0,1],[-1,0,0,0]));//-1

var TFIND=function(OBJ,ENR,P) {
  return TSETZ(PUNKTWERT(OBJ[0][ENR],P));
  }
//alert("TFIND 3 "+TFIND([[[1,0,0,1]]],0,[-1,0,0,0]));

//2
var STAPEL=[];
let DURCHGUCKER=function(OBJ,P) { // ob P im Inneren oder auf Rand von OBJ
  //außerdem, wenn IL gegeben ist, nur die Ebenen in IL auswerten
  //local X,Y,T,ETNR;
  if (P[0]==0&P[1]==0&P[2]==0&P[3]==0) return 3;
  var X=0;
  var Y=0;
  var ETNR=0; //ETNR für ETADR
  for (var i in OBJ[1]) { var T=OBJ[1][i]
  //for (var T of OBJ[1]) { 
    //alert("TFIND\n"+OBJ+"\n"+ETNR+"\n"+P+"\n"+TFIND(OBJ,ETNR,P));
    if (T==TEBN) { STAPEL.push(X); X=TFIND(OBJ,ETNR,P); ETNR=ETNR+1 }
    if (T==TAND) X=Math.max(X,STAPEL.pop());
    if (T==TNOT) X=4-X;
    //alert(ETNR+" "+T+" "+STAPEL);
    }
  return X;
  }
//alert("DURCHGUCKER 3 "+DURCHGUCKER([[[1,0,0,1]],[TEBN]],[-1,0,0,1]));//3
//alert("DURCHGUCKER 3 "+DURCHGUCKER([[[1,0,0,0],[0,1,0,0],[0,0,1,0],[-1,0,0,100],[0,-1,0,150],[0,0,-1,200]],[TEBN,TEBN,TAND,TEBN,TAND,TEBN,TAND,TEBN,TAND,TEBN,TAND],[],[]],[-1,0,0,1]));//3
//alert("DURCHGUCKER 3 "+DURCHGUCKER([[[0,-1,0,100]],[TEBN]],[0,101,0,1]));//3
//alert(nix);

//3
var PGGT=function(E) { //kürzt Punktkoordinaten, gemeinsame Faktoren herausdividieren
  if (E[3]<0) return [E[0]/E[3],E[1]/E[3],E[2]/E[3],1];
  if (E[3]==0) return E;
  if (E[3]>0) return [E[0]/E[3],E[1]/E[3],E[2]/E[3],1];
  }
//alert("PGGT 2.5,2,1.5,1 "+PGGT([10,8,6,4]));
	
var EGGT=function(E) { //kürzt Ebenengleichung, gemeinsame Faktoren herausdividieren
  var len=Math.sqrt(E[0]*E[0]+E[1]*E[1]+E[2]*E[2]);
  return [E[0]/len,E[1]/len,E[2]/len,E[3]/len];
  }
//alert("PGGT 2.5,2,1.5,1 "+PGGT([10,8,6,4]));
	
//4
var Determinant3=function(A) {
  return A[0][0]*A[1][1]*A[2][2]+A[0][1]*A[1][2]*A[2][0]+A[0][2]*A[1][0]*A[2][1]
        -A[0][0]*A[2][1]*A[1][2]-A[0][1]*A[1][0]*A[2][2]-A[0][2]*A[1][1]*A[2][0];
  }
//alert("Determinant -3 "+Determinant3([[1,2,3],[2,3,3],[3,3,3]]));

var DREIEBENEN=function(E1,E2,E3) { //Schnittpunkt dreier Ebenen
  var RET=PGGT([
    Determinant3( [[E1[1],E1[2],E1[3]],[E2[1],E2[2],E2[3]],[E3[1],E3[2],E3[3]]]),
    -Determinant3([[E1[2],E1[3],E1[0]],[E2[2],E2[3],E2[0]],[E3[2],E3[3],E3[0]]]),
    Determinant3( [[E1[3],E1[0],E1[1]],[E2[3],E2[0],E2[1]],[E3[3],E3[0],E3[1]]]),
    -Determinant3([[E1[0],E1[1],E1[2]],[E2[0],E2[1],E2[2]],[E3[0],E3[1],E3[2]]])
    ]);
  //alert([[E1[0],E1[1],E1[2]],[E2[0],E2[1],E2[2]],[E3[0],E3[1],E3[2]]].join("\n"));
  //alert(RET);
  return RET;
  }
//alert("\nDREIEBENEN:1,2,0,1 "+DREIEBENEN([1,0,0,1],[0,1,0,2],[0,0,1,0]));
//alert("\nDREIEBENEN:0,100,0,1 "+DREIEBENEN([1,0,0,0],[0,0,1,0],[0,-1,0,100]));
//alert(nix);

var DREIPUNKTE=function(E1,E2,E3) { //Ebene durch drei Punkte
  var RET=EGGT([
    Determinant3( [[E1[1],E1[2],E1[3]],[E2[1],E2[2],E2[3]],[E3[1],E3[2],E3[3]]]),
    -Determinant3([[E1[2],E1[3],E1[0]],[E2[2],E2[3],E2[0]],[E3[2],E3[3],E3[0]]]),
    Determinant3( [[E1[3],E1[0],E1[1]],[E2[3],E2[0],E2[1]],[E3[3],E3[0],E3[1]]]),
    -Determinant3([[E1[0],E1[1],E1[2]],[E2[0],E2[1],E2[2]],[E3[0],E3[1],E3[2]]])
    ]);
  //alert([[E1[0],E1[1],E1[2]],[E2[0],E2[1],E2[2]],[E3[0],E3[1],E3[2]]].join("\n"));
  //alert(RET);
  return RET;
  }

//5
var EBENE=function(P1,P2,P3) { //Objekt Ebene durch drei Punkte P1, P2, P3,
  return [[DREIPUNKTE(P1,P2,P3)],[TEBN],[],[]];
  }

var SCHNITT1=EBENE([1,0,0,1],[0,1,0,1],[0,0,0,1]);
var SCHNITT2=EBENE([100,0,0,1],[200,50,150,1],[200,0,90,1]);
var SCHNITT3=EBENE([100,0,0,1],[200,0,90,1],[200,50,150,1]);
//alert("SCHNITT1 "+SCHNITT1.join("\n"));

//6
var QFILL=function(OBJ) { //Berechnet und ergänzt Koordinatenangabe [ei,ej,ek,[xi,xj,xk,xl]]
  //local i,j,k,n,P;
  OBJ[2]=[];
  OBJ[3]=[];
  var P=0;
  var n=OBJ[0].length;
  for (var i=0;i<n;i++) {
    for (var j=i+1;j<n;j++) {
      for (var k=j+1;k<n;k++) {
        P=DREIEBENEN(OBJ[0][i],OBJ[0][j],OBJ[0][k]);
        if (P[3]<0) P=[-P[0],-P[1],-P[2],-P[3]];
        if (DURCHGUCKER(OBJ,P)!=3) OBJ[2].push([i,j,k,P]);
//alert("xxx\n"+JSON.stringify(OBJ)+"\n-------------\n"+[i,j,k]+"\n"+P+"\n"+DURCHGUCKER(OBJ,P));
        }
      }
    }
  return OBJ;
  }

var PUNKT_A=[0,0,0,1];
var QUADER=function(L,B,H) { //Objekt "Quader"
  return QFILL([
    [[1,0,0,-PUNKT_A[0]],[0,1,0,-PUNKT_A[1]],[0,0,1,-PUNKT_A[2]],
     [-1,0,0,PUNKT_A[0]+L],[0,-1,0,PUNKT_A[1]+B],[0,0,-1,PUNKT_A[2]+H]],
    [TEBN,TEBN,TAND,TEBN,TAND,TEBN,TAND,TEBN,TAND,TEBN,TAND],
    [],[]]);
  }
var BALKEN1=QUADER(200,100,150);
if (Logflag) Logtext=Logtext+"BALKEN1 mit 6 Ebenen und 8 Eckpunkten:\nEbenen="+JSON.stringify(BALKEN1[0])+"\n";
if (Logflag) Logtext=Logtext+"Verknüpfung 1=Ebene, 2=AND, 3=NOT: "+JSON.stringify(BALKEN1[1])+"\n";
if (Logflag) Logtext=Logtext+"Eckpunkte [Ebene1,Ebene2,Ebene3,[x,y,z,1]]: "+JSON.stringify(BALKEN1[2])+"\n";

//alert(DURCHGUCKER(BALKEN1,[0,0,0,1]));
//alert(DURCHGUCKER(BALKEN1,[0,0,1,1]));
//alert(DURCHGUCKER(BALKEN1,[0,1,1,1]));
//alert(DURCHGUCKER(BALKEN1,[1,1,1,1]));
//alert(DURCHGUCKER(BALKEN1,[-1,1,1,1]));
//alert(DURCHGUCKER(BALKEN1,[100,0,0,1]));
//alert(DURCHGUCKER(BALKEN1,[199,99,149,1]));
//alert(DURCHGUCKER(BALKEN1,[200,100,150,1]));
//alert(DURCHGUCKER(BALKEN1,[200,100,151,1]));

//7
//PFILL(...) weglassen

var MERK12=[];
var MERK=[];
var DFILL=function(OBJ) { //füllt eine temporäre separate Liste MERK12 mit Kantenfluchtlinien
  MERK12=[];
  MERK=[];
  //for (P of OBJ[2]) {//alert(JSON.stringify(P));
  for (var iP in OBJ[2]) {var P=OBJ[2][iP]
    if (P[5]) ; else P[5]=[P[0],P[1],P[2]];
    for (var i=1; i<P[5].length;i++) for (var j=0;j<i;j++) if (MERK12.indexOf("["+[P[5][j],P[5][i]]+"]")==-1) {
      MERK12.push("["+[P[5][j],P[5][i]]+"]");
      var M=[P[5][j],P[5][i]];
//      if (j==0&&i==1) M.push(P[5][2]);
//      if (j==0&&i>1) M.push(P[5][1]);
//      if (j>0) M.push(P[5][0]);
      let weiter_suchen=true;
      for (let kk=0;kk<P[5].length;kk++) if (weiter_suchen) {
        let punkt=DREIEBENEN(OBJ[0][M[0]],OBJ[0][M[1]],OBJ[0][P[5][kk]]);
        if (kk!=i&&kk!=j&&punkt[3]>0.5) {//nochmal ohne kk!=j&&kk!=i schauen warum da bei j==0 i==1 kk==0 punkt[3]==1 ist
          M.push(P[5][kk]);
          weiter_suchen=false;
          if (M[2]==M[0]) alert(M+'\n'+punkt+'\n'+P[5]+'\n'+[j,i,kk]);
          }
        }
      if (M.length>2) MERK.push(M); //wie kann hier M.length==2 sein? Bei NUT_UND_FEDER
      }
    }
  }
DFILL(BALKEN1); 
//alert("MERK12="+JSON.stringify(MERK12));
//alert("MERK="+JSON.stringify(MERK));


//8
function Zsort(a,b) {if (a<b) return -1;if (a==b) return 0; return 1}
function Asort(a,b) {if (a[0]<b[0]) return -1;if (a[0]==b[0]) return 0; return 1}

var KFILL=function(OBJ) { //fuellt Kantenliste [pnr1,pnr2,enr1,enr2]
  if (Logflag) Logtext=Logtext+"starte KFILL(OBJ)\n";
//  if (Logflag) alert("starte KFILL(OBJ)\n");
//  if (Logflag) OBJ[2][0][5]=[4,10,15,16];//bei NUT_UND_FEDER_defekt♥
  if (Logflag) KDUMP(OBJ);
  for (let ii=0;ii<OBJ[2].length;ii++) {
    let P=OBJ[2][ii];
    if (P[6]&&P[6].length>0) {
      for (let jj=0;jj<P[6].length;jj++) {
        if (P[5].indexOf(P[6][jj])==-1) P[5].push(P[6][jj]);
        }
      P[5]=P[5].sort(Zsort);//war zwischendurch .slice().sort(Zsort)
      }
    //delete P[6];
    }
  //local M,PNR,PZZS,PZZT;
//  if (Logflag) alert("starte DFILL(OBJ)\n");
  DFILL(OBJ);
  if (Logflag) Logtext=Logtext+'MERK=\n'+MERK.join('\n')+'\n';
//  if (Logflag) alert('MERK=\n'+MERK.join('\n')+'\n');
  if (Logflag) Logtext=Logtext+'MERK12=\n'+MERK12.join('\n')+'\n';
//  if (Logflag) alert('MERK12=\n'+MERK12.join('\n'));
  OBJ[3]=[];
  //for (var M of MERK) {
  for (var iM in MERK) { var M=MERK[iM];
    if (Logflag) Logtext=Logtext+"Kantenfluchtlinie "+M+"\n";
    var PZZT=[];
    for (var PNR=0;PNR<OBJ[2].length;PNR++) {
      var P=OBJ[2][PNR];//alert(PNR);
//      if (Logflag) alert(iM+" "+MERK.length+" Kantenfluchtlinie "+JSON.stringify(M)+' PNR='+PNR+';\nP='+JSON.stringify(P));
      if (P[5]) ; else P[5]=[P[0],P[1],P[2]];
      for (var i=0; i<P[5].length;i++) for (var j=0;j<i;j++) 
        if ((M[0]==P[5][i]&&M[1]==P[5][j])||(M[1]==P[5][i]&&M[0]==P[5][j])) {
          if (j==0&&i==1) PZZT.push([PUNKTWERT(OBJ[0][M[2]],P[3]),PNR,P[5][2],P[5]]);
          if (j==0&&i>1) PZZT.push([PUNKTWERT(OBJ[0][M[2]],P[3]),PNR,P[5][1],P[5]]);
          if (j>0) PZZT.push([PUNKTWERT(OBJ[0][M[2]],P[3]),PNR,P[5][0],P[5]]);
          }
      }
    var PZZS=PZZT.sort(Asort);
//    if (Logflag) alert("PZZS="+JSON.stringify(PZZS));
    //var PZZR=[PZZS[0]];
    //for (var i=1;i<PZZS.length;i++) if (PZZS[i][0]-PZZS[i-1][0]>=0.0001) PZZR.push(PZZS[i]);
    //PZZS=PZZR;
//    if (Logflag) alert("PZZS="+JSON.stringify(PZZS));
//    if (PZZS.length%2==1) alert("PZZS.length ist ungerade");
    if (Logflag) Logtext=Logtext+"  "+PZZS.length+" PZZS="+JSON.stringify(PZZS)+"\n";
//    for (var PNR=0;PNR<(PZZS.length-1)/2;PNR++) /*if (PZZS[2*PNR][1]<=PZZS[2*PNR+1][1])*/ { //warum geht ohne if nicht?
//      if (Logflag) Logtext=Logtext+"    neue Kante von Punkt P"+PZZS[2*PNR][1]+" bis Punkt P"+PZZS[2*PNR+1][1]+" entlang der Schnittgeraden von Ebene E"+M[0]+" und Ebene E"+M[1]+"\n";
//      OBJ[3].push([PZZS[2*PNR][1],PZZS[2*PNR+1][1],M[0],M[1],PZZS[2*PNR][2],PZZS[2*PNR+1][2]]);
//      }
    for (var PNR=1;PNR<PZZS.length;PNR++) {
      var PNT=[
    (OBJ[2][PZZS[PNR][1]][3][0]+OBJ[2][PZZS[PNR-1][1]][3][0])/2,
    (OBJ[2][PZZS[PNR][1]][3][1]+OBJ[2][PZZS[PNR-1][1]][3][1])/2,
    (OBJ[2][PZZS[PNR][1]][3][2]+OBJ[2][PZZS[PNR-1][1]][3][2])/2,
    1];
      var DU=DURCHGUCKER(OBJ,PNT);
      if (Logflag) Logtext=Logtext+"    PNT=["+PNT+"] DU="+DU+"\n";
      if (DU==2) {
        if (Logflag) Logtext=Logtext+"    neue Kante von Punkt P"+PZZS[PNR-1][1]+" bis Punkt P"+PZZS[PNR][1]+" entlang der Schnittgeraden von Ebene E"+M[0]+" und Ebene E"+M[1]+"\n";
        OBJ[3].push([PZZS[PNR-1][1],PZZS[PNR][1],M[0],M[1],PZZS[PNR-1][2],PZZS[PNR][2]]);
        }
      }
    }
  if (Logflag) KDUMP(OBJ);
  if (Logflag) Logtext=Logtext+"return aus KFILL(OBJ)\n";
  }
      
KFILL(BALKEN1);
//Logtext=Logtext+JSON.stringify(BALKEN1[0])+"\n";
//Logtext=Logtext+JSON.stringify(BALKEN1[2])+"\n";
if (Logflag) Logtext=Logtext+"Kanten [Punkt1,Punkt2,Ebene1,Ebene2]: "+JSON.stringify(BALKEN1[3])+"\n";

//9
var dist=function(A,B) { return Math.sqrt((A[0]-B[0])*(A[0]-B[0])+(A[1]-B[1])*(A[1]-B[1])+(A[2]-B[2])*(A[2]-B[2])) }//war vor 11
var dist4=function(A,B) { return Math.sqrt((A[0]-B[0])*(A[0]-B[0])+(A[1]-B[1])*(A[1]-B[1])+(A[2]-B[2])*(A[2]-B[2])+(A[3]-B[3])*(A[3]-B[3])) }
var dist4M=function(A,B) { return Math.sqrt((A[0]+B[0])*(A[0]+B[0])+(A[1]+B[1])*(A[1]+B[1])+(A[2]+B[2])*(A[2]+B[2])+(A[3]+B[3])*(A[3]+B[3])) }

var GERADEXEBENE=function(OBJ1,OBJ2) { //Schnittpunkte der Kanten von OBJ1 mit Ebenen von OBJ2
  //local U,V,W,KANTE,EBENE,ERG,ENR;
  var ERG=[];
  //for (var KANTE of OBJ1[3]) {
  if (OBJ1[0].length==2) {//Keil
    for (var ENR=0;ENR<OBJ2[0].length;ENR++) {
      if (Logflag) Logtext=Logtext+"Kante k"+0+"="+JSON.stringify("...")+" und Ebene e"+JSON.stringify(ENR)+" ";
      var U=DREIEBENEN(OBJ1[0][0],OBJ1[0][1],OBJ2[0][ENR]);
      if (Logflag) Logtext=Logtext+"Schnittpunkt in "+JSON.stringify(U)+" ";
      var W=DURCHGUCKER(OBJ2,U);
      if (Logflag) Logtext=Logtext+"W="+W+" ";
      if (W==2&&Math.abs(U[3])>0.0001) {
        ERG.push([0,1,ENR,U,,,[0,1]]);//[0,1]
        if (Logflag) Logtext=Logtext+"♥ drin" 
        } else if (Logflag) Logtext=Logtext+"draußen";
      if (Logflag) Logtext=Logtext+"\n";      
      }
    
    }
  for (var iKANTE in OBJ1[3]) { var KANTE=OBJ1[3][iKANTE]
    for (var ENR=0;ENR<OBJ2[0].length;ENR++) { //hier ginge auch in OBJ2[1], ENR nur wegen Print
      if (Logflag) Logtext=Logtext+"Kante k"+iKANTE+"="+JSON.stringify(KANTE)+" und Ebene e"+JSON.stringify(ENR)+" ";
      var U=DREIEBENEN(OBJ1[0][KANTE[2]],OBJ1[0][KANTE[3]],OBJ2[0][ENR]);
      //if U[4]<0 then U:=-U; fi;// ist jetzt PGGT
      if (Math.abs(U[3])<0.0001) {if (Logflag) Logtext=Logtext+"parallel\n"; continue}
      if (Logflag) Logtext=Logtext+"Schnittpunkt in "+JSON.stringify(U)+" ";
      var V=3;
      //var V=DURCHGUCKER(OBJ1,U);
      //var V=DURCHGUCKER(OBJ1,U,[KANTE[3],KANTE[4]]);
      //var F=DURCHGUCKER(OBJ1,U,[KANTE[4],KANTE[5]]);
      //if (Logflag) Logtext=Logtext+"IL=["+[KANTE[4],KANTE[5]]+"] F="+F+" ";
//      if ((TFIND(OBJ1,KANTE[4],U)+TFIND(OBJ1,KANTE[4],OBJ1[2][KANTE[1]][3])!=4)&(TFIND(OBJ1,KANTE[5],U)+TFIND(OBJ1,KANTE[5],OBJ1[2][KANTE[0]][3])!=4)) V=2; //ging nicht mehr in Beispiel "Flächen" weil KANTE[4] und KANTE[5] nicht stimmt, jetzt mit udist4
      if ((dist4(U,OBJ1[2][KANTE[1]][3])<=dist4(OBJ1[2][KANTE[0]][3],OBJ1[2][KANTE[1]][3])+0.00001)&&(dist4(U,OBJ1[2][KANTE[0]][3])<=dist4(OBJ1[2][KANTE[0]][3],OBJ1[2][KANTE[1]][3])+0.00001)) V=2;
      if (Logflag) Logtext=Logtext+"V="+V+" ";
      var W=DURCHGUCKER(OBJ2,U);
      if (Logflag) Logtext=Logtext+"W="+W+" ";
      if ((V==2)&(W==2)) {
      //if ((F<3)&(W==2)) {
        let KX=[];
        //if (KANTE[7]) KX=KANTE[7].slice();
        let KY1=OBJ1[2][KANTE[0]][5];
        let KY2=OBJ1[2][KANTE[1]][5];
        for (let j=0;j<KY1.length;j++) if (KY2.indexOf(KY1[j])>-1) KX.push(KY1[j]);
        ERG.push([KANTE[2],KANTE[3],ENR,U,,,KX]);
        if (Logflag) Logtext=Logtext+"♥ drin mit ["+KY1+']&cap;['+KY2+']=['+KX+']';
        } else if (Logflag) Logtext=Logtext+"draußen";
      //if ((F<3)&(V==3)) if (Logflag) Logtext=Logtext+"----------";
      if (Logflag) Logtext=Logtext+"\n";
      }
    }
  return ERG;
  }
var GX=GERADEXEBENE(BALKEN1,SCHNITT2);
if (Logflag) Logtext=Logtext+"GERADEXEBENE(BALKEN1,SCHNITT2)="+JSON.stringify(GX)+"\n";
if (Logflag) Logtext=Logtext+"DURCHGUCKER(SCHNITT2,[200,50,150.0010,1])="+DURCHGUCKER(SCHNITT2,[200,50,150.0010,1])+"\n";
if (Logflag) Logtext=Logtext+"DURCHGUCKER(SCHNITT2,[200,50,150.0001,1])="+DURCHGUCKER(SCHNITT2,[200,50,150.0001,1])+"\n";
if (Logflag) Logtext=Logtext+"DURCHGUCKER(SCHNITT2,[200,50,150.0000,1])="+DURCHGUCKER(SCHNITT2,[200,50,150.0000,1])+"\n";
if (Logflag) Logtext=Logtext+"DURCHGUCKER(SCHNITT2,[200,50,149.9999,1])="+DURCHGUCKER(SCHNITT2,[200,50,149.9999,1])+"\n";
if (Logflag) Logtext=Logtext+"DURCHGUCKER(SCHNITT2,[200,50,149.9990,1])="+DURCHGUCKER(SCHNITT2,[200,50,149.9990,1])+"\n";


//10
var SCHNITTPUNKTE=function(OBJ1,OBJ2) { //Schnittpunkte der Kanten eines OBJ mit Ebenen des anderen OBJ
  //local TRU,E,ERG12,ERG21,MERK;
  var TRU=OBJ1[0].length;
  if (Logflag) Logtext=Logtext+"GERADEXEBENE(OBJ1,OBJ2) "+JSON.stringify(TRU)+"\n";
  var ERG12=GERADEXEBENE(OBJ1,OBJ2);
  //for (var E of ERG12) E[2]=E[2]+TRU;
  for (var iE in ERG12) { var E=ERG12[iE]; E[2]=E[2]+TRU; if (E[6].length) E[6].push(E[2])}
  if (Logflag) Logtext=Logtext+"ERG12 "+JSON.stringify(ERG12)+"\n";
  if (Logflag) Logtext=Logtext+"GERADEXEBENE(OBJ2,OBJ1) "+JSON.stringify(TRU)+"\n";
  var ERG21=GERADEXEBENE(OBJ2,OBJ1);
  if (Logflag) Logtext=Logtext+"ERG21 "+JSON.stringify(ERG21)+"\n";
  //for (var E of ERG21) { 
  for (var iE in ERG21) { var E=ERG21[iE];
    E[0]=E[0]+TRU; E[1]=E[1]+TRU; if (E[6].length) {for (let ii=0;ii<E[6].length;ii++) E[6][ii]=E[6][ii]+TRU; E[6].push(E[2])}
    var MERK=E[2];E[2]=E[1];E[1]=E[0];E[0]=MERK; //sortiert lassen
    }
  if (Logflag) Logtext=Logtext+"ERG12+21 "+JSON.stringify(ERG12.concat(ERG21))+"\n";
  return ERG12.concat(ERG21);
  }

var SX=SCHNITTPUNKTE(BALKEN1,SCHNITT2);
if (Logflag) Logtext=Logtext+"SCHNITTPUNKTE(BALKEN1,SCHNITT2)="+JSON.stringify(SX)+"\n";

//10a KDUMP
var markObj=function(cmin,ekp,i,value) {
  alert([cmin,ekp,i,value].join("+"));
  }
var spanObj=function(cmin,ekp,i,value) {
  var ret='<span moduleclick="markObj('+cmin+','+ekp+','+i+','+value+')">'+"etpk"[ekp]+i+"="+value+"</span>";
  return ret;
  }

//cmin ist globale Variable in MIT_KONSTRUK_FF.html
var KDUMP=function(OBJ) {
  Logtext=Logtext+"  Ebenen: ei=[nx,ny,nz,w]\n";
  for (var i in OBJ[0]) Logtext=Logtext+"    "+spanObj(cmin,0,i,JSON.stringify(OBJ[0][i]))+"\n";
  Logtext=Logtext+"  Verknüpfung: T="+JSON.stringify(OBJ[1])+"\n";
  Logtext=Logtext+"  Punkte pi=[ei,ej,ek,[x,y,z,1]]:\n";
  for (var i in OBJ[2]) Logtext=Logtext+"    "+spanObj(cmin,2,i,JSON.stringify(OBJ[2][i]))+"\n";
  Logtext=Logtext+"  Kanten ki=[pi,pj,ek,el,evon,ebis]:\n";
  for (var i in OBJ[3]) Logtext=Logtext+"    "+spanObj(cmin,3,i,JSON.stringify(OBJ[3][i]))+"\n";
  }

//vor 11 RUMPS:
var KEBN=function(OBJ) { //fast gleiche Ebenen finden
  var E=OBJ[0];
  for (var i=0;i<E.length;i++) {
    E[i][4]=i;
    for (var j=0;j<i;j++) {
      if (dist4(E[i],E[i-j-1])<0.0001) E[i][4]=i-j-1;
      if (dist4M(E[i],E[i-j-1])<0.0001) E[i][4]=i-j-1;//-(i-j-1)-1;
      }
    }
  }

var KASP=function(OBJ) {//KASP fasst nahe Punkte zusammen:
  var E=OBJ[0];
  var P=OBJ[2];
  for (var i=0;i<P.length;i++) {
    var imin=i;
    P[imin][4]=[];
    if (P[i][5]) ; else P[i][5]=[P[i][0],P[i][1],P[i][2]];
    for (var j=i;j>=0;j--) if (dist(P[j][3],P[i][3])<0.001) imin=j;
    P[imin][4].push(i);
    }
  var Pneu=[];
  for (var i=0;i<P.length;i++) if (P[i][4].length>0) Pneu.push(P[i]);
  //for (var i=0;i<P.length;i++) if ((P[i][4].length%2)!=0) Pneu.push(P[i]);
  //var Q=[];
  //for (var i=0;i<Pneu.length;i++) for (var j=0;j<Pneu[i][4].length;j++) Q[Pneu[i][4][j]]=i;
  for (var i=0;i<Pneu.length;i++) { //alle bisherigen bestimmenden Ebenen sammeln
    var EL=[]; //Ebenenliste
    for (var j=0;j<Pneu[i][4].length;j++) {
      var PJ=P[Pneu[i][4][j]];//alert(P[5]);
      for (var k=0;k<PJ[5].length;k++) if (EL.indexOf(PJ[5][k])==-1) EL.push(PJ[5][k]);
      }
    //delete Pneu[i][4];
    Pneu[i][5]=EL;
    }
  for (var i=0;i<Pneu.length;i++) { var p=Pneu[i]; //fast gleiche Ebenen zusammenfassen
    var p5neu=[];
    for (var j=0;j<p[5].length;j++) {
      if (p5neu.indexOf(E[p[5][j]][4])==-1) p5neu.push(E[p[5][j]][4]);
      }
    p[5]=p5neu;
    }  
  for (var i=0;i<Pneu.length;i++) { //die besten Ebenen für P[i][0..2] herauspicken
    Pneu[i][5]=Pneu[i][5].sort(Zsort); //vorerst die vor dem Schneiden soweit möglich 
    Pneu[i][0]=Pneu[i][5][0];
    Pneu[i][1]=Pneu[i][5][1];
    Pneu[i][2]=Pneu[i][5][2];
    }
  OBJ[2]=Pneu;
  }

var KANZflag=false;
var KANZ=function(OBJ) {//KASP fasst gleiche Kanten zusammen:
  var P=OBJ[2];
  var K=OBJ[3];
  if (KANZflag) alert("P="+P.join("\n"));
  if (KANZflag) alert("K="+K.join("\n"));
  var Q=[];
  for (var i=0;i<K.length;i++) {
    var imin=i;
    K[imin][6]=[];
    if (K[i][7]) ; else K[i][7]=[K[i][2],K[i][3]];
    for (var j=i;j>=0;j--) if (K[j][0]==K[i][0]&&K[j][1]==K[i][1]||K[j][0]==K[i][1]&&K[j][1]==K[i][0]) imin=j;
    K[imin][6].push(i);
    if (K[imin][7].indexOf(K[i][2])==-1) K[imin][7].push(K[i][2]);
    if (K[imin][7].indexOf(K[i][3])==-1) K[imin][7].push(K[i][3]);
    }
  var KNEU=[];
  for (var i=0;i<K.length;i++) if (K[i][6].length>0&&K[i][0]!=K[i][1]) KNEU.push(K[i].slice());
  OBJ[3]=KNEU;
  for (var i=0;i<OBJ[3].length;i++) {
    delete OBJ[3][i][6];
    OBJ[3][i][7]=OBJ[3][i][7].slice();
    }
  }

/* nur aufheben:
//KRED reduziert die Anzahl der Ebenen:
var KRED=function(OBJ) {
  //if (Logflag==true) alert("Hier geht KRED los");
  if (Logflag==true) Logtext=Logtext+"\n\n\nKRED:\n"+OBJ[3].join("\n");
  var verwendet=[];
  var KANTEN=OBJ[3];
  for (var i=0;i<OBJ[2].length;i++) {
    var x=OBJ[2][i];
    //die von P ausgehenden Kanten bestimmen
    var P=OBJ[2][i];
    var KK=[]
    for (var j=0;j<KANTEN.length;j++) if (KANTEN[j][0]==i||KANTEN[j][1]==i) KK.push(j);
    var KKK=[];      
    for (var j=0;j<KK.length;j++) KKK=KKK.concat(KANTEN[KK[j]][7]);
    for (var j=0;j<KKK.length;j++) if (KKK.indexOf(KKK[j],j+1)>-1) verwendet[KKK[j]]=1;
    }
  var T1neu=OBJ[1].slice();
  var sum=0;
  var vsum=0;
  while (sum<OBJ[0].length) {
    while(T1neu[vsum]!=1) vsum=vsum+1;
    if (verwendet[sum]) ; else T1neu[vsum]=0;
    vsum=vsum+1;
    sum=sum+1;
    }
  var Stapel=[];
  var T2neu=[];
  for (var i=0;i<T1neu.length;i++) {
    if (T1neu[i]==0) Stapel.push(0);
    if (T1neu[i]==1) {Stapel.push(1);T2neu.push(1)}
    if (T1neu[i]==3) if (Stapel.pop()==1) {Stapel.push(1);T2neu.push(3)} else Stapel.push(0);
    if (T1neu[i]==2) if (Stapel.pop()==1) if (Stapel.pop()==1) {Stapel.push(1);T2neu.push(2)} else Stapel.push(1);
    }
  OBJ[1]=T2neu;
  var sum=0;
  for (var i=0;i<OBJ[0].length;i++) if (verwendet[i]) {
    OBJ[0][sum]=OBJ[0][i];
    verwendet[i]=sum; 
    sum=sum+1;
    }
  OBJ[0]=OBJ[0].slice(0,sum);
  for (var i=0;i<OBJ[2].length;i++) {
    var x=OBJ[2][i];
//kann raus dann:
    if (verwendet[x[0]]) x[0]=verwendet[x[0]];
    if (verwendet[x[1]]) x[1]=verwendet[x[1]];
    if (verwendet[x[2]]) x[2]=verwendet[x[2]];
    if (x[5]) ; else alert("kein x[5]");
    var xneu=[];
    for (var j=0;j<x[5].length;j++) if (verwendet[x[5][j]]>-1) xneu.push(verwendet[x[5][j]]);
    x[5]=xneu.slice();
    x[0]=x[5][0];
    x[1]=x[5][1];
    x[2]=x[5][2];
    }
  for (var i=0;i<OBJ[3].length;i++) {
    var x=OBJ[3][i];
    if (x[7]) ; else alert("kein x[7]");
    var xneu=[];
    for (var j=0;j<x[7].length;j++) if (verwendet[x[7][j]]>-1) xneu.push(verwendet[x[7][j]]);
    x[7]=xneu;
    x[2]=x[7][0];
    x[3]=x[7][1];
    for (var j=0;j<3;j++) {
      if (x[7].indexOf(OBJ[2][x[0]][j])==-1) x[4]=OBJ[2][x[0]][j];
      if (x[7].indexOf(OBJ[2][x[1]][j])==-1) x[5]=OBJ[2][x[1]][j];
      }
    }
  }
*/

/* auch aufheben:
var KENT=function(OBJ) { //Entgraten
  var E=OBJ[0];
  var P=OBJ[2];
  var K=OBJ[3]; 
  var G=[]; //Gratpunkte
  for (var i=0;i<P.length;i++) { //alle Punkte
    var D=[]; //Durchschnittsmenge
    for (var k=0;k<E.length;k++) D.push(k);
    for (var j=0;j<K.length;j++) { //alle Kanten
      if (K[j][0]==i||K[j][1]==i) { //wenn K[j] von P[i] ausgeht
        var Dneu=[]; //neuer Durchschnitt
        for (var k=0;k<K[j][7].length;k++) if (D.indexOf(K[j][7][k])>-1) Dneu.push(K[j][7][k]);
        D=Dneu;
//  if (Logflag==true) alert("Dneu=["+Dneu+"]\n");
        }
      }
    if (Dneu.length>0) G.push(i);
    }
  //if (Logflag==true) alert("Entgraten:\nGratpunkte=["+G+"]\n");
  //jetzt die Gratpunkte entfernen
  var PNEU=[];
  for (var i=0;i<P.length;i++) if (G.indexOf(i)==-1) PNEU.push(P[i].slice());
  OBJ[2]=PNEU;
  //und Kanten neu bestimmen
  //OBJ[3]=[];
  if (Logflag) Logtext=Logtext+"zweites KFILL beendet mit "+DURCHGUCKER(OBJ,[107.5,100,50,1])+"\n";
  }
*/

var MADD=function(p1,p2) {return [p1[0]+p2[0],p1[1]+p2[1],p1[2]+p2[2],1]}

var MSCAL=function(s,v) { //Produkt Skalar mit Vektor
  return [s*v[0],s*v[1],s*v[2],1];
  }

var PDOT=function(a,b) { //Dotprodukt
  return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
  }

var sign=1;
var KREUZ=function(a,b) { //Kreuzprodukt
  return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0],1];
  }
//    p3=[16,18,23,[193.0224597294723,101.13086532308243,1552.2459729472316,1],[5,25],[16,18,23]]
//    p17=[9,14,16,[193.01715769148177,101.12927041360496,1551.7157691481762,1],[21],[9,14,16]]
//    p18=[12,14,16,[193.62132746752474,101.12927041360491,1612.1327467524716,1],[22],[12,14,16]]
//    p21=[21,23,25,[193.6262250321179,101.13086532308239,1612.6225032117907,1],[26],[21,23,16]]
//    k9=[3,21,16,23,18,21,null,[16,23]]
//    k32=[17,18,14,16,9,12,null,[14,16]]

//alert(Math.atan2(0,0.1));//0
//alert(Math.atan2(0,-0.1));//pi
//alert(Math.atan2(Math.sin(0.123),Math.cos(0.123)));//0.123

var KRWG=function(OBJ) { //Kanten mit nur 1 bestimmende Ebene entfernen
  var E=OBJ[0];
  var P=OBJ[2];
  var K=OBJ[3];
  var W=[]; //zu entfernende Kanten
  var eps=0.001;
  var eps2=0.00001;
  var KNEU=[];
  for (var i=0;i<K.length;i++) {
    var p1=P[K[i][0]][3];
    var p2=P[K[i][1]][3];
    var M=[(p1[0]+p2[0])/2,(p1[1]+p2[1])/2,(p1[2]+p2[2])/2]; //Kantenmittelpunkt
    var d=dist(p1,p2);
    var V=[(p2[0]-p1[0])/d*eps,(p2[1]-p1[1])/d*eps,(p2[2]-p1[2])/d*eps]; //Kantentangente*eps
    if (Logflag) Logtext=Logtext+"KRWG "+i+" d="+d+" ["+K[i][7]+"] V="+V+"\n";

    var eneu=[]; //verwendete Ebenen
    //if (K[i][7].length>2) alert(K[i][7]);
    var EL=[];//zu sortierende Liste der Richtungsvektoren
    for (var j=0;j<K[i][7].length;j++) EL.push([0,KREUZ(V,E[K[i][7][j]]),-1,-1,K[i][7][j]]);
    if (Logflag) {Logtext=Logtext+"  EL0=\n"; for (let j=0;j<EL.length;j++) Logtext=Logtext+"    ["+EL[j][0]+',['+EL[j][1]+'],'+EL[j].slice(2)+']\n'}
    for (var j=0;j<K[i][7].length;j++) EL.push([-EL[j][0],MSCAL(-1,EL[j][1].slice()),-1,-1,EL[j][4]]);//oder ohne slice
    if (Logflag) {Logtext=Logtext+"  EL1=\n"; for (let j=0;j<EL.length;j++) Logtext=Logtext+"    ["+EL[j][0]+',['+EL[j][1]+'],'+EL[j].slice(2)+']\n'}
    for (var j=0;j<EL.length;j++) {
      var KR=KREUZ(EL[0][1],EL[j][1]);//♦
      let sign=1;
      if (PDOT(KR,V)<0) sign=-1;//♦oder bei >0, noch herausfinden
      EL[j][0]=Math.atan2(dist(KR,[0,0,0])*sign,PDOT(EL[0][1],EL[j][1]))*180/Math.PI;
      EL[j][6]='♦';
      EL[j][7]=PDOT(KR,V);
      EL[j][8]=dist(KR,[0,0,0])*sign;
      EL[j][9]=PDOT(EL[0][1],EL[j][1]);
      EL[j][10]=KR;
      }
//    if (Logflag) {Logtext=Logtext+"  EL2=\n"; for (let j=0;j<EL.length;j++) Logtext=Logtext+"    ["+EL[j][0]+',['+EL[j][1]+'],'+EL[j].slice(2)+']; KR='+EL[j][10]+'\n'}
    if (Logflag) {Logtext=Logtext+"  EL2=\n"; for (let j=0;j<EL.length;j++) Logtext=Logtext+"    "+JSON.stringify(EL[j])+'\n'}
    EL.sort(Asort).reverse();
    EL.push(EL[0]);
    for (var j=0;j<EL.length-1;j++) {
      var DG=DURCHGUCKER(OBJ,MADD(M,MSCAL(0.5,MADD(EL[j][1],EL[j+1][1]))));
      EL[j][2]=DG;
      EL[j+1][3]=DG;
      }
    //if (K[i][7].length>2) alert(EL.join("\n"));
    if (Logflag) {Logtext=Logtext+"  EL=\n"; for (let j=0;j<EL.length;j++) Logtext=Logtext+"    ["+EL[j][0]+',['+EL[j][1]+'],'+EL[j].slice(2)+']\n'}
    for (var j=0;j<EL.length-1;j++) if (EL[j][2]!=EL[j][3]&&eneu.indexOf(EL[j][4])==-1) eneu.push(EL[j][4]);
    if (Logflag) Logtext=Logtext+"  eneu=["+eneu+"]\n";
    //if (K[i][7].length>2) alert("eneu=["+eneu+"]");
/*
    var eneu=[]; //verwendete Ebenen
    for (var j=0;j<K[i][7].length;j++) {
      var ekij=E[K[i][7][j]];
      if (
        (DURCHGUCKER(OBJ,MADD(MSCAL(+eps2,ekij),MADD(M,KREUZ(V,ekij))))!=
         DURCHGUCKER(OBJ,MADD(MSCAL(-eps2,ekij),MADD(M,KREUZ(V,ekij)))))||
        (DURCHGUCKER(OBJ,MADD(MSCAL(+eps2,ekij),MADD(M,KREUZ(ekij,V))))!=
         DURCHGUCKER(OBJ,MADD(MSCAL(-eps2,ekij),MADD(M,KREUZ(ekij,V)))))) eneu.push(K[i][7][j]);
      if (Logflag) Logtext=Logtext+"  E"+K[i][7][j]+" VxE=["+KREUZ(V,ekij)+"] "+eneu.length
        +" "+DURCHGUCKER(OBJ,MADD(MSCAL(+eps2,ekij),MADD(M,KREUZ(V,ekij))))
        +" "+DURCHGUCKER(OBJ,MADD(MSCAL(-eps2,ekij),MADD(M,KREUZ(V,ekij))))
        +" "+DURCHGUCKER(OBJ,MADD(MSCAL(+eps2,ekij),MADD(M,KREUZ(ekij,V))))
        +" "+DURCHGUCKER(OBJ,MADD(MSCAL(-eps2,ekij),MADD(M,KREUZ(ekij,V))))
        +"\n";
      }
*/
    //K[i][7]=eneu;//rausgenommen bei der Fehlersuche Button NUT_UND_FEDER_defekt
    if (eneu.length>1) KNEU.push(K[i]);
    }
  OBJ[3]=KNEU;K=KNEU;
  for (var i=0;i<E.length;i++) E[i][5]=0;
  for (var i=0;i<K.length;i++) for (var j=0;j<K[i][7].length;j++) E[K[i][7][j]][5]=E[K[i][7][j]][5]+1;
  }

var KPWG=function(OBJ) { //Punkte mit nur 2 oder 1 oder 0 Kanten entfernen
  var Punktliste=[];
  var Kantenliste=[];
  for (var iP in OBJ[2]) { var P=OBJ[2][iP];
    var Kantenliste=[];
    for (var iK in OBJ[3]) { var K=OBJ[3][iK];
      if (K[0]==iP) Kantenliste.push([iK,0]);
      if (K[1]==iP) Kantenliste.push([iK,1]);
      }
    if (Kantenliste.length==2) {
      Punktliste.push(iP);
      OBJ[3][Kantenliste[0][0]][Kantenliste[0][1]]=OBJ[3][Kantenliste[1][0]][1-Kantenliste[1][1]];
      OBJ[3].splice([Kantenliste[1][0]],1);
      //alert(iP);
      }
    if (Kantenliste.length==1) {
      Punktliste.push(iP);
      //alert("war noch nie dagewesen: nur eine Kante zu P"+iP);
      OBJ[3].splice([Kantenliste[0][0]],1);
      }
    if (Kantenliste.length==0) {
      Punktliste.push(iP);
      }
    }
  if (Punktliste.length>0) {//alert(Punktliste);
    var neue_Punktliste=[];
    var neue_Punktnummern=[];
    for (var iP in OBJ[2]) if (Punktliste.indexOf(iP)==-1) {
      neue_Punktnummern[iP]=neue_Punktliste.length;
      neue_Punktliste.push(OBJ[2][iP]);
      }
    //alert(neue_Punktnummern);
    OBJ[2]=neue_Punktliste;
    //alert(neue_Punktliste.join("\n"));
    for (var iK in OBJ[3]) { var K=OBJ[3][iK];
      K[0]=neue_Punktnummern[K[0]];
      K[1]=neue_Punktnummern[K[1]];
      }
    //alert(OBJ[3].join("\n"));
    }
  for (var i in OBJ[0]) OBJ[0][i][5]=0;
  for (var i in OBJ[3]) for (var j in OBJ[3][i][7]) OBJ[0][OBJ[3][i][7][j]][5]+=1;
  }

//11 so, jetzt nur noch RUMPS:
var RUMPS=function(OBJ1,OBJ2,BIT) { //Schnittkoerper (OBJ1 and OBJ2)
  //local TRU,ERG,P,PNEU;
  if (Logflag) Logtext=Logtext+"OBJ1=\n";
  if (Logflag) KDUMP(OBJ1);
  if (Logflag) Logtext=Logtext+"OBJ2=\n";
  if (Logflag) KDUMP(OBJ2);
  
  //if (Logflag) Logtext=Logtext+"OBJ2="+JSON.stringify(OBJ2)+"\n";
  var TRU=OBJ1[0].length;
  var ERG=[];
  ERG[0]=OBJ1[0].slice().concat(OBJ2[0]); for (var i=0;i<ERG[0].length;i++) ERG[0][i]=ERG[0][i].slice();
  ERG[1]=OBJ1[1].slice().concat(OBJ2[1]);
  if (BIT) ERG[1].push(TNOT);
  ERG[1].push(TAND);  
  ERG[2]=SCHNITTPUNKTE(OBJ1,OBJ2);
  //if (Logflag) alert(8);
  //for (var P of OBJ1[2]) {
  for (var iP in OBJ1[2]) { var P=OBJ1[2][iP];
    if (Logflag) Logtext=Logtext+"OBJ1 P="+JSON.stringify(P)+" drin="+DURCHGUCKER(ERG,P[3])+"\n";
    if (DURCHGUCKER(ERG,P[3])!=3) ERG[2].push(P.slice());
    }
  //for (var P of OBJ2[2]) {
  for (var iP in OBJ2[2]) { var P=OBJ2[2][iP];
    //if (iP==0) alert(P.join('\n')+'\n\n'+TRU);
    var PNEU=P.slice();
    if (PNEU[5]) ; else PNEU[5]=[PNEU[0],PNEU[1],PNEU[2]];
    PNEU[5]=PNEU[5].slice();
    PNEU[0]=PNEU[0]+TRU;
    PNEU[1]=PNEU[1]+TRU;
    PNEU[2]=PNEU[2]+TRU;
    if (PNEU[6]) {PNEU[6]=PNEU[6].slice(); for (let i=0;i<PNEU[6].length;i++) PNEU[6][i]=PNEU[6][i]+TRU;}//♥
    for (var i=0;i<PNEU[5].length;i++) PNEU[5][i]=PNEU[5][i]+TRU;
    //if (iP==0) alert(PNEU.join('\n')+'\nX\n'+TRU);
    if (Logflag) Logtext=Logtext+"OBJ2 P="+JSON.stringify(P)+" drin="+DURCHGUCKER(ERG,P[3])+" als PNEU="+JSON.stringify(PNEU)+"\n";
    if (DURCHGUCKER(ERG,P[3])!=3) ERG[2].push(PNEU);
    }
  //if (Logflag) alert(9);
  if (Logflag) Logtext=Logtext+"Punkte="+JSON.stringify(ERG[2])+"\n";
  if (Logflag) for (var i=0;i<ERG[2].length;i++) Logtext=Logtext+"P"+i+"="+JSON.stringify(ERG[2][i])+"\n";

  KEBN(ERG); //gleiche Ebenen bestimmen
  KASP(ERG); //gleiche Punkte zusammenfassen
  KFILL(ERG);
  KANZ(ERG); //gleiche Kanten zusammenfassen
  if (Logflag) Logtext=Logtext+"nach KANZ(ERG):\n";
  if (Logflag) KDUMP(ERG);
//  KENT(ERG); //Entgraten
//  KFILL(ERG);
//  KANZ(ERG);
  KRWG(ERG); //Kanten mit nur 1 bestimmende Ebene entfernen
  if (Logflag) Logtext=Logtext+"nach KRWG(ERG):\n";
  if (Logflag) KDUMP(ERG);
  KPWG(ERG); //Punkte mit nur 2 Kanten entfernen
  if (Logflag) Logtext=Logtext+"nach KPWG(ERG):\n";
  if (Logflag) KDUMP(ERG);
  if (Logflag) Logtext=Logtext+"nach return RUMPS(OBJ1,OBJ2,bit):\n";
  return ERG;
  }

var REST1=RUMPS(BALKEN1,SCHNITT2,0);
if (Logflag) Logtext=Logtext+"RUMPS(BALKEN1,SCHNITT2,0)="+JSON.stringify(REST1)+"\n";
//var REST2=RUMPS(BALKEN1,SCHNITT2,1);
//Logtext=Logtext+"RUMPS(BALKEN1,SCHNITT2,1)="+JSON.stringify(REST2)+"\n";
//var REST3=RUMPS(BALKEN1,SCHNITT3,0);
//Logtext=Logtext+"RUMPS(BALKEN1,SCHNITT3,0)="+JSON.stringify(REST3)+"\n";


//12
var MMULT=function(A,T) {
  var RET=[];
  var s=0;
  for (var i=0;i<A.length;i++) {
    RET[i]=[];
    for (var j=0;j<T.length;j++) {
      s=0;
      for (var k=0;k<4/*A[0].length*/;k++) {//vorübergehend nur k=0,2,3 wegen KEBN()
        s=s+A[i][k]*T[k][j];
        }
      RET[i][j]=s;
      }
    }
  return RET;
  }

if (Logflag) Logtext=Logtext+"MMULT(A,T)=[[8,11],[13,18]]: "+JSON.stringify(MMULT([[1,2],[2,3]],[[2,3],[3,4]]))+"\n";


var TRANSFORM=function(OBJ,A) {
  var neu=MMULT(OBJ[0],A);
  for (var i in OBJ[0]) {
    if (OBJ[0][i][4]>=0) neu[i][4]=OBJ[0][i][4];
    if (OBJ[0][i][5]>=0) neu[i][5]=OBJ[0][i][5];
    }
  OBJ[0]=neu;
  //for (var P of OBJ[2]) {
  for (var iP in OBJ[2]) { var P=OBJ[2][iP];
    //if (Logflag) Logtext=Logtext+"TRANSFORM i="+iP+"\n"+OBJ[0][P[0]]+"\n"+OBJ[0][P[1]]+"\n"+OBJ[0][P[2]]+"\n";
    P[3]=PGGT(DREIEBENEN(OBJ[0][P[0]],OBJ[0][P[1]],OBJ[0][P[2]]));
    //if (Logflag) Logtext=Logtext+iP+" "+P[3]+"\n";
    //if (P[3][3]<0) P[3]=[-P[4]; fi; //ist jetzt PGGT
    }
  //QFILL(OBJ);
  //KFILL(OBJ);
  return OBJ;
  }

var A=[[1,0,0,-5],[0,1,0,0],[0,0,1,0],[0,0,0,1]];
var B=[[1,0,0,5],[0,1,0,0],[0,0,1,0],[0,0,0,1]];

TRANSFORM(REST1,A);

//TRANSFORM(REST1,B);
var ALPHA=0.1;
let CDF=[[Math.cos(ALPHA),Math.sin(ALPHA),0,0],[-Math.sin(ALPHA),Math.cos(ALPHA),0,0],[0,0,1,0],[0,0,0,1]];
let FDC=[[Math.cos(ALPHA),-Math.sin(ALPHA),0,0],[Math.sin(ALPHA),Math.cos(ALPHA),0,0],[0,0,1,0],[0,0,0,1]];
//TRANSFORM(REST1,CDF);
//TRANSFORM(BALKEN1,CDF);
//TRANSFORM(BALKEN1,CDF);
//TRANSFORM(BALKEN1,FDC);


//13
var PUNKT2D=function(x) {
  return [x[0]+x[1]/2,x[2]+x[1]/2]; 
  }

var KPLOTtext="";
var KPLOT=function(KLISTE) {
  //for (var K of KLISTE) {
  KPLOTtext="";
  var xmin=Infinity;
  var xmax=-Infinity;
  var ymin=Infinity;
  var ymax=-Infinity;
  for (var iK in KLISTE) { var K=KLISTE[iK];
    //for (var KANTE of K[3]) {
    for (var iKANTE in K[3]) { var KANTE=K[3][iKANTE];
      var P1=PUNKT2D(K[2][KANTE[0]][3]);
      var P2=PUNKT2D(K[2][KANTE[1]][3]);
      xmin=Math.min(xmin,P1[0],P2[0]);
      xmax=Math.max(xmax,P1[0],P2[0]);
      ymin=Math.min(ymin,P1[1],P2[1]);
      ymax=Math.max(ymax,P1[1],P2[1]);
      //PD=P2-P1;
      //Logtext=Logtext+"KPLOT von "+JSON.stringify(P1)+" nach "+JSON.stringify(P2)+"\n";
      KPLOTtext=KPLOTtext+'<line x1="'+P1[0]+'" y1="'+P1[1]+'" x2="'+P2[0]+'" y2="'+P2[1]+'"/>\n';
      }
    }
  xmin=xmin-10; ymin=ymin-10; xmax=xmax+10; ymax=ymax+10;
  KPLOTtext='<svg width="100%" height="400" viewBox="'+xmin+" "+ymin+" "+(xmax-xmin)+" "+(ymax-ymin)+'" stroke="blue">\n'+KPLOTtext;
  KPLOTtext=KPLOTtext+'<path id="Eiderdaus" d="M-100,-100 L-40,-100 L-40,-40 Z" fill="orange" fill-rule="evenodd" stroke="none"/>'
    +'<circle id="svg_p" cx="-77" cy="-33" r="5" stroke="fuchsia" stroke-dasharray="0.5,1.5" stroke-width="4" fill="none">'
      +'<animate attributeName="stroke-dashoffset" from="0" to="4" dur="1" additive="sum" repeatCount="indefinite"/>'
      +'</circle>'
    +'<line id="svg_k" x1="-100" y1="-100" x2="-200" y2="-300" stroke="fuchsia" stroke-dasharray="0.5,1.5" stroke-width="4" fill="none">'
      +'<animate attributeName="stroke-dashoffset" from="0" to="4" dur="1" additive="sum" repeatCount="indefinite"/>'
      +'</line>'
    +'</svg>\n';
  }

if (Logflag) KPLOT([REST1]);
var REST2=RUMPS(REST1,SCHNITT2,0);
if (Logflag) KPLOT([REST2]);

//var BALKEN1=QUADER(200,100,150);
var BALKEN2=QUADER(60,60,60); KFILL(BALKEN2);
var C=[[1,0,0,10],[0,1,0,10],[0,0,1,10],[0,0,0,1]];
TRANSFORM(BALKEN2,C);
var REST3=RUMPS(BALKEN1,BALKEN2,1);
if (Logflag) KPLOT([REST3]);
var REST4=RUMPS(REST2,BALKEN2,1);
if (Logflag) KPLOT([REST4]);


//var REST4=RUMPS2(REST2,BALKEN1,0,1);
//KPLOT([REST4]);

/*
REST1:=RUMPS(BALKEN1,SCHNITT2,0);
C:=[[1,0,0,-30],[0,1,0,10],[0,0,1,-10],[0,0,0,1]];
TRANSFORM(REST1,C);
KPLOT([REST1]);
REST4:=RUMPS(BALKEN1,REST1,1);
KPLOT([REST4]);

BALKEN2:=StructuralCopy(BALKEN1);
C:=[[1,0,0,-5],[0,1,0,-5],[0,0,1,-5],[0,0,0,1]];
TRANSFORM(BALKEN2,C);
REST5:=RUMPS(BALKEN1,BALKEN2,1);
KPLOT([REST5]);

TRANSFORM(REST4,C);
TRANSFORM(REST4,CDF);
KPLOT([REST4]);

TRANSFORM(BALKEN1,CDF);
KPLOT([BALKEN1]);

ALPHA:=1;
CCDF:=function(ALPHA)
  local RP,IP,Z;
  Z:=E(DenominatorRat(ALPHA))^NumeratorRat(ALPHA);
  RP:=RealPart(Z);
  IP:=ImaginaryPart(Z);
  return [[RP,-IP,0,0],[IP,RP,0,0],[0,0,1,0],[0,0,0,1]];
  end;

TRANSFORM(REST4,CCDF(1/55));
KPLOT([REST4]);
TRANSFORM(REST4,CCDF(-1/55));
KPLOT([REST4]);
TRANSFORM(REST4,CCDF(1/555));
KPLOT([REST4]);
TRANSFORM(REST4,CCDF(-1/555));
KPLOT([REST4]);







#RA
GRENZ1:=QUADER(100,100,500);
SCHEUNE:=QUADER(8000,5500,6700);
DACHVORN:=EBENE([0,0,3500,1],[0,2250,6700,1],[8000,2250,6700,1]);
DACHHINTEN:=EBENE([8000,2250,6700,1],[0,2250,6700,1],[0,5500,3500,1]);
SCHEUNE:=RUMPS(SCHEUNE,DACHVORN,0);
SCHEUNE:=RUMPS(SCHEUNE,DACHHINTEN,0);
VERSCHIEB(SCHEUNE,3650,1070,-1500);
*/

Logtext=Logtext+"...KONSTRUK_javascript.js soweit geladen\n";








//--------------------♥ANF.js



let FFF = [1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2];
//alert(FFF);
//(1∧2∧3∧4∧5∧6)∧¬(7∧8)∧-(9∧10)∧-(11∧12)∧-(13∧14)∧-(15∧16)∧-(17∧18)∧-(19∧20)∧-(21∧22)
//(1∧2∧3∧4∧5∧6)∧(-7∨-8)∧(-9∨-10)∧(-11∨-12)∧(-13∨-14)∧(-15∨-16)∧(-17∨-18)∧(-19∨-20)∧(-21∨-22)
//((1∧2∧3∧4∧5∧6)∧(-7∨-8)∧(-9∨-10)∧(-11∨-12)∧(-13∨-14)∧(-15∨-16)∧(-17∨-18)∧(-19∨-20)∧-21)∨
//  ((1∧2∧3∧4∧5∧6)∧(-7∨-8)∧(-9∨-10)∧(-11∨-12)∧(-13∨-14)∧(-15∨-16)∧(-17∨-18)∧(-19∨-20)∧-22)

//Beispiel8:
//T = [1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2, 1, 1, 2, 3, 2]


//ANF1=[[a*b*c]+[d*e*f]] und ANF2=[[g*h*k]+[p*q*r]]
//ANF1*ANF2=[[a*b*c*g*h*k]+[a*b~c*p*q*r]+[d*e*f*g*h*k]+[d*e*f*ü*q*r]]
//-ANF2=[-[g*h*k]*-[p*q*r]]=[[-g+-h+-k]*[-p+-q+-r]]
//     =[[-g*-p]+[-g*-q]+[-g*-r]+[-h*-p]+[-h*-q]+[-h*-r]+[-k*-p]+[-k*-q]+[-k*-r]];

let and_tab=[[0,1,2,3],[1,1,2,2],[2,2,2,2],[3,2,2,3]];
let not_tab=[0,3,2,1];

function ANF_new(OBJ,i,r) {
	   
	 let RET=[];
	 for (let i=0;i<OBJ[0].length;i++) RET[i]=0;
	 RET[i]=r;
	 return [RET];
  }

function ANF_and(OBJ,ANF1,ANF2) {
	 let RET=[];
	 let R=[];
	 for (let i=0;i<ANF1.length;i++) for (let j=0;j<ANF2.length;j++) {
	 	 R=[];
	 	 for (let k=0;k<ANF1[i].length;k++) R[k]=and_tab[ANF1[i][k]][ANF2[j][k]];
	 	 RET.push(R)
  	 }
  return RET;
  }

function ANF_not(OBJ,ANF1) {
 	if (ANF1.length>1) alert('ERROR: ANF1.length>1 ist noch nicht drin');
	 let RET = [];
	 let R = [];
	 for (let i=0;i<ANF1.length;i++) {
	//  	for (let j = 0; j < ANF2.length; j++) {
	 		R = [];
	 		for (let k = 0;k<ANF1[i].length;k++) if(ANF1[i][k]>0) R.push(ANF_new(OBJ,k,not_tab[ANF1[i][k]])[0]);
		 	RET.push(R)
		  }
	 return R;
  }

function ANF(OBJ) {
  
	 let STAPEL=[];
	 let T=OBJ[1];
	 let enr=0;
	 let ANF1=[];
	 let ANF2=[];
	 for (let v=0;v<T.length;v++) {
	 	 
	 	 if (T[v]==1) {STAPEL.push(ANF_new(OBJ,enr,1));enr=enr+1}
	 	 if (T[v]==2) {
	 	 	 ANF2=STAPEL.pop();
	 	 	 ANF1=STAPEL.pop();
	 	 	 STAPEL.push(ANF_and(OBJ,ANF1,ANF2));
	 	 	 }
	 	 if (T[v]==3) {
	 	 	 ANF1=STAPEL.pop();
	 	 	 STAPEL.push(ANF_not(OBJ,ANF1));
	 	 	 }
    //console.log(JSON.stringify(STAPEL));
	   }

  OBJ.ANF=STAPEL[0];
  }

function alle_Punkte(OBJ) {
	 let PL=[];
	 let CL=[];
	 let EL=OBJ[0];
	 let xyz=[];
	 let dr=0;
	 for (let i=0;i<EL.length;i++) 
	   for (let j=0;j<i;j++) 
	     for (let k=0;k<j;k++) {
	     	 dr=DREIEBENEN(EL[i], EL[j], EL[k]);
	       if (dr[3]==1&&DURCHGUCKER(OBJ,dr)<3) PL.push(dr);
	       }
	 for (let i=0;i<PL.length;i++) {
	   CL[i]=[];
  	 for (let j=0;j<EL.length;j++) CL[i].push(TFIND(OBJ,j,PL[i]));
	   }
  OBJ.PL=PL;
  OBJ.CL=CL;
  PL=[];
  CL=[];
  for (let i=0;i<OBJ.PL.length;i++) if (JSON.stringify(CL).indexOf(JSON.stringify(OBJ.CL[i]))==-1) {
  	 PL.push(OBJ.PL[i]);
  	 CL.push(OBJ.CL[i]);
    }
  OBJ.PL=PL;
  OBJ.CL=CL;
  }

function alle_konvexen_Teile(OBJ) {
	 let RET=[];
	 let RET0=[];
	 let flag=true;
	 let drin=0;
	 //alert(OBJ.ANF.join('\n'));
	 for (let c=0;c<OBJ.ANF.length;c++) {
	   RET[c]=[];
	   for (let i=0;i<OBJ.PL.length;i++) {
	   	 flag=true;
	   	 let anzahl2=0;
	   	 for (let j=0;j<OBJ.ANF[c].length;j++) {
	   	 	 drin=OBJ.CL[i][j];
	   	 	 if (drin!=OBJ.ANF[c][j]&&OBJ.ANF[c][j]>0&&drin!=2) flag=false;
	   	 	 if (drin==2&&OBJ.ANF[c][j]>0) anzahl2=anzahl2+1;
  	   	 }
  	   if (anzahl2<3) flag=false;
    	 //if (flag) alert('c='+c+'; i='+i+';\n'+OBJ.ANF[c]+'\n'+OBJ.CL[i]+'\n'+anzahl2+' '+flag);
	   	 
  	   if (flag) RET[c].push(i);
	     }
	   }
	 OBJ.konv=RET;
	 }





//---------------
function ANF_Test(OBJ) {
  ANF(OBJ);
  alle_Punkte(OBJ);
  //console.log(TFIND(OBJ_X,0,);
  alle_konvexen_Teile(OBJ);
  exportiere.innerHTML='//insgesamt '+OBJ.PL.length+' Punkte und '+OBJ.konv.length+' konvexe Teile:\nPL='+JSON.stringify(OBJ.PL.map(function(i){return i})).replace(/\],\[/g,'],\n  [')+';\ncpoints='+JSON.stringify(OBJ.konv).replace(/\],\[/g,'],\n  [')+";\n";
  selectText("exportiere");
  console.error('kein Fehler alles gut: '+JSON.stringify(OBJ.PL.slice(0,2))+'#'+JSON.stringify(OBJ.konv.slice(0,2)));
  }






//--------------------♥MIT_KONSTR8K_FF.html








import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';











//globale Variablen
var renderer;
var scene;
var camera;
//var raycaster = new THREE.Raycaster(); //aus three.js.pdf
var mouse = { x : 0, y : 0 }; 
var Castlist=[];
var q; //PUNKT_Q;
var PA,PS,PD;
var VAS;
var EASD;
var canvas_height=0;
var canvas_width=0;
var zoom=20;
var Linientyp=0;
var cube;
var REST5;
var cmin=0;
var OBJ_X=cmin;
var OBJ_Y=cmin;
var SCHNITTEBENE;
var SAMMELEBENE=[[],[],[],[]];
var Logtext2=[];
var LT=[];
var SCHNITTVEKTOR_AS=0;
var SCHNITTEBENE_ASD=0;
var MERKOBJEKT=[[],[],[],[]];
var History=[];
var QASDzoom=1;
var requestAnimationFrameID=0;
var ASdistanz=1;
var Verschiebedistanz=1;
let contr=0;
let OBJ_gefuellt=0;

function init() {
  zoom=20;
  Linientyp=0;
  PUNKT_A=[0,0,0,1];
  Castlist=[];
  cancelAnimationFrame(requestAnimationFrameID);

  // create a scene, that will hold all our elements such as objects, cameras and lights.
  scene = new THREE.Scene();
  canvas_width=0.85*window.innerWidth;  //document.getElementById("canvas").clientWidth;
  canvas_height=0.5*canvas_width; //window.innerHeight;//document.getElementById("canvas").clientHeight;
//  canvas_height=512;
//  canvas_width=1024;
  //alert(canvas_width+" "+canvas_height);

  // create a camera, which defines where we‘re looking at.
  //camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.001, 1000);
  camera = new THREE.PerspectiveCamera(45, canvas_width / canvas_height, 0.1, 100000);
  //alert(THREE.WebGLRenderer); //geht nicht bei MINT

  // create a render, sets the background color and the size
  renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(0xCCCC00, 1.0);
  renderer.setSize(canvas_width, canvas_height);
  renderer.domElement.addEventListener( 'click', raycast, false );
  renderer.domElement.addEventListener( 'mousemove', function() {if (event.shiftKey) raycast()}, false );

        // add light
        var light = new THREE.DirectionalLight();
        light.position.set(1200, 1200, 1200);
        scene.add(light);

  OBJ_gefuellt=new THREE.Group();
  scene.add(OBJ_gefuellt);
  
// create a cube and add to scene
  var cubeGeometry = new THREE.BoxGeometry(0.1/QASDzoom /* 10 * Math.random()*/, 0.1/QASDzoom, 0.1/QASDzoom);
//alert(JSON.stringify(cubeGeometry.faces));
  var cubeMaterial = new THREE.MeshNormalMaterial();
  cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  cube.name = 'cube';
  cube.position.x=0;
  scene.add(cube);

  //Pointer Q
  //var qGeometry = new THREE.SphereGeometry( 0.14, 32, 32 );
  var qGeometry = new THREE.BoxGeometry(0.17/QASDzoom, 0.17/QASDzoom, 0.17/QASDzoom);
  var qMaterial = new THREE.MeshBasicMaterial( { color: 0xFFFF00, opacity:0.5, transparent:true } );
  q = new THREE.Mesh( qGeometry, qMaterial );
  //q.position.x=205/zoom;
  //q.position.z=150/zoom;
  scene.add( q );
  //Knoten.push(q.position.clone());

  var AGeometry = new THREE.SphereGeometry( 0.09/QASDzoom, 32, 32 );
  var AMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity:0.5, transparent:true } );
  PA = new THREE.Mesh( AGeometry, AMaterial );
  PA.position.x=20/zoom;
  PA.position.z=0/zoom;
  scene.add( PA );
  
  var SGeometry = new THREE.SphereGeometry( 0.095/QASDzoom, 32, 32 );
  var SMaterial = new THREE.MeshBasicMaterial( { color: 0x0000FF, opacity:0.5, transparent:true } );
  PS = new THREE.Mesh( SGeometry, SMaterial );
  PS.position.x=10/zoom;
  PS.position.y=30/zoom;
  PS.position.z=10/zoom;
  scene.add( PS );

  var DGeometry = new THREE.SphereGeometry( 0.1/QASDzoom, 32, 32 );
  var DMaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, opacity:0.5, transparent:true } );
  PD = new THREE.Mesh( DGeometry, DMaterial );
  PD.position.x=0/zoom;
  PD.position.z=40/zoom;
  scene.add( PD );

  var VASmaterial = new THREE.LineBasicMaterial({ color: 0x778899, linewidth:1});
  //var VASgeometry = new THREE.BufferGeometry();
  //VASgeometry.vertices = [PA.position,PS.position];
  let VASgeometry = new THREE.BufferGeometry().setFromPoints( [PA.position,PS.position] );
  VAS = new THREE.Line(VASgeometry, VASmaterial);
  scene.add( VAS );

  var EASDmaterial = new THREE.LineBasicMaterial({ color: 0x996633, linewidth:1});
  //var EASDgeometry = new THREE.BufferGeometry();
  //EASDgeometry.vertices = [PA.position,PD.position];
  let EASDgeometry = new THREE.BufferGeometry().setFromPoints( [PA.position,PD.position] );
  EASD = new THREE.Line(EASDgeometry, EASDmaterial);
  scene.add( EASD );

  // position and point the camera to the center of the scene
  camera.position.x = 5; //15;
  camera.position.y = 5; //16;
  camera.position.z = -12; //13
  camera.lookAt(scene.position);

  // add the output of the renderer to the html element
  document.getElementById("canvas").replaceChild(renderer.domElement,document.getElementById("canvas").firstChild);

  contr = new OrbitControls( camera ,renderer.domElement);

  //scene.add(Testspline());//geht nicht mehr
  }



  
  

var DrehenASD=function(OBJ_X) {

  if (Logflag==true) Logtext=Logtext+"Verschieben zum Ursprung mit [dx,dy,dz]=["+[-PA.position.x*zoom,-PA.position.y*zoom,-PA.position.z*zoom]+"]\n";
  var RET=TRANSFORM(OBJ_X,[[1,0,0,PA.position.x*zoom],[0,1,0,PA.position.y*zoom],[0,0,1,PA.position.z*zoom],[0,0,0,1]]);

  var alpha=0; 
  if((PS.position.z-PA.position.z)**2+(PS.position.x-PA.position.x)**2>0.00001) {
    alpha=-Math.atan2(PS.position.x-PA.position.x,PS.position.z-PA.position.z);
    }
  if (Logflag==true) Logtext=Logtext+"Drehen um die y-Achse mit alpha="+(alpha*180/Math.PI)+"\n";
  var ca=Math.cos(alpha); 
  var sa=Math.sin(alpha); 
  RET=TRANSFORM(RET,[[ca,0,-sa,0],[0,1,0,0],[sa,0,ca,0],[0,0,0,1]]); 

  var beta=0;
  if(((PD.position.z-PA.position.z)**2+(PD.position.y-PA.position.y)**2>0.00001)/*&&((PS.position.z-PA.position.z)**2+(PS.position.y-PA.position.y)**2>0.00001)*/) {
    beta=-Math.atan2(Math.sqrt((PD.position.z-PA.position.z)**2+(PD.position.x-PA.position.x)**2),PD.position.y-PA.position.y);
    beta=beta+Math.atan2(Math.sqrt((PS.position.z-PA.position.z)**2+(PS.position.x-PA.position.x)**2),PS.position.y-PA.position.y);
    }
  if (Logflag==true) Logtext=Logtext+"Drehen um die x-Achse mit beta="+(-beta*180/Math.PI)+"\n";
  var cb=Math.cos(beta); 
  var sb=Math.sin(beta); 
  RET=TRANSFORM(RET,[[1,0,0,0],[0,cb,-sb,0],[0,sb,cb,0],[0,0,0,1]]);

  var gamma=0; 
  if((PD.position.z-PA.position.z)**2+(PD.position.x-PA.position.x)**2>0.00001) {
    gamma=Math.atan2(PD.position.x-PA.position.x,PD.position.z-PA.position.z);
    }
  if (Logflag==true) Logtext=Logtext+"Drehen um die y-Achse mit gamma="+(gamma*180/Math.PI)+"\n";
  var cc=Math.cos(gamma); 
  var sc=Math.sin(gamma); 
  RET=TRANSFORM(RET,[[cc,0,-sc,0],[0,1,0,0],[sc,0,cc,0],[0,0,0,1]]); 

  if (Logflag==true) Logtext=Logtext+"Verschieben zum Ausgangsort mit [dx,dy,dz]=["+[PA.position.x*zoom,PA.position.y*zoom,PA.position.z*zoom]+"]\n";
  RET=TRANSFORM(RET,[[1,0,0,-PA.position.x*zoom],[0,1,0,-PA.position.y*zoom],[0,0,1,-PA.position.z*zoom],[0,0,0,1]]); 

  return RET;
  }



var neuen_Balken_plazieren=function(x,y,z,l,b,h) {
  PUNKT_A=[x,y,z,1];
  var RET=QUADER(l,b,h);
  KFILL(RET);
  KDUMP(RET);
  KPLOT([RET]);
  AddObjekt(scene,RET);
  return RET;
  }



var Beispiel1=function() {
  QASDzoom=1;
  init();
  Linientyp=0; //Röhren
  Logtext2=[];
  OBJ_Y=0;
  History=[];

var BALKEN1=QUADER(200,100,150); KFILL(BALKEN1);
var SCHNITT2=EBENE([100,0,0,1],[200,50,150,1],[200,0,90,1]);
var REST1=RUMPS(BALKEN1,SCHNITT2,1);
TRANSFORM(REST1,A);
TRANSFORM(SCHNITT2,CDF);
var REST2=RUMPS(REST1,SCHNITT2,1);
var BALKEN2=QUADER(60,60,60); KFILL(BALKEN2);
var C=[[1,0,0,10],[0,1,0,10],[0,0,1,10],[0,0,0,1]];
TRANSFORM(BALKEN2,C);
var REST3=RUMPS(BALKEN1,BALKEN2,1);
var REST4=RUMPS(REST2,BALKEN2,1);
PUNKT_A=[-10,75,-10,1];
var BALKEN3=QUADER(100,15,100); KFILL(BALKEN3);
REST5=RUMPS(REST4,BALKEN3,1);
//REST5=BALKEN1;
Logtext=Logtext+"REST5="+JSON.stringify(REST5)+"\n";
Logtext=Logtext+"BALKEN3="+JSON.stringify(BALKEN3)+"\n";
KPLOT([REST1]);
KPLOT([REST4]);
KPLOT([REST5]);
Castlist.push(REST5);
//cube.geometry.faces[0].color = new THREE.Color(0x000000);
AddObjekt(scene,REST5);
TQ(20,0,0,0);
TA();
TQ(10,30,10,0);
TS();
TQ(0,0,40,0);
TD();
/*6*/ TQ(73.0598058481,54.6307707698,36.8107501871,0);
/*7*/ TA();
/*8*/ TQ(5,50,150,0);
/*9*/ TS();
/*10*/ TQ(50,0,25,0);
/*11*/ TD();
/*12*/ TMerken();
/*13*/ TQ(47.5,75,90,0);
/*14*/ TA();
/*15*/ TQ(45.9008335412,75,41.8945745584,0);
/*16*/ TS();
/*19*/ TQ(54.6589723069,37.0764868502,0,0);
/*18*/ TD();
/*19*/ TQ(54.6589723069,37.0764868502,0,0);
/*19*/ TSchneiden();

//Logtext=JSON.stringify(cube.geometry.faces)+"\n"+Logtext;

  Logfile();
  Logfile2();

  //var xm=new XMLSerializer();
  //alert(xm.serializeToString(renderer.domElement));
  //alert(renderer.domElement);
 
  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }




var Beispiel2=function() {
  QASDzoom=1;
  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  
  // position and point the camera to
  schaue_von_und_nach(-5,5,-12, 0.00,0.00,0.00);

/*
  PA.position.x=0/zoom;
  PA.position.y=0/zoom;
  PA.position.z=0/zoom;

  PS.position.x=0/zoom;
  PS.position.y=0/zoom;
  PS.position.z=1700/zoom;

  PD.position.x=130/zoom;
  PD.position.y=120/zoom;
  PD.position.z=1250/zoom;
*/

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//      " >P -250 0 0 Anlegepunkt" INTERPRET
//      " >Q 18 1700 180 rechtesBrett" INTERPRET
var rechtes_Brett=neuen_Balken_plazieren(-250,0,0,18,180,1700);

//      " >P -500 0 0 Anlegepunkt" INTERPRET
//      " >Q 30 700 180 HochzuBrett" INTERPRET
var Hochzubrett=neuen_Balken_plazieren(-500,0,0,30,180,700);

//      " >P -750 0 0 Anlegepunkt" INTERPRET
//      " >Q 20 2000 20 Bügel" INTERPRET
var Buegel=neuen_Balken_plazieren(-750,0,0,20,20,2000);




//Logflag=true;
//Testflag=true;
LT=[
"TQ(-232,0,0,2)",
"TA()",
"TQ(0,0,0,0)",
"TS()",
"TQ(-250,180,1700,2)",
"TKopieren()",
"TVerschieben()",
"TQ(-250,0,0,2)",
"TA()",
"TQ(355,0,0,0)",
"TS()",
"TQ(-232,180,1700,2)",
"TVerschieben()",
"TQ(0,0,0,0)",
"TA()",
"TQ(0,0,1700,5)",
"TS()",
"TQ(130,0,1250,1)",
"TD()",
"TQ(-18,180,1700,5)",
"TDrehen()",
"TQ(130,120,1250,1)",
"TS()",
"TQ(130,0,1250,1)",
"TD()",
"TQ(250,120,1620,1)",
"TSchneiden()",
"TQ(177.5,115,0,0)",
"TSchneiden()",
"TQ(355,0,0,0)",
"TA()",
"TQ(355,0,1700,2)",
"TS()",
"TQ(250,0,1250,1)",
"TD()",
"TQ(373,180,1700,2)",
"TDrehen()",
"TQ(250,0,1250,1)",
"TS()",
"TQ(250,120,1250,1)",
"TD()",
"TQ(190,120,1250,1)",
"TSchneiden()",
"TQ(183.48,0,115,0)",
"TSchneiden()",
"TQ(193.7,120,1620,1)",
"TA()",
"TQ(218.92,60,1620,1)",
"TS()",
"TQ(168.48000000000002,60,1620,1)",
"TD()",
"TQ(212.70114787936444,180,1694.0339538170856,2)",
"TSchneiden()",
"TQ(157.94811390479882,0,1692.7422701976568,5)",
"TSchneiden()",
"TQ(-500,90,0,3)",
"TA()",
"TQ(177.5,0,0,0)",
"TS()",
"TQ(-485,180,0,3)",
"TVerschieben()",
"TQ(177.5,0,0,0)",
"TA()",
"TQ(177.5,0,700,3)",
"TS()",
"TQ(177.5,90,0,3)",
"TD()",
"TQ(177.5,-90,0,3)",
"TDrehen()",
"TQ(177.5,5.5109105961630896e-15,-90,3)",
"TS()",
"TQ(0,0,0,0)",
"TD()",
"TQ(207.5,350,90.00000000000003,3)",
"TDrehen()",
"TQ(-750,0,0,4)",
"TA()",
"TQ(-750,20,0,4)",
"TA()",
"TQ(87.5,700,-29.999999999999986,3)",
"TS()",
"TQ(-730,0,1000,4)",
"TKopieren()",
"TVerschieben()",
"TQ(-730,20,0,4)",
"TA()",
"TQ(267.50000000000006,700,-30.000000000000018,3)",
"TS()",
"TQ(-730,0,1000,4)",
"TVerschieben()",
"TQ(87.5,700,-29.99999999999999,6)",
"TA()",
"TQ(87.5,700,1970,6)",
"TS()",
"TQ(168.48000000000002,120,1620,1)",
"TD()",
"TQ(87.5,700,1970,6)",
"TDrehen()",
"TQ(267.5000000000001,700,-30.000000000000014,4)",
"TA()",
"TQ(267.5000000000001,700,1970,4)",
"TS()",
"TQ(218.92,120,1620,1)",
"TD()",
"TQ(267.5000000000001,700,1970,4)",
"TDrehen()",
"TQ(190,120,1250,1)",
"TA()",
"TQ(193.7,120,1620,1)",
"TS()",
"TQ(218.92,120,1620,1)",
"TD()",
"TQ(179.84152492372203,28.027354163578536,1851.495630083249,6)",
"TSchneiden()",
"TQ(211.96875676696882,37.008623401441696,1856.0961575648632,4)",
"TSchneiden()",
"TQ(87.50000000000001,700.0000000000001,-29.999999999999943,6)",
"TA()",
"TQ(97.1632037211084,681.1292704136066,-37.10760569542027,6)",
"TS()",
"TVerschieben()",
"TQ(267.50000000000006,700,-30.000000000000018,3)",
"TA()",
"TQ(257.69944764911827,681.130865323084,-36.92133875504069,4)",
"TS()",
"TVerschieben()",
"TQ(267.50000000000006,700,-15.000000000000018,3)",
"TA()",
"TQ(87.50000000000004,700,-14.999999999999984,3)",
"TS()",
"TQ(87.5,5.5109105961630896e-15,-14.999999999999984,3)",
"TD()",
"TQ(106.82640744221679,662.2585408272132,-44.215211390840565,6)",
"TSchneiden()",
"TQ(247.89889529823643,662.261730646168,-43.84267751008141,4)",
"TSchneiden()",
"TQ(118.27229099826182,651.8166393945107,-14.999999999999993,6)",
"TA()",
"TQ(177.50000000000006,700,-4.733165431326071e-30,3)",
"TSchneiden()",//Löcher in die Rückwand
"TQ(237.04536360786378,652.0196427372484,-15.000000000000014,4)",
"TA();//Testflag=true",
"TQ(177.50000000000006,700,-4.733165431326071e-30,3)",
"TSchneiden()",//Löcher in die Rückwand
"TQ(190,0,1250,1)",
"TA()",
"TQ(190,120,1250,1)",
"TS()",
"TQ(193.7,0,1620,1)",
"TD()",
"TQ(233.0867389713242,387.27802396613663,799.0393306224815,4);Logflag=true",
"TSchneiden()",
"TQ(193.7,0,1620,1)",
"TS()",
"TQ(190,120,1250,1)",
"TD()",
"TQ(156.715966119015,376.4729549040578,768.305309326288,6)",
"TSchneiden()",
"TQ(193.7,0,1620,1)",
"TA()",
"TQ(138.19571096632518,387.24369123077435,798.9461971522918,6)",
"TA()",
"TQ(193.7,0,1620,1)",
"TSchneiden()",
"TQ(233.0867389713242,387.27802396613663,799.0393306224815,4)",
"TA()",
"TQ(193.7,0,1620,1)",
"TSchneiden()",

"TQ(900,0,0,0)",
"TNeu(160,210,2,'Schusterburg neues Dachfenster')",
"TQ(0,0,0,0)",
"TA()",
"TQ(0,115,0,0)",
"TS()",
"TQ(5.98,115,57.5,0)",
"TD()",
"TQ(900,0,2,7)",
"TDrehen()",
"TQ(-900,0,0,0)",
"TNeu(200,500,5,'neuer Putz')",
"TQ(-900,0,5,0)",
"TNeu(5,500,2000,'neuer Putz')",
  ];




  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel2");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }



var Beispiel3=function() {
  QASDzoom=1;
  init();
  zoom=20;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  Logflag=false;
  History=[];
  
  // position and point the camera to
  schaue_von_und_nach(-70,30,60, 0.00,0.00,0.00);

/*
  PA.position.x=0/zoom;
  PA.position.y=0/zoom;
  PA.position.z=0/zoom;

  PS.position.x=0/zoom;
  PS.position.y=0/zoom;
  PS.position.z=1700/zoom;

  PD.position.x=130/zoom;
  PD.position.y=120/zoom;
  PD.position.z=1250/zoom;
*/

var Dach=[[
  DREIPUNKTE([0,0,0,1],[2000,0,0,1],[250,750,250,1]),
  DREIPUNKTE([0,0,500,1],[250,750,250,1],[1000,0,500,1]),
  DREIPUNKTE([0,0,0,1],[250,750,250,1],[0,0,500,1]),
  DREIPUNKTE([0,0,0,1],[0,0,500,1],[2000,0,500,1]),
  DREIPUNKTE([2000,0,0,1],[2000,0,500,1],[1750,750,250,1]),
  ],
  [TEBN,TEBN,TAND,TEBN,TAND,TEBN,TAND,TEBN,TAND],
  [],[]];
  QFILL(Dach);
  KFILL(Dach);
  AddObjekt(scene,Dach);

var Balken=neuen_Balken_plazieren(0,0,50,2500,24,12);










LT=[
"/*0*/ TQ(0,0,500,0)",
"/*1*/ TA()",
"/*2*/ TQ(0,0,0,0)",
"/*3*/ TS()",
"/*4*/ TQ(0,0,500,0)",
"/*5*/ TVerschieben()",
"/*6*/ TQ(0,24,56,1)",
"/*7*/ TA()",
"/*8*/ TQ(0,0,0,0)",
"/*9*/ TS()",
"/*10*/ TQ(0,0,12,1)",
"/*11*/ TKopieren()",
"/*12*/ TVerschieben()",
"/*13*/ TQ(0,0,0,0)",
"/*14*/ TA()",
"/*15*/ TQ(2000,0,0,0)",
"/*16*/ TS()",
"/*17*/ TQ(250,750,-250,0)",
"/*18*/ TD()",
"/*19*/ TQ(0,0,0,2)",
"/*20*/ TDrehen()",
"/*21*/ TQ(0,0,-250,0)",
"/*22*/ TA()",
"/*23*/ TA()",
"/*24*/ TQ(2000,0,-250,0)",
"/*25*/ TS()",
"/*26*/ TQ(1750,750,-250,0)",
"/*27*/ TD()",
"/*28*/ TQ(758.0210021315,2261.3350843332,-749.5357207573,2)",
"/*29*/ TSchneiden()",
"/*30*/ TQ(0,24,56,1)",
"/*31*/ TKopieren()",
"/*32*/ TA()",
"/*33*/ TQ(0,0,-500,0)",
"/*34*/ TS()",
"/*35*/ TQ(0,24,62,1)",
"/*36*/ TVerschieben()",
"/*37*/ TQ(0,0,-500,0)",
"/*38*/ TA()",
"/*39*/ TQ(2500,0,-500,1)",
"/*40*/ TS()",
"/*41*/ TQ(2500,0,-494,1)",
"/*42*/ TA()",
"/*43*/ TQ(0,0,-500,0)",
"/*44*/ TA()",
"/*45*/ TQ(2500,0,-500,1)",
"/*46*/ TS()",
"/*47*/ TS()",
"/*48*/ TS()",
"/*49*/ TS()",
"/*50*/ TQ(250,750,-250,0)",
"/*51*/ TD()",
"/*52*/ TQ(2500,-24,-500,1)",
"/*53*/ TDrehen()",
"/*54*/ TQ(0,0,-250,0)",
"/*55*/ TA()",
"/*56*/ TA()",
"/*57*/ TA()",
"/*58*/ TQ(1750,750,-250,0)",
"/*59*/ TS()",
"/*60*/ TQ(2000,0,-250,0)",
"/*61*/ TD()",
"/*62*/ TQ(758.0210021315,2261.3350843332,249.5357207573,1)",
"/*63*/ TSchneiden()",
"/*64*/ TQ(0,24,56,3)",
"/*65*/ TA()",
"/*66*/ TQ(250,750,-250,2)",
"/*67*/ TS()",
"/*68*/ TQ(2500,24,62,3)",
"/*69*/ TKopieren()",
"/*70*/ TVerschieben()",
"/*71*/ TQ(250,750,-244,4)",
"/*72*/ TA()",
"/*73*/ TQ(250,726,-244,4)",
"/*74*/ TS()",
"/*75*/ TVerschieben()",
"/*76*/ TQ(250,726,-244,4)",
"/*77*/ TA()",
"/*78*/ TQ(250,714,-244,4)",
"/*79*/ TS()",
"/*80*/ TVerschieben()",
"/*81*/ TVerschieben()",
"/*82*/ TQ(1750,750,-250,0)",
"/*83*/ TA()",
"/*84*/ TQ(1000,750,-250,0)",
"/*85*/ TS()",
"/*86*/ TQ(2750,678,-244,4)",
"/*87*/ TSchneiden()",
"/*88*/ TQ(250,702,-244,4)",
"/*89*/ TA()",
"/*90*/ TQ(-4.2426406871,0,-4.7573593129,2)",
"/*91*/ TSchneiden()",
"/*92*/ TQ(-4.2426406871,0,-495.7573593129,1)",
"/*93*/ TSchneiden()",
"/*94*/ TQ(0,0,0,0)",
"/*95*/ TA()",
"/*96*/ TQ(1000,750,-250,0)",
"/*97*/ TS()",
"/*98*/ TQ(1875,375,-125,0)",
"/*99*/ TD()",
"/*100*/ TQ(11.1078108905,-10.2336343851,-19.5930922647,2)",
"/*101*/ TSchneiden()",
"/*102*/ TQ(0,0,-250,0)",
"/*103*/ TA()",
"/*104*/ TQ(250,750,-250,1)",
"/*105*/ TS()",
"/*106*/ TQ(0,0,0,0)",
"/*107*/ TD()",
"/*108*/ TQ(-4.2426406871,0,-4.2426406871,2);//Logflag=true",
"/*109*/ TSchneiden()",
"/*110*/ TQ(4.2426406871,0,-504.2426406871,1)",
"/*111*/ TSchneiden()",
"/*112*/ TQ(2000,0,-250,0)",
"/*113*/ TA()",
"/*114*/ TQ(2000,0,-500,0)",
"/*115*/ TS()",
"/*116*/ TQ(1000,0,-500,0)",
"/*117*/ TA()",
"/*118*/ TQ(2000,0,-500,0)",
"/*119*/ TS()",
"/*120*/ TQ(1875,375,-375,0)",
"/*121*/ TD()",
"/*122*/ TQ(19.5930922647,-10.2336343851,-488.8921891095,1)",
"/*123*/ TSchneiden()",
"/*124*/ TQ(0,0,-500,1)",
"/*125*/ TA()",
"/*126*/ TKopieren()",
"/*127*/ TQ(2000,0,0,0)",
"/*128*/ TS()",
"/*129*/ TQ(0,0,-500,1)",
"/*130*/ TVerschieben()",
"/*131*/ TQ(2000,0,0,1)",
"/*132*/ TA()",
"/*133*/ TQ(1000,0,0,0)",
"/*134*/ TS()",
"/*135*/ TQ(2000,0,-500,0)",
"/*136*/ TD()",
"/*137*/ TQ(2258.4852813742,750,250,1)",
"/*138*/ TDrehen()",
"/*139*/ TDrehen()",
"/*140*/ TQ(19.5930922647,-10.2336343851,-11.1078108905,2)",
"/*141*/ TKopieren()",
"/*142*/ TQ(0,0,0,0)",
"/*143*/ TA()",
"/*144*/ TQ(2000,0,-500,0)",
"/*145*/ TS()",
"/*146*/ TQ(11.1078108905,-10.2336343851,-19.5930922647,2);//Logflag=true;",
"/*147*/ TVerschieben()",
"/*148*/ TQ(2000,0,-500,2)",
"/*149*/ TA()",
"/*150*/ TQ(2000,0,-250,0)",
"/*151*/ TS()",
"/*152*/ TQ(1000,0,-500,0)",
"/*153*/ TD()",
"/*154*/ TQ(2258.4852813742,750,-750,2)",
"/*155*/ TDrehen()",
"/*156*/ TDrehen()",
"/*157*/ TQ(0,24,56,3)",
"/*158*/ TA()",
"/*159*/ TQ(1000,0,0,0)",
"/*160*/ TS()",
"/*161*/ TQ(0,24,56,3)",
"/*162*/ TKopieren()",
"/*163*/ TVerschieben()",
"/*164*/ TQ(1000,0,0,0)",
"/*165*/ TA()",
"/*166*/ TQ(2000,0,0,1)",
"/*167*/ TS()",
"/*168*/ TQ(1000,750,-250,0)",
"/*169*/ TD()",
"/*170*/ TQ(3500,-12,6,7)",
"/*171*/ TDrehen()",
"/*172*/ TQ(2000,0,-250,0)",
"/*173*/ TA()",
"/*174*/ TQ(1000,750,-250,0)",
"/*175*/ TS()",
"/*176*/ TQ(0,0,-250,0)",
"/*177*/ TD()",
"/*178*/ TQ(994,2371.7082451263,-790.5694150421,7)",
"/*179*/ TSchneiden()",
"/*180*/ TQ(1000,702,-256,4)",
"/*181*/ TA()",
"/*182*/ TQ(1006,375,-125,7)",
"/*183*/ TSchneiden()",
"/*184*/ TQ(1000,0,0,0)",
"/*185*/ TA()",
"/*186*/ TQ(1250,24,62,3)",
"/*187*/ TS()",
"/*188*/ TQ(1006,352.2316008468,-142.7087548969,7)",
"/*189*/ TS()",
"/*190*/ TQ(1006,352.2316008468,-142.7087548969,7)",
"/*191*/ TS()",
"/*192*/ TQ(1000,0,-500,0)",
"/*193*/ TS()",
"/*194*/ TQ(994,375,-125,7)",
"/*195*/ TKopieren()",
"/*196*/ TVerschieben()",
"/*197*/ TQ(1000,0,-500,0)",
"/*198*/ TA()",
"/*199*/ TQ(2000,0,-500,2)",
"/*200*/ TS()",
"/*201*/ TQ(1000,0,0,0)",
"/*202*/ TD()",
"/*203*/ TQ(1000,-7.5894663844,-522.7683991532,8)",
"/*204*/ TDrehen()",
"/*205*/ TDrehen()",
"/*206*/ TQ(0,0,56,3)",
"/*207*/ TA()",
"/*208*/ TQ(250,678,-250,4)",
"/*209*/ TS()",
"/*210*/ TQ(0,24,62,3)",
"/*211*/ TKopieren()",
"/*212*/ TVerschieben()",
"/*213*/ TQ(241.5147186258,680.9870888208,-250,5)",
"/*214*/ TA()",
"/*215*/ TQ(126.3112647581,335.3767272178,-134.7965461324,6)",
"/*216*/ TS()",
"/*217*/ TQ(2750,702,-244,9)",
"/*218*/ TKopieren()",
"/*219*/ TVerschieben()",
"/*220*/ TQ(2634.7965461324,356.3896383971,-128.7965461324,10)",
"/*221*/ TKopieren()",
"/*222*/ TVerschieben()",
"/*223*/ TQ(134.7965461324,356.3896383971,-128.7965461324,10)",
"/*224*/ TA()",
"/*225*/ TQ(125,375,-125,6)",
"/*226*/ TSchneiden()",
"/*227*/ TQ(19.5930922647,-13.2207232058,-25.5930922647,11)",
"/*228*/ TA()",
"/*229*/ TQ(5.1682108373,-6.2739010163,-13.6534922116,6)",
"/*230*/ TSchneiden()",
"/*231*/ TQ(2750,678,-244,9)",
"/*232*/ TLoeschen()",
"/*233*/ TQ(1000,0,0,0)",
"/*234*/ TA()",
"/*235*/ TA()",
"/*236*/ TQ(2000,0,0,1)",
"/*237*/ TS()",
"/*238*/ TQ(0,0,0,0)",
"/*239*/ TD()",
"/*240*/ TQ(19.5930922647,-13.2207232058,-25.5930922647,9)",
"/*241*/ TDrehen()",
"/*242*/ TQ(2634.7965461324,356.3896383971,-140.7965461324,10)",
"/*243*/ TDrehen()",
"/*244*/ TQ(19.5930922647,10.7792767942,-25.1164183433,6)",
"/*245*/ TA()",
"/*246*/ TQ(19.5930922647,10.7792767942,-13.5930922647,6)",
"/*247*/ TS()",
"/*248*/ TQ(19.5930922647,-6.5057123237,-13.5930922647,6)",
"/*249*/ TD()",
"/*250*/ TQ(-519.5930922647,10.7792767942,25.5930922647,9)",
"/*251*/ TSchneiden()",
"/*252*/ TQ(134.7965461324,356.3896383971,-140.3198722109,6)",
"/*253*/ TA()",
"/*254*/ TQ(134.7965461324,356.3896383971,-128.7965461324,6)",
"/*255*/ TS()",
"/*256*/ TQ(134.7965461324,339.1046492792,-128.7965461324,6)",
"/*257*/ TD()",
"/*258*/ TQ(-634.7965461324,332.3896383971,140.7965461324,10)",
"/*259*/ TSchneiden()",
"/*260*/ TQ(1000,0,0,0)",
"/*261*/ TA()",
"/*262*/ TQ(2000,0,0,1)",
"/*263*/ TS()",
"/*264*/ TQ(0,0,0,0)",
"/*265*/ TD()",
"/*266*/ TQ(19.5930922647,-1.2207232058,13.5930922647,9)",
"/*267*/ TDrehen()",
"/*268*/ TQ(134.7965461323,332.3896383971,134.7965461324,10)",
"/*269*/ TDrehen()",
"/*270*/ TQ(1865.2034538677,356.3896383971,-128.7965461324,10)",
"/*271*/ TA()",
"/*272*/ TQ(1866.9004132337,373.8429161762,-124.6143053921,1)",
"/*273*/ TSchneiden()",
"/*274*/ TQ(1980.4069077353,10.7792767942,-13.5930922647,9)",
"/*275*/ TA()",
"/*276*/ TQ(1992.2861078416,-2.3141676475,0.7713892158,1);",
"/*277*/ TSchneiden()",
"/*278*/ TQ(1000,750,-250,0)",
"/*279*/ TA()",
"/*280*/ TQ(1750,750,-250,1)",
"/*281*/ TS()",
"/*282*/ TQ(250,750,-250,5)",
"/*283*/ TD()",
"/*284*/ TQ(134.7965461324,332.3896383971,-140.7965461324,10)",
"/*285*/ TKopieren()",
"/*286*/ TDrehen()",
"/*287*/ TQ(19.5930922647,-13.2207232058,-25.5930922647,9)",
"/*288*/ TKopieren()",
"/*289*/ TDrehen()",
"/*290*/ TQ(19.5930922647,-13.2207232058,-474.4069077353,12)",
"/*291*/ TA()",
"/*292*/ TQ(-0.7713892158,-2.3141676475,-492.2861078416,5)",
"/*293*/ TSchneiden()",
"/*294*/ TQ(134.7965461323,332.3896383971,-359.2034538676,11)",
"/*295*/ TA()",
"/*296*/ TQ(120.371664705,361.1149941149,-371.1430539208,5)",
"/*297*/ TSchneiden()",
"/*298*/ TQ(1865.2034538676,344.3896383971,-359.2034538676,11)",
"/*299*/ TA()",
"/*300*/ TQ(1866.9004132337,373.8429161762,-375.3856946079,2)",
"/*301*/ TSchneiden()",
"/*302*/ TQ(1980.4069077353,-13.2207232058,-474.4069077353,12)",
"/*303*/ TA()",
"/*304*/ TQ(1980.4069077353,-10.2336343851,-488.8921891095,2)",
"/*305*/ TSchneiden()",
"/*306*/ TQ(2500,24,62,3)",
"/*307*/ TLoeschen()",
"/*308*/ TQ(1000,356.3896383971,-140.7965461324,10)",
"/*309*/ TA()",
"/*310*/ TQ(994,375,-125,7)",
"/*311*/ TSchneiden()",
"/*312*/ TQ(1000,356.3896383971,-371.2034538676,11)",
"/*313*/ TA()",
"/*314*/ TQ(994,375,-375,8)",
"/*315*/ TSchneiden()",
"/*316*/ TQ(1000,10.7792767942,-13.5930922647,9)",
"/*317*/ TA()",
"/*318*/ TQ(1006,-7.5894663844,-22.7683991532,7)",
"/*319*/ TSchneiden()",
"/*320*/ TQ(1000,10.7792767942,-474.4069077353,3)",
"/*321*/ TA()",
"/*322*/ //TQ(1000,10.7792767942,-486.4069077353,3)",
"/*323*/ //TSchneiden()",
"/*324*/ TQ(994,-7.5894663844,-477.2316008468,8)",
"/*325*/ TSchneiden()",
"/*326*/ TQ(1006,0,0,7)",
"/*327*/ TA()",
"/*328*/ TQ(994,0,0,7)",
"/*329*/ TA()",
"/*330*/ TQ(1006,0,0,7)",
"/*331*/ TS()",
"/*332*/ TKopieren()",
"/*333*/ TVerschieben()",
"/*334*/ TVerschieben()",
"/*335*/ TVerschieben()",
"/*336*/ TVerschieben()",
"/*337*/ TVerschieben()",
"/*338*/ TVerschieben()",
"/*339*/ TVerschieben()",
"/*340*/ TVerschieben()",
"/*341*/ TVerschieben()",
"/*342*/ TVerschieben()",
"/*343*/ TVerschieben()",
"/*344*/ TVerschieben()",
"/*345*/ TQ(1006,0,0,7)",
"/*346*/ TA()",
"/*347*/ TQ(1150,0,0,12)",
"/*348*/ TS()",
"/*349*/ TKopieren()",
"/*350*/ TVerschieben()",
"/*351*/ TKopieren()",
"/*352*/ TVerschieben()",
"/*353*/ TKopieren()",
"/*354*/ TVerschieben()",
"/*355*/ TKopieren()",
"/*356*/ TVerschieben()",
"/*357*/ TQ(1150,0,0,12)",
"/*358*/ TA()",
"/*359*/ TA()",
"/*360*/ TQ(1006,0,0,7)",
"/*361*/ TS()",
"/*362*/ TKopieren()",
"/*363*/ TVerschieben()",
"/*364*/ TKopieren()",
"/*365*/ TVerschieben()",
"/*366*/ TKopieren()",
"/*367*/ TVerschieben()",
"/*368*/ TKopieren()",
"/*369*/ TVerschieben()",
"/*370*/ TKopieren()",
"/*371*/ TVerschieben()",
"/*372*/ TQ(1006,0,-500,8)",
"/*373*/ TA()",
"/*374*/ TQ(994,0,-500,8)",
"/*375*/ TS()",
"/*376*/ TKopieren()",
"/*377*/ TVerschieben()",
"/*378*/ TVerschieben()",
"/*379*/ TVerschieben()",
"/*380*/ TVerschieben()",
"/*381*/ TVerschieben()",
"/*382*/ TVerschieben()",
"/*383*/ TVerschieben()",
"/*384*/ TVerschieben()",
"/*385*/ TVerschieben()",
"/*386*/ TVerschieben()",
"/*387*/ TVerschieben()",
"/*388*/ TVerschieben()",
"/*389*/ TQ(994,0,-500,8)",
"/*390*/ TA()",
"/*391*/ TQ(850,0,-500,22)",
"/*392*/ TS()",
"/*393*/ TKopieren()",
"/*394*/ TVerschieben()",
"/*395*/ TKopieren()",
"/*396*/ TVerschieben()",
"/*397*/ TKopieren()",
"/*398*/ TVerschieben()",
"/*399*/ TKopieren()",
"/*400*/ TVerschieben()",
"/*401*/ TQ(850,0,-500,22)",
"/*402*/ TA()",
"/*403*/ TQ(994,0,-500,8)",
"/*404*/ TS()",
"/*405*/ TKopieren()",
"/*406*/ TVerschieben()",
"/*407*/ TKopieren()",
"/*408*/ TVerschieben()",
"/*409*/ TKopieren()",
"/*410*/ TVerschieben()",
"/*411*/ TKopieren()",
"/*412*/ TVerschieben()",
"/*413*/ TKopieren()",
"/*414*/ TVerschieben()",
];
  
  
  
  
  
  

  
  LTeval(LT,0);
  Logfile("das war Beispiel3");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }




var Beispiel4=function() {
  QASDzoom=2;

  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  
  // position and point the camera to
  schaue_von_und_nach(-1.19,1.19,-2.85, 0.00,0.00,0.00);

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//Logflag=true;
//Testflag=true;
LT=[
"/*0*/ TQ(355,0,0,0)",
"/*1*/ TA()",
"/*2*/ TQ(250,0,1250,1)",
"/*3*/ TS()",
"/*4*/ TQ(250,120,1250,1)",
"/*5*/ TD()",
"/*6*/ TQ(177.5,0,0,0)",
"/*7*/ TSchneiden()",
"/*8*/ TQ(0,0,0,0)",
"/*9*/ TA()",
"/*10*/ TQ(130,120,1250,1)",
"/*11*/ TS()",
"/*12*/ TQ(130,0,1250,1)",
"/*13*/ TD()",
"/*14*/ TQ(177.5,0,0,0)",
"/*15*/ TSchneiden()",
"/*16*/ TQ(11.96,115,115,0)",
"/*17*/ TA()",
"/*18*/ TQ(350.17,115,57.5,0)",
"/*19*/ TS()",
"/*20*/ TQ(345.34,57.5,115,0)",
"/*21*/ TD()",
"/*22*/ TSchneiden()",
"/*23*/ TQ(11.96,115,115,0)",
"/*24*/ TA()",
"/*25*/ TQ(250,120,1250,1)",
"/*26*/ TS()",
"/*27*/ TQ(190,0,1250,1)",
"/*28*/ TD()",
"/*29*/ TQ(177.5,0,0,0)",
"/*30*/ TSchneiden()",
"/*31*/ TQ(0,0,0,0);TA();TS();TD()",
];
  
  
 
  
  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel4");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }





var Beispiel5=function() {
  QASDzoom=8;

  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  

  // position and point the camera to
  schaue_von_und_nach(1.31,0.93,1.04, 0.00,0.00,0.00);

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
//var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
//var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//Logflag=true;
//Testflag=true';


LT=[
"/*0*/ TNeu(300,100,200)",
"/*1*/ TQ(55,65,50,0)",
"/*2*/ TNeu(105,50,60)",
"/*3*/ TQ(60,70,100,0)",
"/*4*/ TNeu(100,50,60)",
"/*5*/ TQ(60,70,40,1)",
"/*6*/ TA()",
"/*7*/ TQ(0,0,0,0)",
"/*8*/ TSchneiden()",
"/*9*/ TQ(60,120,160,2)",
"/*10*/ TA()",
"/*11*/ TQ(0,0,0,0)",
"/*12*/ TSchneiden()",
"/*13*/ TQ(0,0,0,0)",
"/*14*/ TA()",
"/*15*/ TS()",
"/*16*/ TD()",
"/*17*/ TQ(55,65,110,0)",
"/*18*/ TA()",
"/*19*/ TQ(60,70,100,2)",
"/*20*/ TS()",
"/*21*/ TQ(160,115,50,1)",
"/*22*/ TVerschieben()",
"/*23*/ TVerschieben()",
"/*24*/ TQ(170,125,30,1)",
"/*25*/ TA()",
"/*26*/ TQ(0,100,200,0)",
"/*27*/ TSchneiden()",
"/*28*/ TQ(55,65,110,0)",
"/*29*/ TA()",
"/*30*/ TQ(60,70,100,2)",
"/*31*/ TS()",
"/*32*/ TQ(170,125,30,1)",
"/*33*/ TVerschieben()",
"/*34*/ TVerschieben()",
"/*35*/ TVerschieben()",
"/*36*/ TVerschieben()",
"/*37*/ TVerschieben()",
"/*38*/ TVerschieben()",
"/*39*/ TVerschieben()",
"/*40*/ TVerschieben()",
"/*41*/ TQ(160,120,100,2)",
"/*42*/ TUmdrehen()",
"/*43*/ TVerschieben()",
"/*44*/ TVerschieben()",
"/*45*/ TVerschieben()",
"/*46*/ TVerschieben()",
"/*47*/ TVerschieben()",
"/*48*/ TVerschieben()",
"/*49*/ TVerschieben()",
"/*50*/ TVerschieben()",
"/*51*/ TVerschieben()",
"/*52*/ TVerschieben()",
"/*53*/ TVerschieben()",
"/*54*/ TVerschieben()",
"/*55*/ TVerschieben()",
"/*56*/ TVerschieben()",
];
  
  
/*
09 Vector (0.0, 0.0, 200.0)
08 Vector (0.0, 0.0, 0.0)
11 Vector (0.0, 100.0, 200.0)
10 Vector (0.0, 100.0, 0.0)
12 Vector (300.0, 0.0, 0.0)
13 Vector (300.0, 0.0, 200.0)
15 Vector (300.0, 100.0, 200.0)
14 Vector (300.0, 100.0, 0.0)
06 Vector (55.0, 100.0, 110.0)
00 Vector (60.0, 100.0, 110.0)
03 Vector (60.0, 100.0, 160.0)
04 Vector (160.0, 100.0, 160.0)
Vector (160.0, 100.0, 110.0)
Vector (160.0, 100.0, 100.0)
07 Vector (160.0, 100.0, 50.0)
05 Vector (55.0, 100.0, 50.0)
17 Vector (55.0, 65.0, 110.0)
02 Vector (60.0, 70.0, 110.0)
01 Vector (160.0, 70.0, 110.0)
19 Vector (160.0, 65.0, 110.0)
20 Vector (60.0, 70.0, 160.0)
21 Vector (160.0, 70.0, 160.0)
Vector (160.0, 70.0, 100.0)
18 Vector (160.0, 65.0, 50.0)
16 Vector (55.0, 65.0, 50.0)
*/

  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel5");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }




var Beispiel6=function() {
  QASDzoom=1;
  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  
  // position and point the camera to
  schaue_von_und_nach(-0.83,0.83,-1.99, 0.00,0.00,0.00);

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//Logflag=true;
//Testflag=true;

LT=[
"/*0*/ TQ(130,0,1250,1)",
"/*1*/ TA()",
"/*2*/ TQ(250,0,1435,1)",
"/*3*/ TS()",
"/*4*/ TQ(0,0,57.5,0)",
"/*5*/ TVerschieben()",
"/*6*/ TQ(120,0,185,0)",
"/*7*/ TA()",
"/*8*/ TQ(475,0,242.5,0)",
"/*9*/ TS()",
"/*10*/ TQ(475,57.5,300,0)",
"/*11*/ TD()",
"/*12*/ Logflag=true;TDrehen();//Logflag=false;",
];

/*
Verschieben zum Ursprung mit [dx,dy,dz]=[-120,0,-185]
Drehen um die y-Achse mit alpha=-80.79959953092967
Drehen um die x-Achse mit beta=-8.759726433781287
Drehen um die y-Achse mit gamma=72.05059700708613
Verschieben zum Ausgangsort mit [dx,dy,dz]=[120,0,185]
    p0=[0,1,2,[120.00000000000003,7.105427357601003e-15,184.99999999999994,1],null,[0,1,2]]
    p1=[0,1,5,[102.30375447070085,2.80019748308526,298.5957824402935,1],null,[0,1,5]]
    p2=[0,2,4,[103.33891404604843,113.65860228231527,179.60274680364947,1],null,[0,2,4]]
    p3=[0,4,5,[85.64266851674925,116.45879976540053,293.19852924394297,1],null,[0,4,5]]
    p4=[1,2,3,[466.98065689313665,53.367846927155945,237.73800011725046,1],null,[1,2,3]]
    p5=[1,3,5,[449.2844113638375,56.16804441024118,351.33378255754394,1],null,[1,3,5]]
    p6=[2,3,4,[450.31957093918504,167.0264492094712,232.34074692089996,1],null,[2,3,4]]
    p7=[3,4,5,[432.62332540988587,169.82664669255644,345.93652936119344,1],null,[3,4,5]]
Vector (102.30375447070081, 2.8001974830852503, 298.5957824402934)
Vector (120.0, 0.0, 185.0)
Vector (85.64266851674923, 116.45879976540053, 293.1985292439429)
Vector (103.33891404604842, 113.65860228231527, 179.6027468036495)
Vector (449.28441136383736, 56.16804441024116, 351.333782557544)
Vector (466.98065689313654, 53.36784692715591, 237.73800011725058)
Vector (432.6233254098858, 169.82664669255644, 345.9365293611935)
Vector (450.319570939185, 167.0264492094712, 232.34074692090005)
*/
  
  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel6");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }




var Beispiel7=function() {
  QASDzoom=8;

  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  

  // position and point the camera to
  schaue_von_und_nach(51.71,1.93,1.08, 52.50,1.00,0.25);


//Logflag=true;
//Testflag=true;

LT=[
"/*0*/ TNeu(100,1000,100)",
"/*1*/ TQ(0,0,50,0)",
"/*2*/ TA()",
"/*3*/ TQ(0,0,0,0)",
"/*4*/ TS();",
"/*5*/ TVerschieben()",
"/*6*/ TQ(50,0,-50,0)",
"/*7*/ TA()",
"/*8*/ TQ(0,0,-50,0)",
"/*9*/ TS()",
"/*10*/ TVerschieben();",
"/*11*/ TQ(-50,1000,50,0)",
"/*12*/ TA()",
"/*13*/ TQ(-50,0,50,0)",
"/*14*/ TS()",
"/*15*/ TVerschieben()",
"/*16*/ TQ(10000,-2000,-100,0)",
"/*17*/ TNeu(1000,2000,100,'oberstes L-Teil')",
"/*18*/ TQ(10000,0,0,1)",
"/*19*/ TA()",
"/*20*/ TQ(11000,0,0,1)",
"/*21*/ TS()",
"/*22*/ TD(); YPR(-8)",
"/*23*/ TQ(10000,0,0,1)",
"/*24*/ TDrehen()",
"/*17*/ TNeu(100,200,50,'Meßklotz')",
"/*27*/ TQ(10000,0,0,1)",
"/*28*/ TA()",
"/*29*/ TQ(10100,0,0,2)",
"/*30*/ TS()",
"/*15*/ D(500)",
"/*15*/ TVerschieben()",
"/*33*/ TQ(10500,200,50,2)",
"/*17*/ TNeu(20,30,15,'Nutholz')",
  ];

  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel7");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }




var Beispiel8=function() {
  QASDzoom=8;
  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  

  // position and point the camera to
  schaue_von_und_nach(1.08,1.47,-0.77, 0.50,1.00,0.00);


//Logflag=true;
//Testflag=true;

LT=[
"/*0*/ TNeu(100,200,50)",
"/*1*/ TQ(0,200,0,0)",
"/*2*/ TNeu(20,30,15)",
"/*3*/ TQ(0,230,0,1)",
"/*4*/ TA()",
"/*5*/ TQ(0,200,0,0)",
"/*6*/ TS()",
"/*7*/ TQ(0,230,15,1)",
"/*8*/ TVerschieben()",
"/*9*/ TA()",
"/*10*/ TQ(0,170,15,1)",
"/*11*/ TA()",
"/*12*/ TQ(0,170,0,1)",
"/*13*/ TS()",
"/*14*/ TUmdrehen()",
"/*15*/ TMerken()",
"/*16*/ TQ(0,170,15,1)",
"/*17*/ TA()",
"/*18*/ TQ(0,200,15,1)",
"/*19*/ TS()",
"/*20*/ TUmdrehen()",
"/*21*/ TQ(0,200,50,0)",
"/*22*/ TSchneiden()",
"/*23*/ TQ(20,170,0,1)",
"/*24*/ TA()",
"/*25*/ TQ(0,170,0,0)",
"/*26*/ TS()",
"/*27*/ TUmdrehen()",
"/*28*/ TMerken()",
"/*29*/ TQ(20,170,0,1)",
"/*30*/ TA()",
"/*31*/ TQ(20,200,0,1)",
"/*32*/ TS()",
"/*33*/ TUmdrehen()",
"/*34*/ TQ(0,200,50,0)",
"/*35*/ TSchneiden()",
"/*36*/ TQ(20,200,15,0)",
"/*37*/ TA()",
"/*38*/ TQ(100,200,50,0)",
"/*39*/ TS()",
"/*40*/ TQ(0,200,0,1)",
"/*41*/ TVerschieben()",
"/*42*/ TQ(80,170,50,1)",
"/*43*/ TA()",
"/*44*/ TQ(100,170,50,1)",
"/*45*/ TS()",
"/*46*/ TUmdrehen()",
"/*47*/ TMerken()",
"/*48*/ TQ(80,170,50,1)",
"/*49*/ TA()",
"/*50*/ TQ(80,200,50,1)",
"/*51*/ TS()",
"/*52*/ TUmdrehen()",
"/*53*/ TQ(20,200,15,0)",
"/*54*/ TSchneiden()",
"/*55*/ TQ(100,170,35,1)",
"/*56*/ TA()",
"/*57*/ TQ(100,170,50,1)",
"/*58*/ TS()",
"/*59*/ TUmdrehen()",
"/*60*/ TMerken()",
"/*61*/ TQ(100,170,35,1)",
"/*62*/ TA()",
"/*63*/ TQ(100,200,35,1)",
"/*64*/ TS()",
"/*65*/ TUmdrehen()",
"/*66*/ TQ(20,200,15,0)",
"/*67*/ TSchneiden()",
"/*68*/ TQ(80,200,50,1)",
"/*69*/ TA()",
"/*70*/ TQ(100,200,50,1)",
"/*71*/ TS()",
"/*72*/ TQ(100,200,35,1)",
"/*73*/ TVerschieben()",
"/*74*/ TVerschieben()",
"/*75*/ TQ(140,170,50,1);TA();TS();TD();",
"/*76*/ TQ(0,170,0,0)",
];


  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel8");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }





var Beispiel9=function() {
  QASDzoom=8;

  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  

  // position and point the camera to
  schaue_von_und_nach(1.08,1.47,-0.77, 0.50,1.00,0.00);


//Logflag=true;
//Testflag=true;

LT=[
"/*0*/ TNeu(100,200,50)",
"/*1*/ TQ(0,200,0,0)",
"/*2*/ TNeu(20,30,15)",
"/*3*/ TQ(0,230,0,1)",
"/*4*/ TA()",
"/*5*/ TQ(0,200,0,0)",
"/*6*/ TS()",
"/*7*/ TQ(0,230,15,1)",
"/*8*/ TVerschieben()",
"/*9*/ TA()",
"/*10*/ TQ(0,170,15,1)",
"/*11*/ TA()",
"/*12*/ TQ(0,170,0,1)",
"/*13*/ TS()",
"/*14*/ TUmdrehen()",
"/*15*/ TMerken()",
"/*16*/ TQ(0,170,15,1)",
"/*17*/ TA()",
"/*18*/ TQ(0,200,15,1)",
"/*19*/ TS()",
"/*20*/ TUmdrehen()",
"/*21*/ TQ(0,200,50,0)",
"/*22*/ TSchneiden()",
"/*23*/ TQ(20,170,0,1)",
"/*24*/ TA()",
"/*25*/ TQ(0,170,0,0)",
"/*26*/ TS()",
"/*27*/ TUmdrehen()",
"/*28*/ TMerken()",
"/*29*/ TQ(20,170,0,1)",
"/*30*/ TA()",
"/*31*/ TQ(20,200,0,1)",
"/*32*/ TS()",
"/*33*/ TUmdrehen()",
"/*34*/ TQ(0,200,50,0)",
"/*35*/ TSchneiden()",
"/*36*/ TQ(20,200,15,0)",
"/*37*/ TA()",
"/*38*/ TQ(100,200,50,0)",
"/*39*/ TS()",
"/*40*/ TQ(0,200,0,1)",
"/*41*/ TVerschieben()",
"/*42*/ TQ(80,170,50,1)",
"/*43*/ TA()",
"/*44*/ TQ(100,170,50,1)",
"/*45*/ TS()",
"/*46*/ TUmdrehen()",
"/*47*/ TMerken()",
"/*48*/ TQ(80,170,50,1)",
"/*49*/ TA()",
"/*50*/ TQ(80,200,50,1)",
"/*51*/ TS()",
"/*52*/ TUmdrehen()",
"/*53*/ TQ(20,200,15,0)",
"/*54*/ TSchneiden()",
"/*55*/ TQ(100,170,35,1)",
"/*56*/ TA()",
"/*57*/ TQ(100,170,50,1)",
"/*58*/ TS()",
"/*59*/ TUmdrehen()",
"/*60*/ TMerken()",
"/*61*/ TQ(100,170,35,1)",
"/*62*/ TA()",
"/*63*/ TQ(100,200,35,1)",
"/*64*/ TS()",
"/*65*/ TUmdrehen()",
"/*66*/ TQ(20,200,15,0)",
"/*67*/ TSchneiden()",
"/*68*/ TQ(80,200,50,1)",
"/*69*/ TA()",
"/*70*/ TQ(100,200,50,1)",
"/*71*/ TS()",
"/*72*/ TQ(100,200,35,1)",
"/*73*/ TVerschieben()",
"/*74*/ TVerschieben()",
"/*75*/ TQ(140,170,50,1)",
"/*76*/ TA()",
"/*77*/ TS()",
"/*78*/ TD()",
"/*79*/ TQ(50,170,35,0)",
"/*80*/ TA()",
"/*81*/ TQ(50,200,35,0)",
"/*82*/ TS()",
"/*83*/ TQ(50,200,15,0)",
"/*84*/ TD()",
"/*85*/ TMerken()",
"/*86*/ TQ(80,200,15,0)",
"/*87*/ TA()",
"/*88*/ TQ(80,200,35,0)",
"/*89*/ TS()",
"/*90*/ TQ(20,185,35,0)",
"/*91*/ TD()",
"/*92*/ TSchneiden()",
"/*93*/ TQ(80,170,25,0)",
"/*94*/ TA()",
"/*95*/ TQ(20,200,35,0)",
"/*96*/ TS()",
"/*97*/ TQ(20,170,35,0)",
"/*98*/ TD()",
"/*99*/ TMerken()",
"/*100*/ TQ(80,170,25,0)",
"/*101*/ TA()",
"/*102*/ TQ(20,170,25,0)",
"/*103*/ TS()",
"/*104*/ TQ(35,200,15,0)",
"/*105*/ TD()",
"/*106*/ TSchneiden()",
"/*107*/ TQ(50,170,0,0)",
"/*108*/ TA()",
"/*109*/ TQ(20,185,20,0)",
"/*110*/ TS()",
"/*111*/ TUmdrehen()",
"/*112*/ TMerken()",
"/*113*/ TQ(50,170,0,0)",
"/*114*/ TA()",
"/*115*/ TQ(80,185,15,0)",
"/*116*/ TS()",
"/*117*/ TUmdrehen()",
"/*118*/ TSchneiden()",
"/*119*/ TQ(20,182.5,35,0)",
"/*120*/ TA()",
"/*121*/ TQ(80,170,30,0)",
"/*122*/ TS()",
"/*123*/ TQ(91.6666666667,170,50,0)",
"/*124*/ TD()",
"/*125*/ TMerken()",
"/*126*/ TQ(80,170,30,0)",
"/*127*/ TA()",
"/*128*/ TQ(0,170,12.5,0)",
"/*129*/ TS()",
"/*130*/ TQ(20,182.5,35,0)",
"/*131*/ TD()",
"/*132*/ TQ(80,170,30,0)",
"/*133*/ TA()",
"/*134*/ TQ(35,185,15,0)",
"/*135*/ TS()",
"/*136*/ TQ(20,182.5,35,0)",
"/*137*/ TD()",
"/*138*/ TSchneiden()",
];
  
  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel9");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }


  

var Beispiel10=function() {
  QASDzoom=8;

  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  History=[];
  Logflag=false;
  

  // position and point the camera to
  schaue_von_und_nach(1.5,1,2, 0,0,0);


//Logflag=true;
//Testflag=true;

LT=[
"/*0*/ TNeu(200,100,50)",
"/*1*/ TQ(100,100,50,0)",
"/*2*/ TA()",
"/*3*/ TQ(0,100,50,0)",
"/*4*/ TS()",
"/*5*/ TMerken()",
"/*6*/ TQ(200,100,50,0)",
"/*7*/ TA()",
"/*8*/ TQ(0,50,50,0)",
"/*9*/ TS()",
"/*10*/ TQ(0,50,0,0)",
"/*11*/ TD()",
"/*12*/ TSchneiden()",
"/*13*/ TQ(200,100,25,0)",
"/*14*/ TA()",
"/*15*/ TQ(200,100,50,0)",
"/*16*/ TS();Logflag=true",
"/*17*/ //TSchneiden()",
];
  
  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel10");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrameID=requestAnimationFrame(render);
    zeige_Kameraposition();
    }    
  render();
  }


  
//Eingabefunktionen für Log2
var gerundet=function(x) { return Math.round(x*10000000000)/10000000000 }

var TQ=function(x,y,z,cmin) {//setzt Koordinaten von q und damit OBJ_X
  if ((Logtext2.length>0)&&(Logtext2[Logtext2.length-1]).slice(0,2)=="TQ") Logtext2.pop();
  Logtext2.push("TQ("+gerundet(x)+","+gerundet(y)+","+gerundet(z)+","+cmin+")");
  q.position.x=x/zoom;
  q.position.y=y/zoom;
  q.position.z=z/zoom;
  OBJ_X=Castlist[cmin];
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  History_update();
  Logfile();
  Logfile2();
  }

var TA=function() {//setzt Punkt A auf Punkt Q
  Logtext2.push("TA()");
  PA.position.copy(q.position); OBJ_Y=OBJ_X;
  History_update();
  Logfile2();
  }

var TS=function() {//setzt Punkt S auf Punkt Q
  Logtext2.push("TS()");
  PS.position.copy(q.position);
  ASdistanz=PS.position.distanceTo(PA.position)*zoom;
  Verschiebedistanz=ASdistanz;
  //VAS.geometry.verticesNeedUpdate = true;
  VAS.geometry.setFromPoints([PA.position,PS.position]);
  OBJ_Y=0;
  SCHNITTVEKTOR_AS=[[EGGT([PA.position.x-PS.position.x,PA.position.y-PS.position.y,PA.position.z-PS.position.z,-((PA.position.x-PS.position.x)*PA.position.x+(PA.position.y-PS.position.y)*PA.position.y+(PA.position.z-PS.position.z)*PA.position.z)*zoom])],[TEBN],[],[]];
  KDUMP(SCHNITTVEKTOR_AS);
  History_update();
  Logfile();
  Logfile2();
  }

var TD=function() {//setzt Punkt D auf Punkt Q
  Logtext2.push("TD()");
  PD.position.copy(q.position);
  //EASD.geometry.verticesNeedUpdate = true;
  EASD.geometry.setFromPoints([PA.position,PD.position]);
  OBJ_Y=0;
  SCHNITTVEKTOR_AS=0;
  SCHNITTEBENE_ASD=[[DREIPUNKTE([PA.position.x*zoom,PA.position.y*zoom,PA.position.z*zoom,1],[PD.position.x*zoom,PD.position.y*zoom,PD.position.z*zoom,1],[PS.position.x*zoom,PS.position.y*zoom,PS.position.z*zoom,1])],[TEBN],[],[]];
  History_update();
  Logfile2();
  }

var TUmdrehen=function() {//AS oder AD umdrehen
  Logtext2.push("TUmdrehen()");
  if (SCHNITTVEKTOR_AS!=0) {
    SCHNITTVEKTOR_AS[0][0][0]=-SCHNITTVEKTOR_AS[0][0][0];
    SCHNITTVEKTOR_AS[0][0][1]=-SCHNITTVEKTOR_AS[0][0][1];
    SCHNITTVEKTOR_AS[0][0][2]=-SCHNITTVEKTOR_AS[0][0][2];
    SCHNITTVEKTOR_AS[0][0][3]=-SCHNITTVEKTOR_AS[0][0][3];
    PS.position.x=2*PA.position.x-PS.position.x;
    PS.position.y=2*PA.position.y-PS.position.y;
    PS.position.z=2*PA.position.z-PS.position.z;
    //VAS.geometry.verticesNeedUpdate = true;
    VAS.geometry.setFromPoints([PA.position,PS.position]);
    Logtext="SCHNITTVEKTOR_AS nach -AS:\n";KDUMP(SCHNITTVEKTOR_AS);Logfile();
    } else if (SCHNITTEBENE_ASD!=0) {
      SCHNITTEBENE_ASD[0][0][0]=-SCHNITTEBENE_ASD[0][0][0];
      SCHNITTEBENE_ASD[0][0][1]=-SCHNITTEBENE_ASD[0][0][1];
      SCHNITTEBENE_ASD[0][0][2]=-SCHNITTEBENE_ASD[0][0][2];
      SCHNITTEBENE_ASD[0][0][3]=-SCHNITTEBENE_ASD[0][0][3];
      PD.position.x=2*PA.position.x-PD.position.x;
      PD.position.y=2*PA.position.y-PD.position.y;
      PD.position.z=2*PA.position.z-PD.position.z;
      //EASD.geometry.verticesNeedUpdate = true;
      EASD.geometry.setFromPoints([PA.position,PD.position]);
      Logtext="SCHNITTEBENE_ASD nach -AD:\n";KDUMP(SCHNITTEBENE_ASD);Logfile();
      }
  History_update();
  }

var TMerken_Hilfsfunktion=function() {//
  if (SCHNITTVEKTOR_AS!=0) {
    MERKOBJEKT[0].push(SCHNITTVEKTOR_AS[0][0]);
    MERKOBJEKT[1].push(TEBN);
    if (MERKOBJEKT[0].length>1) MERKOBJEKT[1].push(TAND);
    } else if (SCHNITTEBENE_ASD!=0) {
      MERKOBJEKT[0].push(SCHNITTEBENE_ASD[0][0]);
      MERKOBJEKT[1].push(TEBN);
      if (MERKOBJEKT[0].length>1) MERKOBJEKT[1].push(TAND);
      }
  }

var TMerken=function() {//legt Ebene ASD fest
  Logtext2.push("TMerken()");
  TMerken_Hilfsfunktion();
  Logtext="MERKEBENE nach TMerken():\n";
  KDUMP(MERKOBJEKT);
  History_update();
  Logfile();
  Logfile2();
  }

var TKopieren=function() {//verschiebt OBJ_X um Vektor AS
  Logtext2.push("TKopieren()");
  //OBJ_X=OBJ_X.slice();
  //OBJ_X[4]=[]; 
  OBJ_X=JSON.parse(JSON.stringify(OBJ_X.slice(0,4)));
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);
  SAMMELEBENE=[[],[],[],[]];
  History_update();
  Logfile();
  Logfile2();
  }

var TVerschieben=function() {//verschiebt OBJ_X um Vektor AS
  Logtext2.push("TVerschieben()");
  scene.remove(OBJ_X[4]); 
  var cind=Castlist.indexOf(OBJ_X);
  OBJ_X=TRANSFORM(OBJ_X,[
    [1,0,0,(PA.position.x-PS.position.x)*zoom*Verschiebedistanz/ASdistanz],
    [0,1,0,(PA.position.y-PS.position.y)*zoom*Verschiebedistanz/ASdistanz],
    [0,0,1,(PA.position.z-PS.position.z)*zoom*Verschiebedistanz/ASdistanz],
    [0,0,0,1]]);
  KDUMP(OBJ_X);KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X); Castlist.pop(); 
  Castlist[cind]=OBJ_X;
  SAMMELEBENE=[[],[],[],[]];
  History_update();
  Logfile();
  Logfile2();
  }

var TDrehen=function() {//dreht OBJ_X aus Vektor AS in Richtung AD erst yaw dann pitch
  Logtext2.push("TDrehen()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  OBJ_X=DrehenASD(OBJ_X);
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);Castlist.pop();
  Castlist[cind]=OBJ_X;
  SAMMELEBENE=[[],[],[],[]]
  History_update();
  Logfile();
  Logfile2();
  }

var TSchneiden=function() {//schneidet von OBJ_X das Objekt SAMMELEBENE ab
  Logtext2.push("TSchneiden()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  if (OBJ_Y!=0) SAMMELEBENE=OBJ_Y; else {
    TMerken_Hilfsfunktion();
    SAMMELEBENE=MERKOBJEKT;
    }
  OBJ_X=RUMPS(OBJ_X,SAMMELEBENE,1);
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);Castlist.pop();
  Castlist[cind]=OBJ_X;
  MERKOBJEKT=[[],[],[],[]];
  History_update();
  Logfile();
  Logfile2();
  }

var TLoeschen=function() {//schneidet von OBJ_X das Objekt SAMMELEBENE ab
  Logtext2.push("TLoeschen()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  Castlist[cind]=Castlist.pop();
  MERKOBJEKT=[[],[],[],[]];
  History_update();
  Logfile();
  Logfile2();
  }

var TNeu=function(l,b,h,name) {
  Logtext2.push("TNeu("+l+","+b+","+h+")");
  PUNKT_A=[q.position.x*zoom,q.position.y*zoom,q.position.z*zoom,1];
  var NEU=QUADER(l,b,h);
  KFILL(NEU); 
  NEU[5]=name;
  AddObjekt(scene,NEU);
  History_update();
  Logfile();
  Logfile2();
  }

var YPR=function(yaw) {//###
  Logtext2.push("YPR("+yaw+")");
  //for (var p in PA.position) Logtext2.push(" "+p);
  var ya=yaw/180*Math.PI;
  var cosyaw=Math.cos(ya);
  var sinyaw=Math.sin(ya);
  PS.position.y=PA.position.y;
  PD.position.y=PA.position.y;
  PD.position.x=PA.position.x+cosyaw*(PS.position.x-PA.position.x)+sinyaw*(PS.position.z-PA.position.z);
  PD.position.z=PA.position.z-sinyaw*(PS.position.x-PA.position.x)+cosyaw*(PS.position.z-PA.position.z);
  //alert(PS.position.x*zoom);
  //TS(PS.position.x*zoom,PS.position.y*zoom,PS.position.z*zoom,cmin);
  //TD(PD.position.x*zoom,PD.position.y*zoom,PD.position.z*zoom,cmin);
  }

var D=function(dist) {
  Logtext2.push("D("+dist+")");
  Verschiebedistanz=dist;
  }



//nur ein einzelnes Objekt zeigen
var einzeln=0;
function Einzelobjekt() {
  //alert(Castlist[3]);
  einzeln=1-einzeln;
  for (var i=0;i<Castlist.length;i++) {
    if (einzeln==1) if (i!=cmin) Castlist[i][4].visible=false;
    if (einzeln==0) Castlist[i][4].visible=true;
    }
  }



//Logfile
//gesammelten Logtext ausgeben
function Logfile(Resttext) {
  if (!Resttext) var Resttext="";
  document.getElementById("Log").innerHTML='<span style="white-space:pre; font-family:monospace">'+Logtext+Resttext+"</span>";
  Logtext="";
  document.getElementById("KPLOTelement").innerHTML=KPLOTtext;
  }

function Logfile2(Resttext) {
  if (!Resttext) var Resttext="";
  var Log2element=document.getElementById("Log2");
  var Log2element_innerHTML='<span style="white-space:pre; font-family:monospace">\nLT=[\n';
  for (let t in Logtext2) Log2element_innerHTML=Log2element_innerHTML+'<span moduleclick="History_t('+t+')">"/*'+t+"*/ "+Logtext2[t]+'",</span>\n';
  Log2element_innerHTML=Log2element_innerHTML+Resttext+'];\n\  \n  </span>';
  Log2element.innerHTML=Log2element_innerHTML;
  Log2element.scrollTo({//mit dem geht Kopieren nicht
    top: 100000,
    left: 0,
    //behavior: 'smooth'
    });
  selectText("Log2");
  }

function selectText(element) { //Quelle: https://gist.github.com/gubatron/6599366
    var doc = document
        , text = doc.getElementById(element)
        , range, selection
    ;    
    if (doc.body.createTextRange) { //ms
        range = doc.body.createTextRange();
        range.moveToElementText(text);
        range.select();
    } else if (window.getSelection) { //all others
        selection = window.getSelection();        
        range = doc.createRange();
        range.selectNodeContents(text);
        selection.removeAllRanges();
        selection.addRange(range);
    }
}

var LTeval=function(LT,ltind) {
  eval(LT[ltind]);
  ltind=ltind+1;
  if (ltind<LT.length) setTimeout(LTeval,20,LT,ltind);
  }


  
//raycast
function raycast ( e ) {
  //raycaster.setFromCamera( mouse, camera ) aus three.pdf ging nicht
  //1. sets the mouse position with a coordinate system where the center
  //   of the screen is the origin
  //for (var i in e) alert(i);
  //mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
  //mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
  mouse.x = ( (event.clientX-event.target.getBoundingClientRect().left) / canvas_width/*window.innerWidth*/ ) * 2 - 1;
  mouse.y = - ( (event.clientY-event.target.getBoundingClientRect().top) / canvas_height/*window.innerHeight/*event.target.height*/ ) * 2 + 1;
  mouse.z = 1;
//  document.getElementById("mouse").firstChild.nodeValue=JSON.stringify(mouse);
  if (Logflag) Logtext=Logtext+JSON.stringify(mouse)+"\n";
  cmin=0;
  var dmin=0;
  var pk="p";
  var pmin=[[0,0,0,1],[0,0,0,1]];
  var mindist=Infinity;
  for (var c in Castlist) if(Castlist[c][4].visible) {
    if (Logflag) Logtext=Logtext+"OBJ["+c+"]:\n";
    for (var d in Castlist[c][2]) {
      var p=Castlist[c][2][d][3];
      var pp=(new THREE.Vector3(p[0]/zoom,p[1]/zoom,p[2]/zoom)).project(camera);
      pp.z=1;
      var dist=pp.distanceToSquared(mouse);
      if (dist<mindist) {pk="p"; mindist=dist; cmin=c; dmin=d; pmin=[p.slice(),p.slice()];}
      if (Logflag) Logtext=Logtext+"d="+d+", dist="+dist+", mindist="+mindist+JSON.stringify(pp)+"\n";
      }
    for (var d in Castlist[c][3]) {
      var p=Castlist[c][2];
      var k=Castlist[c][3][d];
      var pp=(new THREE.Vector3(
        (p[k[0]][3][0]+p[k[1]][3][0])/2/zoom,
        (p[k[0]][3][1]+p[k[1]][3][1])/2/zoom,
        (p[k[0]][3][2]+p[k[1]][3][2])/2/zoom
        )).project(camera);
      pp.z=1;
      var dist=pp.distanceToSquared(mouse);
      if (dist<mindist) {pk="k"; mindist=dist; cmin=c; dmin=d; pmin=[p[k[0]][3].slice(),p[k[1]][3].slice()];}
      }
    }
//alert("cmin="+cmin+", dmin="+dmin+",pmin="+JSON.stringify(pmin)+", mindist="+mindist);
//alert(JSON.stringify((new THREE.Vector3((pmin[0][0]+pmin[1][0])/2/zoom,(pmin[0][1]+pmin[1][1])/2/zoom,(pmin[0][2]+pmin[1][2])/2/zoom)).project(camera))); 
  TQ((pmin[0][0]+pmin[1][0])/2,(pmin[0][1]+pmin[1][1])/2,(pmin[0][2]+pmin[1][2])/2,cmin);
  document.getElementById("Pdisp").firstChild.nodeValue=pk+dmin+"=["+[(q.position.x*zoom).toFixed(2),(q.position.y*zoom).toFixed(2),(q.position.z*zoom).toFixed(2)]+'] in "OBJ'+cmin+" ("+Castlist[cmin][5]+')"';
  }


  
//markObj war in KONSTRUK_javascript.js vordefiniert als alert
markObj=function(cmin,ekpi,i,value) {
  //alert("Hallo "+[cmin,ekpi,i,value].join("---"));
  var OBJC=Castlist[cmin];
  var PC=OBJC[2]; //Punkte
  var KC=OBJC[3]; //Kanten
  var EC=OBJC[0]; //Ebenen
  if (ekpi==2) {
    //TQ(value[3][0],value[3][1],value[3][2],cmin);
    var p=PUNKT2D(value[3]);
    var svg_p=document.getElementById("svg_p");
    svg_p.setAttribute("cx",p[0]);
    svg_p.setAttribute("cy",p[1]);
    document.getElementById("Pdisp").firstChild.nodeValue="p"+i+"="+JSON.stringify(value)+' in "'+cmin+" "+Castlist[cmin][5]+'"';
    }
  if (ekpi==3) { /*TQ(
    (Castlist[cmin][2][value[0]][3][0]+Castlist[cmin][2][value[1]][3][0])/2,
    (Castlist[cmin][2][value[0]][3][1]+Castlist[cmin][2][value[1]][3][1])/2,
    (Castlist[cmin][2][value[0]][3][2]+Castlist[cmin][2][value[1]][3][2])/2,
    cmin);*/
    var svg_k=document.getElementById("svg_k");
    var p=PUNKT2D(Castlist[cmin][2][value[0]][3]);
    svg_k.setAttribute("x1",p[0]);
    svg_k.setAttribute("y1",p[1]);
    var p=PUNKT2D(Castlist[cmin][2][value[1]][3]);
    svg_k.setAttribute("x2",p[0]);
    svg_k.setAttribute("y2",p[1]);
    document.getElementById("Pdisp").firstChild.nodeValue="k"+i+"="+JSON.stringify(value)+' in "OBJ'+cmin+" "+Castlist[cmin][5]+'"';
    }
  if (ekpi==0) { 
    var KLISTE=[];
    var PLISTE=[];
    var d="M0,0 ";
    for (var j=0;j<KC.length;j++) {
      if (KC[j][7].indexOf(i)>-1) {
        KLISTE.push(j); 
        PLISTE.push([KC[j][0],KC[j][1]]);
        var P1=PUNKT2D(PC[KC[j][0]][3]);
        var P2=PUNKT2D(PC[KC[j][1]][3]);
        d=d+"L"+P1[0]+","+P1[1]+" L"+P2[0]+","+P2[1]+" L0,0 ";
        }
      }
    //alert(KLISTE);
    //alert(PLISTE.join("\n"));
    d=d+"Z";
    document.getElementById("Eiderdaus").setAttribute("d",d);    
    }
  }



//History
var History_update=function() {
  var hist="";
  for (var i in Castlist) hist=hist+"AddObjekt(scene,"+JSON.stringify(Castlist[i].slice(0,4))+");\n";
  History.push(hist);
  return hist;
  }
  
var History_t=function(t) {
  for (var i in Castlist) scene.remove(Castlist[i][4]);
  Castlist=[];
  eval(History[t]);
  }




//alert(THREE.LineBasicMaterial);
function AddObjekt(OBJ1,OBJ2) {
  var temp_material = new THREE.LineBasicMaterial({ color: 0x0077f0, linewidth:2});
  var temp_geometry = new THREE.BufferGeometry();
  temp_geometry.vertices = [new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0)];
  var temp = new THREE.Line(temp_geometry, temp_material);
  for (var iK in OBJ2[3]) { var K=OBJ2[3][iK];
    var numPoints = 2;   
    var start = new THREE.Vector3(OBJ2[2][K[0]][3][0]/zoom, OBJ2[2][K[0]][3][1]/zoom, OBJ2[2][K[0]][3][2]/zoom);   
    var middle = new THREE.Vector3(OBJ2[2][K[0]][3][0]/zoom, OBJ2[2][K[0]][3][1]/zoom, OBJ2[2][K[0]][3][2]/zoom);   
    var end = new THREE.Vector3(OBJ2[2][K[1]][3][0]/zoom, OBJ2[2][K[1]][3][1]/zoom, OBJ2[2][K[1]][3][2]/zoom);

    if (Linientyp==0) {//alert('QuadraticBezierCurve3 geht wohl nicht')
      var numPoints = 33;
      var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end); 
      var tube = new THREE.TubeGeometry(curveQuad, numPoints, 0.05, 33, false);
      var mesh11 = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({opacity: 0.99,     transparent: true   }));   
      temp.add(mesh11);
      } else {
        var materialline = new THREE.LineBasicMaterial({ color: 0x0077f0, linewidth:1});
        //var geometryline = new THREE.BufferGeometry();
        //geometryline.vertices = [start,end];
        var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
        var obj2line = new THREE.Line(geometryline, materialline);
        temp.add(obj2line);
        }

    }
  OBJ2[4]=temp;
  OBJ1.add(temp);
  Castlist.push(OBJ2);
  }




function export_object() {
  var ExportText="import Part\nfrom FreeCAD import Base\n"; //JSON.stringify(OBJ_X.slice(0,4));
  var E=OBJ_X[0];
  var P=OBJ_X[2];
  var K=OBJ_X[3];
  for (var i in P) ExportText=ExportText+"p"+i+"=Base.Vector("+P[i][3].slice(0,3)+")\n";
  for (var i in K) ExportText=ExportText+"k"+i+"=Part.LineSegment(p"+K[i][0]+",p"+K[i][1]+").toShape()\n";
  for (var i in E) if (E[i][5]>0) {
    ExportText=ExportText+"e"+i+"=Part.Face(Part.Wire([";
    for (var j in K) if (K[j][7][0]==i||K[j][7][1]==i) ExportText=ExportText+"k"+j+",";
    ExportText=ExportText.slice(0,-1)+"]))\n";
    }
  ExportText=ExportText+"OBJ_X=Part.Solid(Part.Shell([";
  for (var i in E) if (E[i][5]>0) ExportText=ExportText+"e"+i+",";
  ExportText=ExportText.slice(0,-1)+"]))\nPart.show(OBJ_X)\n";
  //alert(ExportText);
  document.getElementById("exportiere").innerHTML=ExportText+"\n";
  selectText("exportiere");
  }

/*Vorlage: https://wiki.freecadweb.org/index.php?title=Topological_data_scripting

import Part
from FreeCAD import Base
V1 = Base.Vector(0, 10, 0)
V2 = Base.Vector(30, 10, 0)
V3 = Base.Vector(30, -10, 0)
L1 = Part.LineSegment(V1, V2)
L2 = Part.LineSegment(V3, V4)
...
#The last step is to put the geometric base elements together and bake a topological shape:
S1 = Part.Shape([C1, L1, C2, L2])
W = Part.Wire(S1.Edges)

face1 = Part.Face(poly)
face2 = Part.Face(poly)

myShell = Part.makeShell([face1, face2, face3, face4, face5, face6])   
mySolid = Part.makeSolid(myShell)

myCyl = Part.makeCylinder(2, 20)
myCyl.translate(Base.Vector(size / 2, size / 2, 0))

cut_part = mySolid.cut(myCyl)

Part.show(cut_part)

*/




var schaue_von_und_nach=function(x,y,z, u,v,w) {
  camera.position.x=x;
  camera.position.y=y;
  camera.position.z=z;
  //camera.position=new THREE.Vector3(x,y,z); //geht nicht
  contr.target.copy(new THREE.Vector3(u,v,w)); //anstelle camera.lookAt(scene.position);
  }

var zeige_Kameraposition=function() {//###
  document.getElementById("camerapos").firstChild.nodeValue=camera.position.x.toFixed(2)+","+camera.position.y.toFixed(2)+","+camera.position.z.toFixed(2)+",  "+(cube.position.x).toFixed(2)+","+(cube.position.y).toFixed(2)+","+(cube.position.z).toFixed(2);
  }




function Testspline() {

var spline = new THREE.SplineCurve3([
     new THREE.Vector3(-10, -2, 10),
     new THREE.Vector3(-4, -2, 2),
     new THREE.Vector3(0, -2, -10),
     new THREE.Vector3(2, -2, -10),
     new THREE.Vector3(0,-4,0),
     new THREE.Vector3(7, -2, 1),
     new THREE.Vector3(10, -2, 3),
     new THREE.Vector3(-10, -2, 10)]);
   var geometry = new THREE.BufferGeometry();
   var splinePoints = spline.getPoints(50);
   var material = new THREE.LineBasicMaterial({ color: 0xff00f0   });
//   geometry.vertices = [new THREE.Vector3(0, 2, 0),new THREE.Vector3(2, 0, 2)]; //splinePoints;
   geometry.vertices = splinePoints;
   var sline = new THREE.Line(geometry, material);
   sline.name='sline';
   return sline;
  }



let PL=[];
let cpoints=[];
function ANF_display(OBJ) {
	 OBJ_gefuellt.remove(...OBJ_gefuellt.children);
  PL=OBJ.PL;
  cpoints=OBJ.konv;
  let cmax=Math.max(...(PL.flat(2).map(Math.abs)));//alert('cmax='+cmax);
  for (let c=0;c<cpoints.length;c++) for (let i=0;i<cpoints[c].length;i++) {
    let p=PL[cpoints[c][i]];
    cpoints[c][i]=new THREE.Vector3(p[0]/zoom,p[1]/zoom,p[2]/zoom);//oder /cmax
    }
  let cgeometry,cmaterial,cmesh;
  for (let c=0;c<cpoints.length;c++) if (cpoints[c].length>0) {
    cgeometry = new ConvexGeometry(cpoints[c]);
    cmaterial = new THREE.MeshStandardMaterial({ color: 0xf080f0+c*0x000000, roughness:0.3, metalness:0.1, transparent: true, opacity: 1 });
    cmesh = new THREE.Mesh(cgeometry, cmaterial);
    OBJ_gefuellt.add(cmesh);
    }
  }



/*
  DRU X wählt ein OBJEKT X
  DRU C kopiert OBJEKT X an die gleiche Stelle
  DRU A wählt einen PUNKT A.
  DRU S wählt zu A einen VEKTOR AS.
  DRU D wählt zu AS eine EBENE ASD.
  DRU E verschiebt X entlang AS
  DRU Q dreht X von AS in Richtung AD
  DRU W AS pendelt um AD bis AS2
  DRU F EBENE ASD sägt OBJEKT X rechterhand ab
  DRU R VEKTOR AS sägt OBJEKT X linkerhand ab
  DRU Y wählt OBJEKT Y
  DRU T OBJEKT Y spart OBJEKT X aus.
  DRU mit Shifttaste ‹:
  DRU ‹C löscht Objekt X
  DRU ‹E dreht Vektor AS um.
  DRU ‹R hebt Sägeebene auf bis R oder F
  DRU ‹F hebt Sägeebene auf bis R oder F
  DRU ‹T Durchschnitt von Objekt X und Y
  DRU weitere Eingaben
  DRU G zur einzelnen Darstellung X und Y
  DRU 4 Vergrößerung (4:1)
  DRU 3 Vergrößerung (3:2)
  DRU 2 Verkleinerung (2:3)
  DRU 1 Verkleinerung (1:4)
  DRU J Blick von weiter links
  DRU K Blick von weiter rechts
  ;
*/



/*
FEHLERTEXT ( nr --> adr n )
  DUP 500 < IF FEHLERTEXT ELSE >R
    R 502 = IF U" OBJEKT X ist nicht markiert" ENDIF
    R 503 = IF U" OBJEKT Y ist nicht markiert" ENDIF
    R 504 = IF U" VEKTOR AS ist nicht markiert oder A fällt mit S zusammen" ENDIF
    R 505 = IF U" EBENE ASD ist nicht markiert oder A fällt mit S oder D zusammen" ENDIF
    R 506 = IF U" AS und AD sind parallel" ENDIF
    R 507 = IF U" AS2 und AD sind parallel" ENDIF
    R 508 = IF U" Wurzel aus negativer ganzen Zahl" ENDIF
    R 500 = IF U" Wurzel aus negativer rationalen Zahl" ENDIF
    R 501 = IF U" Fehler im Rechenausdruck" ENDIF
    R 508 > IF " ???" ENDIF
    R> DROP ENDIF
  ;
  */


function Logclick() {
  let ev=event.target.getAttribute('moduleclick');
  eval(ev);
  }

Log.addEventListener('click',Logclick);
Log2.addEventListener('click',Logclick);
button_Beispiel1.addEventListener('click',Beispiel1);
button_Beispiel2.addEventListener('click',Beispiel2);
button_Beispiel3.addEventListener('click',Beispiel3);
button_Beispiel4.addEventListener('click',Beispiel4);
button_Beispiel5.addEventListener('click',Beispiel5);
button_Beispiel6.addEventListener('click',Beispiel6);
button_Beispiel7.addEventListener('click',Beispiel7);
button_Beispiel8.addEventListener('click',Beispiel8);
button_Beispiel9.addEventListener('click',Beispiel9);
button_Beispiel10.addEventListener('click',Beispiel10);
button_TA.addEventListener('click',TA);
button_TS.addEventListener('click',TS);
button_TD.addEventListener('click',TD);
button_TUmdrehen.addEventListener('click',TUmdrehen);
button_TMerken.addEventListener('click',TMerken);
button_TKopieren.addEventListener('click',TKopieren);
button_TVerschieben.addEventListener('click',TVerschieben);
button_TDrehen.addEventListener('click',TDrehen);
button_TSchneiden.addEventListener('click',TSchneiden);
button_TLoeschen.addEventListener('click',TLoeschen);
button_Test.addEventListener('click',function(){alert('Testbutton ohne Funktion')});
button_Zentrieren.addEventListener('click',function(){contr.target.copy(q.position)});
button_einzeln.addEventListener('click',Einzelobjekt);
button_Auswaehlen.addEventListener('click',export_object);
button_Verlauf.addEventListener('click',export_object);
button_Auswaehlen.addEventListener('click',export_object);
button_ANF_Test.addEventListener('click',function(){ANF_Test(OBJ_X);ANF_display(OBJ_X)});



Beispiel10();
console.error('kein Fehler, alles ok')


  </script>

<!--svg height="300px">
<path d="M0,0 L100,100 L100,200 L0,0 L200,100 L100,100 L0,0 L200,200 L200,100 L0,0 L200,200 L100,200 L0,0 L130,180 L150,120 L0,0 L170,180 L130,180 L0,0 L170,180 L150,120 L0,0 Z" stroke="none" fill="orange" fill-rule="evenodd"/>
<path d="M10,10 L20,10 M20,20 L20,20 L10,20" stroke="green" fill="orange" fill-rule="evenodd"/>
  </svg-->


  <style>
     body {
       margin: 1;
       overflow: auto;
       }

    button {font-size:200%}
    </style>
</body>
</html>
