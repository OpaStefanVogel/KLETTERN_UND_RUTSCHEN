<!DOCTYPE html>
<html>
<head>
  <!-- verwendete Vorlage: three-cookbook/.../01.05-setup-animation-loop.html -->
  <!-- was noch nicht geht:
.. Reihenfolge ASD soll positive Seite der Ebene bestimmen
.. die stimmt aber nicht beim Keil, deshalb auch -ASD
    -->
  <meta charset="utf-8"/>
  <title>MIT_KONSTRUK_FF.html</title>
  <script src="../libs/three.js"></script>
  <script src="../three.js/build/three.js"></script>
  <!--script src="../threejs-cookbook/libs/three.js"></script>
  <script src="../threejs-cookbook/libs/OrbitControls.js"></script>
  <script src="../threejs-cookbook/libs/Projector.js"></script>
  <script src="../threejs-cookbook/libs/dat.gui.min.js"></script>
  <script src="../threejs-cookbook/libs/clock.js"></script-->
  <script src="threejs-cookbook/libs/three.js"></script>
  <script src="threejs-cookbook/libs/OrbitControls.js"></script>
  <script src="threejs-cookbook/libs/Projector.js"></script>
  <script src="threejs-cookbook/libs/dat.gui.min.js"></script>
  <script src="threejs-cookbook/libs/clock.js"></script>
  <style>
     body {
       margin: 1;
       overflow: auto;
       }

    button {font-size:200%}
    </style>
  </head>
<body onload="Beispiel3()">
<!--canvas id="Uhr"> </canvas-->
<div>2 Eingabebeispiele: 
  <button onclick="Beispiel1()">REST5</button> und
  <button onclick="Beispiel2()">GOKART</button>.
  <button onclick="Beispiel3()">DACH</button>.
  </div>
<button onclick='TA()'>TA()</button>
<button onclick='TS()'>TS()</button>
<button onclick='TD()'>TD()</button>

<button onclick='TUmdrehen()'>Umdrehen</button>
<button onclick='TMerken()'>Merken</button>
<button onclick='TKopieren()'>Kopieren</button>
<button onclick='TVerschieben()'>Verschieben</button>
<button onclick='TDrehen()'>Drehen</button>
<button onclick='TSchneiden()'>Schneiden</button>
<button onclick='TLoeschen()'>Löschen</button>




<div style="max-width:90%;max-height:80%; height:550px; border:solid; border-color:red; overflow:hidden" id="canvas"	>hier kommt das render.domElement rein</div>
<button onclick='alert(JSON.stringify(VAS.geometry.vertices));alert(document.getElementById("canvas").scrollHeight)'>Test</button>
<button onclick='contr.target.copy(q.position)'>Zentrieren</button>
<span id="Pdisp">...</span>;
  </div>
<div id="Log2" style="display:flex; overflow:auto; border:solid; width:90%; height:200px"> div</div>
<div id="Log" style="display:flex; overflow:auto; border:solid; width:90%; height:400px"> div</div>

<script src="QWASNEU/KONSTRUK_javascript.js"></script>

<script>
//var Uhr = document.getElementById('Uhr'); 
//Uhr.width=51; Uhr.height=51; 
//clock(Uhr);
  </script>

<script>//globale Variablen
var renderer;
var scene;
var camera;
//var raycaster = new THREE.Raycaster(); //aus three.js.pdf
var mouse = { x : 0, y : 0 }; 
var Castlist=[];
var q; //PUNKT_Q;
var PA,PS,PD;
var VAS;
var EASD;
var canvas_height=0;
var canvas_width=0;
var zoom=20;
var Linientyp=0;
var cube;
var REST5;
var cmin=0;
var OBJ_X=cmin;
var OBJ_Y=cmin;
var SCHNITTEBENE;
var SAMMELEBENE=[[],[],[],[]];
var Logtext2=[];
var LT=[];
var SCHNITTVEKTOR_AS=0;
var SCHNITTEBENE_ASD=0;
var MERKOBJEKT=[[],[],[],[]];
  </script>

<script>//globale Funktionen
function init() {
  zoom=20;
  Linientyp=0;
  PUNKT_A=[0,0,0,1];
  Castlist=[];

  // create a scene, that will hold all our elements such as objects, cameras and lights.
  scene = new THREE.Scene();
  canvas_height=window.innerHeight;//document.getElementById("canvas").clientHeight;
  canvas_width=window.innerWidth;  //document.getElementById("canvas").clientWidth;
  //alert(canvas_width+" "+canvas_height);

  // create a camera, which defines where we‘re looking at.
  //camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera = new THREE.PerspectiveCamera(45, canvas_width / canvas_height, 0.1, 1000);
  //alert(THREE.WebGLRenderer); //geht nicht bei MINT

  // create a render, sets the background color and the size
  renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(0xCCCC00, 1.0);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.addEventListener( 'click', raycast, false );

        // add light
        var light = new THREE.DirectionalLight();
        light.position.set(1200, 1200, 1200);
        scene.add(light);

  // create a cube and add to scene
  var cubeGeometry = new THREE.BoxGeometry(0.1 /* 10 * Math.random()*/, 0.1, 0.1);
//alert(JSON.stringify(cubeGeometry.faces));
  var cubeMaterial = new THREE.MeshNormalMaterial();
  cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  cube.name = 'cube';
  cube.position.x=0;
  scene.add(cube);

  //Pointer Q
  //var qGeometry = new THREE.SphereGeometry( 0.14, 32, 32 );
  var qGeometry = new THREE.BoxGeometry(0.17, 0.17, 0.17);
  var qMaterial = new THREE.MeshBasicMaterial( { color: 0xFFFF00, opacity:0.5, transparent:true } );
  q = new THREE.Mesh( qGeometry, qMaterial );
  q.position.x=205/zoom;
  q.position.z=150/zoom;
  scene.add( q );
  //Knoten.push(q.position.clone());

  var AGeometry = new THREE.SphereGeometry( 0.09, 32, 32 );
  var AMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity:0.5, transparent:true } );
  PA = new THREE.Mesh( AGeometry, AMaterial );
  PA.position.x=20/zoom;
  PA.position.z=0/zoom;
  scene.add( PA );
  
  var SGeometry = new THREE.SphereGeometry( 0.095, 32, 32 );
  var SMaterial = new THREE.MeshBasicMaterial( { color: 0x0000FF, opacity:0.5, transparent:true } );
  PS = new THREE.Mesh( SGeometry, SMaterial );
  PS.position.x=10/zoom;
  PS.position.y=30/zoom;
  PS.position.z=10/zoom;
  scene.add( PS );

  var DGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
  var DMaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, opacity:0.5, transparent:true } );
  PD = new THREE.Mesh( DGeometry, DMaterial );
  PD.position.x=0/zoom;
  PD.position.z=40/zoom;
  scene.add( PD );

  var VASmaterial = new THREE.LineBasicMaterial({ color: 0x778899, linewidth:4});
  var VASgeometry = new THREE.Geometry();
  VASgeometry.vertices = [PA.position,PS.position];
  //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
  VAS = new THREE.Line(VASgeometry, VASmaterial);
  scene.add( VAS );

  var EASDmaterial = new THREE.LineBasicMaterial({ color: 0x996633, linewidth:3});
  var EASDgeometry = new THREE.Geometry();
  EASDgeometry.vertices = [PA.position,PD.position];
  //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
  EASD = new THREE.Line(EASDgeometry, EASDmaterial);
  scene.add( EASD );

  // position and point the camera to the center of the scene
  camera.position.x = 5; //15;
  camera.position.y = 5; //16;
  camera.position.z = -12; //13
  camera.lookAt(scene.position);

  // add the output of the renderer to the html element
  document.getElementById("canvas").replaceChild(renderer.domElement,document.getElementById("canvas").firstChild);

  contr = new THREE.OrbitControls( camera ,document.getElementById("canvas"));

  scene.add(Testspline());
  }
  </script>

<script>
var DrehenASD=function(OBJ_X) {

  var RET=TRANSFORM(OBJ_X,[[1,0,0,PA.position.x*zoom],[0,1,0,PA.position.y*zoom],[0,0,1,PA.position.z*zoom],[0,0,0,1]]);

  var alpha=0; 
  if((PS.position.z-PA.position.z)**2+(PS.position.x-PA.position.x)**2>0.00001) {
    alpha=-Math.atan2(PS.position.x-PA.position.x,PS.position.z-PA.position.z);
    }
  if (Logflag==true) alert("Drehen mit alpha="+(alpha*180/Math.PI));
  var ca=Math.cos(alpha); 
  var sa=Math.sin(alpha); 
  RET=TRANSFORM(RET,[[ca,0,-sa,0],[0,1,0,0],[sa,0,ca,0],[0,0,0,1]]); 

  var beta=0;
  if(((PD.position.z-PA.position.z)**2+(PD.position.y-PA.position.y)**2>0.00001)/*&&((PS.position.z-PA.position.z)**2+(PS.position.y-PA.position.y)**2>0.00001)*/) {
    beta=-Math.atan2(Math.sqrt((PD.position.z-PA.position.z)**2+(PD.position.x-PA.position.x)**2),PD.position.y-PA.position.y);
    beta=beta+Math.atan2(Math.sqrt((PS.position.z-PA.position.z)**2+(PS.position.x-PA.position.x)**2),PS.position.y-PA.position.y);
    }
  if (Logflag==true) alert("beta="+(beta*180/Math.PI));
  var cb=Math.cos(beta); 
  var sb=Math.sin(beta); 
  RET=TRANSFORM(RET,[[1,0,0,0],[0,cb,-sb,0],[0,sb,cb,0],[0,0,0,1]]);

  var gamma=0; 
  if((PD.position.z-PA.position.z)**2+(PD.position.x-PA.position.x)**2>0.00001) {
    gamma=Math.atan2(PD.position.x-PA.position.x,PD.position.z-PA.position.z);
    }
  var cc=Math.cos(gamma); 
  var sc=Math.sin(gamma); 
  RET=TRANSFORM(RET,[[cc,0,-sc,0],[0,1,0,0],[sc,0,cc,0],[0,0,0,1]]); 

  RET=TRANSFORM(RET,[[1,0,0,-PA.position.x*zoom],[0,1,0,-PA.position.y*zoom],[0,0,1,-PA.position.z*zoom],[0,0,0,1]]); 

  return RET;
  }

  </script>

<script>
var neuen_Balken_plazieren=function(x,y,z,l,b,h) {
  PUNKT_A=[x,y,z,1];
  var RET=QUADER(l,b,h);
  KFILL(RET);
  KDUMP(RET);
  KPLOT([RET]);
  AddObjekt(scene,RET);
  return RET;
  }
  </script>

<script>
var Beispiel1=function() {
  init();
  Linientyp=0; //Röhren
  Logtext2=[];
  OBJ_Y=0;

var BALKEN1=QUADER(200,100,150); KFILL(BALKEN1);
var SCHNITT2=EBENE([100,0,0,1],[200,50,150,1],[200,0,90,1]);
var REST1=RUMPS(BALKEN1,SCHNITT2,1);
TRANSFORM(REST1,A);
TRANSFORM(SCHNITT2,CDF);
var REST2=RUMPS(REST1,SCHNITT2,1);
var BALKEN2=QUADER(60,60,60); KFILL(BALKEN2);
var C=[[1,0,0,10],[0,1,0,10],[0,0,1,10],[0,0,0,1]];
TRANSFORM(BALKEN2,C);
var REST3=RUMPS(BALKEN1,BALKEN2,1);
var REST4=RUMPS(REST2,BALKEN2,1);
PUNKT_A=[-10,75,-10,1];
var BALKEN3=QUADER(100,15,100); KFILL(BALKEN3);
Logflag=true;
REST5=RUMPS(REST4,BALKEN3,1);
//REST5=BALKEN1;
Logtext=Logtext+"REST5="+JSON.stringify(REST5)+"\n";
Logtext=Logtext+"BALKEN3="+JSON.stringify(BALKEN3)+"\n";
KPLOT([REST1]);
KPLOT([REST4]);
KPLOT([REST5]);
Castlist.push(REST5);
cube.geometry.faces[0].color = new THREE.Color(0x000000); 
AddObjekt(scene,REST5);
TQ(20,0,0,0);
TA();
TQ(10,30,10,0);
TS();
TQ(0,0,40,0);
TD();
TQ(50,0,0,0);

Logtext=JSON.stringify(cube.geometry.faces)+"\n"+Logtext;

  Logfile();
  Logfile2();

  //var xm=new XMLSerializer();
  //alert(xm.serializeToString(renderer.domElement));
  //alert(renderer.domElement);
 
  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }

  </script>

<script>
var Beispiel2=function() {
  init();
  zoom=200;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  
  // position and point the camera to the center of the scene
  camera.position.x = -5; //5; //15;
  camera.position.y = 5; //5; //16;
  camera.position.z = -12; //-12; //13
  camera.lookAt(scene.position);

/*
  PA.position.x=0/zoom;
  PA.position.y=0/zoom;
  PA.position.z=0/zoom;

  PS.position.x=0/zoom;
  PS.position.y=0/zoom;
  PS.position.z=1700/zoom;

  PD.position.x=130/zoom;
  PD.position.y=120/zoom;
  PD.position.z=1250/zoom;
*/

//      " >P 0 0 0 Anlegepunkt" INTERPRET
//      " >Q 355 115 115 Hinterbalken" INTERPRET
var Hinterbalken=neuen_Balken_plazieren(0,0,0,355,115,115);

//      " >P 130 1250 0 Anlegepunkt" INTERPRET
//      " >Q 120 370 120 Vorderbalken" INTERPRET
var Vorderbalken=neuen_Balken_plazieren(130,0,1250,120,120,370);

//      " >P -250 0 0 Anlegepunkt" INTERPRET
//      " >Q 18 1700 180 rechtesBrett" INTERPRET
var rechtes_Brett=neuen_Balken_plazieren(-250,0,0,18,180,1700);

//      " >P -500 0 0 Anlegepunkt" INTERPRET
//      " >Q 30 700 180 HochzuBrett" INTERPRET
var Hochzubrett=neuen_Balken_plazieren(-500,0,0,30,180,700);

//      " >P -750 0 0 Anlegepunkt" INTERPRET
//      " >Q 20 2000 20 Bügel" INTERPRET
var Buegel=neuen_Balken_plazieren(-750,0,0,20,20,2000);





LT=[
"TQ(-232,0,0,2)",
"TA()",
"TQ(0,0,0,0)",
"TS()",
"TQ(-250,180,1700,2)",
"TKopieren()",
"TVerschieben()",
"TQ(-250,0,0,2)",
"TA()",
"TQ(355,0,0,0)",
"TS()",
"TQ(-232,180,1700,2)",
"TVerschieben()",
"TQ(0,0,0,0)",
"TA()",
"TQ(0,0,1700,5)",
"TS()",
"TQ(130,0,1250,1)",
"TD()",
"TQ(-18,180,1700,5)",
"TDrehen()",
"TQ(130,120,1250,1)",
"TS()",
"TQ(130,0,1250,1)",
"TD()",
"TQ(250,120,1620,1)",
"TSchneiden()",
"TQ(177.5,115,0,0)",
"TSchneiden()",
"TQ(355,0,0,0)",
"TA()",
"TQ(355,0,1700,2)",
"TS()",
"TQ(250,0,1250,1)",
"TD()",
"TQ(373,180,1700,2)",
"TDrehen()",
"TQ(250,0,1250,1)",
"TS()",
"TQ(250,120,1250,1)",
"TD()",
"TQ(190,120,1250,1)",
"TSchneiden()",
"TQ(183.48,0,115,0)",
"TSchneiden()",
"TQ(193.7,120,1620,1)",
"TA()",
"TQ(218.92,60,1620,1)",
"TS()",
"TQ(168.48000000000002,60,1620,1)",
"TD()",
"TQ(212.70114787936444,180,1694.0339538170856,2)",
"TSchneiden()",
"TQ(157.94811390479882,0,1692.7422701976568,5)",
"TSchneiden()",
"TQ(-500,90,0,3)",
"TA()",
"TQ(177.5,0,0,0)",
"TS()",
"TQ(-485,180,0,3)",
"TVerschieben()",
"TQ(177.5,0,0,0)",
"TA()",
"TQ(177.5,0,700,3)",
"TS()",
"TQ(177.5,90,0,3)",
"TD()",
"TQ(177.5,-90,0,3)",
"TDrehen()",
"TQ(177.5,5.5109105961630896e-15,-90,3)",
"TS()",
"TQ(0,0,0,0)",
"TD()",
"TQ(207.5,350,90.00000000000003,3)",
"TDrehen()",
"TQ(-750,0,0,4)",
"TA()",
"TQ(-750,20,0,4)",
"TA()",
"TQ(87.5,700,-29.999999999999986,3)",
"TS()",
"TQ(-730,0,1000,4)",
"TKopieren()",
"TVerschieben()",
"TQ(-730,20,0,4)",
"TA()",
"TQ(267.50000000000006,700,-30.000000000000018,3)",
"TS()",
"TQ(-730,0,1000,4)",
"TVerschieben()",
"TQ(87.5,700,-29.99999999999999,6)",
"TA()",
"TQ(87.5,700,1970,6)",
"TS()",
"TQ(168.48000000000002,120,1620,1)",
"TD()",
"TQ(87.5,700,1970,6)",
"TDrehen()",
"TQ(267.5000000000001,700,-30.000000000000014,4)",
"TA()",
"TQ(267.5000000000001,700,1970,4)",
"TS()",
"TQ(218.92,120,1620,1)",
"TD()",
"TQ(267.5000000000001,700,1970,4)",
"TDrehen()",
"TQ(190,120,1250,1)",
"TA()",
"TQ(193.7,120,1620,1)",
"TS()",
"TQ(218.92,120,1620,1)",
"TD()",
"TQ(179.84152492372203,28.027354163578536,1851.495630083249,6)",
"TSchneiden()",
"TQ(211.96875676696882,37.008623401441696,1856.0961575648632,4)",
"TSchneiden()",
"TQ(87.50000000000001,700.0000000000001,-29.999999999999943,6)",
"TA()",
"TQ(97.1632037211084,681.1292704136066,-37.10760569542027,6)",
"TS()",
"TVerschieben()",
"TQ(267.50000000000006,700,-30.000000000000018,3)",
"TA()",
"TQ(257.69944764911827,681.130865323084,-36.92133875504069,4)",
"TS()",
"TVerschieben()",
"TQ(267.50000000000006,700,-15.000000000000018,3)",
"TA()",
"TQ(87.50000000000004,700,-14.999999999999984,3)",
"TS()",
"TQ(87.5,5.5109105961630896e-15,-14.999999999999984,3)",
"TD()",
"TQ(106.82640744221679,662.2585408272132,-44.215211390840565,6)",
"TSchneiden()",
"TQ(247.89889529823643,662.261730646168,-43.84267751008141,4)",
"TSchneiden()",
"TQ(118.27229099826182,651.8166393945107,-14.999999999999993,6)",
"TA()",
"TQ(177.50000000000006,700,-4.733165431326071e-30,3)",
"TSchneiden()",
"TQ(237.04536360786378,652.0196427372484,-15.000000000000014,4)",
"TA()",
"TQ(177.50000000000006,700,-4.733165431326071e-30,3)",
"TSchneiden()",
"TQ(190,0,1250,1)",
"TA()",
"TQ(190,120,1250,1)",
"TS()",
"TQ(193.7,0,1620,1)",
"TD()",
"TQ(233.0867389713242,387.27802396613663,799.0393306224815,4)",
"TSchneiden()",
"TQ(193.7,0,1620,1)",
"TS()",
"TQ(190,120,1250,1)",
"TD()",
"TQ(156.715966119015,376.4729549040578,768.305309326288,6)",
"TSchneiden()",
"TQ(193.7,0,1620,1)",
"TA()",
"TQ(138.19571096632518,387.24369123077435,798.9461971522918,6)",
"TA()",
"TQ(193.7,0,1620,1)",
"TSchneiden()",
"TQ(233.0867389713242,387.27802396613663,799.0393306224815,4)",
"TA()",
"TQ(193.7,0,1620,1)",
"TSchneiden()",

"TQ(900,0,0,0)",
"TNeu(160,210,2,'Schusterburg neues Dachfenster')",
"TQ(0,0,0,0)",
"TA()",
"TQ(0,115,0,0)",
"TS()",
"TQ(5.98,115,57.5,0)",
"TD()",
"TQ(900,0,2,7)",
"TDrehen()",
"TQ(-900,0,0,0)",
"TNeu(200,500,5,'neuer Putz')",
"TQ(-900,0,5,0)",
"TNeu(5,500,2000,'neuer Putz')",
  ];
  
  
  
  
  
  
  
  
  
  
  
  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel2");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }
  </script>

<script>//Beispiel3
var Beispiel3=function() {
  init();
  zoom=20;
  Linientyp=1; //dünne Linie
  Logtext2=[];
  
  // position and point the camera to the center of the scene
  camera.position.x = -15; //5; //15;
  camera.position.y = 5; //5; //16;
  camera.position.z = 12; //-12; //13
  camera.lookAt(scene.position);

/*
  PA.position.x=0/zoom;
  PA.position.y=0/zoom;
  PA.position.z=0/zoom;

  PS.position.x=0/zoom;
  PS.position.y=0/zoom;
  PS.position.z=1700/zoom;

  PD.position.x=130/zoom;
  PD.position.y=120/zoom;
  PD.position.z=1250/zoom;
*/

var Dach=[[
  DREIPUNKTE([0,0,0,1],[2000,0,0,1],[250,750,250,1]),
  DREIPUNKTE([0,0,500,1],[250,750,250,1],[1000,0,500,1]),
  DREIPUNKTE([0,0,0,1],[250,750,250,1],[0,0,500,1]),
  DREIPUNKTE([0,0,0,1],[0,0,500,1],[2000,0,500,1]),
  DREIPUNKTE([2000,0,0,1],[2000,0,500,1],[1750,750,250,1]),
  ],
  [TEBN,TEBN,TAND,TEBN,TAND,TEBN,TAND,TEBN,TAND],
  [],[]];
  QFILL(Dach);
  KFILL(Dach);
  AddObjekt(scene,Dach);

var Balken=neuen_Balken_plazieren(0,0,50,2500,24,12);







LT=[
"/*0*/ TQ(0,0,500,0)",
"/*1*/ TA()",
"/*2*/ TQ(0,0,0,0)",
"/*3*/ TS()",
"/*4*/ TQ(0,0,500,0)",
"/*5*/ TVerschieben()",
"/*6*/ TQ(0,24,56,1)",
"/*7*/ TA()",
"/*8*/ TQ(0,0,0,0)",
"/*9*/ TS()",
"/*10*/ TQ(0,0,12,1)",
"/*11*/ TKopieren()",
"/*12*/ TVerschieben()",
"/*13*/ TQ(0,0,0,0)",
"/*14*/ TA()",
"/*15*/ TQ(2000,0,0,0)",
"/*16*/ TS()",
"/*17*/ TQ(250,750,-250,0)",
"/*18*/ TD()",
"/*19*/ TQ(0,0,0,2)",
"/*20*/ TDrehen()",
"/*21*/ TQ(0,0,-250,0)",
"/*22*/ TA()",
"/*23*/ TA()",
"/*24*/ TQ(2000,0,-250,0)",
"/*25*/ TS()",
"/*26*/ TQ(1749.9999999999998,750.0000000000001,-250.00000000000003,0)",
"/*27*/ TD()",
"/*28*/ TQ(758.0210021315283,2261.3350843332273,-749.5357207572898,2)",
"/*29*/ TSchneiden()",
"/*30*/ TQ(0,24,56,1)",
"/*31*/ TKopieren()",
"/*32*/ TA()",
"/*33*/ TQ(0,0,-500,0)",
"/*34*/ TS()",
"/*35*/ TQ(0,24,62,1)",
"/*36*/ TVerschieben()",
"/*37*/ TQ(0,0,-500,0)",
"/*38*/ TA()",
"/*39*/ TQ(2500,0,-500,1)",
"/*40*/ TS()",
"/*41*/ TQ(2500,0,-494,1)",
"/*42*/ TA()",
"/*43*/ TQ(0,0,-500,0)",
"/*44*/ TA()",
"/*45*/ TQ(2500,0,-500,1)",
"/*46*/ TS()",
"/*47*/ TS()",
"/*48*/ TS()",
"/*49*/ TS()",
"/*50*/ TQ(250.00000000000003,750.0000000000001,-250.00000000000003,0)",
"/*51*/ TD()",
"/*52*/ TQ(2500,-24,-500,1)",
"/*53*/ TDrehen()",
"/*54*/ TQ(0,0,-250,0)",
"/*55*/ TA()",
"/*56*/ TA()",
"/*57*/ TA()",
"/*58*/ TQ(1749.9999999999998,750.0000000000001,-250.00000000000003,0)",
"/*59*/ TS()",
"/*60*/ TQ(2000,0,-250,0)",
"/*61*/ TD()",
"/*62*/ TQ(758.0210021315286,2261.3350843332273,249.53572075728977,1)",
"/*63*/ TSchneiden()",
"/*64*/ TQ(0,24,56,3)",
"/*65*/ TA()",
"/*66*/ TQ(249.9999999999999,749.9999999999998,-250,2)",
"/*67*/ TS()",
"/*68*/ TQ(2500,24,62,3)",
"/*69*/ TKopieren()",
"/*70*/ TVerschieben()",
"/*71*/ TQ(249.9999999999999,749.9999999999997,-244,4)",
"/*72*/ TA()",
"/*73*/ TQ(249.9999999999999,725.9999999999997,-244,4)",
"/*74*/ TS()",
"/*75*/ TVerschieben()",
"/*76*/ TQ(249.9999999999999,725.9999999999995,-244,4)",
"/*77*/ TA()",
"/*78*/ TQ(249.9999999999999,713.9999999999995,-244,4)",
"/*79*/ TS()",
"/*80*/ TVerschieben()",
"/*81*/ TVerschieben()",
"/*82*/ TQ(1749.9999999999998,750.0000000000001,-250.00000000000003,0)",
"/*83*/ TA()",
"/*84*/ TQ(999.9999999999999,750.0000000000001,-250.00000000000003,0)",
"/*85*/ TS()",
"/*86*/ TQ(2750,677.9999999999995,-244,4)",
"/*87*/ TSchneiden()",
"/*88*/ TQ(249.9999999999999,701.9999999999995,-244,4)",
"/*89*/ TA()",
"/*90*/ TQ(-4.242640687119296,-1.4210854715202004e-14,-4.7573593128807,2)",
"/*91*/ TSchneiden()",
"/*92*/ TQ(-4.242640687119296,-1.4210854715202004e-14,-495.7573593128807,1)",
"/*93*/ TSchneiden()",
"/*94*/ TQ(0,0,0,0)",
"/*95*/ TA()",
"/*96*/ TQ(999.9999999999999,750.0000000000001,-250.00000000000003,0)",
"/*97*/ TS()",
"/*98*/ TQ(1875,375.00000000000006,-125.00000000000001,0)",
"/*99*/ TD()",
"/*100*/ TQ(11.107810890484668,-10.233634385069301,-19.593092264723236,2)",
"/*101*/ TSchneiden()",
"/*102*/ TQ(0,0,-250,0)",
"/*103*/ TA()",
"/*104*/ TQ(250.00000000000003,750,-250.00000000000006,1)",
"/*105*/ TS()",
"/*106*/ TQ(0,0,0,0)",
"/*107*/ TD()",
"/*108*/ TQ(-4.242640687119285,-6.661338147750939e-16,-4.242640687119286,2)",
"/*109*/ TSchneiden()",
"/*110*/ TQ(4.242640687119284,-2.842170943040401e-14,-504.2426406871193,1)",
"/*111*/ TSchneiden()",
"/*112*/ TQ(2000,0,-250,0)",
"/*113*/ TA()",
"/*114*/ TQ(2000,0,-500,0)",
"/*115*/ TS()",
"/*116*/ TQ(1000,0,-500,0)",
"/*117*/ TA()",
"/*118*/ TQ(2000,0,-500,0)",
"/*119*/ TS()",
"/*120*/ TQ(1875,375.00000000000006,-375,0)",
"/*121*/ TD()",
"/*122*/ TQ(19.59309226472321,-10.233634385069308,-488.89218910951536,1)",
"/*123*/ TSchneiden()",
"/*124*/ TQ(9.003323862443442e-14,2.1184291441043393e-14,-500.00000000000006,1)",
"/*125*/ TA()",
"/*126*/ TKopieren()",
"/*127*/ TQ(2000,0,0,0)",
"/*128*/ TS()",
"/*129*/ TQ(0,0,-500,1)",
"/*130*/ TVerschieben()",
"/*131*/ TQ(2000,0,-3.389486630566944e-13,1)",
"/*132*/ TA()",
"/*133*/ TQ(1000,0,0,0)",
"/*134*/ TS()",
"/*135*/ TQ(2000,0,-500,0)",
"/*136*/ TD()",
"/*137*/ TQ(2258.485281374238,750.0000000000003,250.00000000000003,1)",
"/*138*/ TDrehen()",
"/*139*/ TDrehen()",
"/*140*/ TQ(19.59309226472324,-10.233634385069301,-11.107810890484664,2)",
"/*141*/ TKopieren()",
"/*142*/ TQ(0,0,0,0)",
"/*143*/ TA()",
"/*144*/ TQ(2000,0,-500,0)",
"/*145*/ TS()",
"/*146*/ TQ(11.107810890484668,-10.233634385069301,-19.593092264723236,2)",
"/*147*/ TVerschieben()",
"/*148*/ TQ(1999.9999999999998,0,-500,2)",
"/*149*/ TA()",
"/*150*/ TQ(2000,0,-250,0)",
"/*151*/ TS()",
"/*152*/ TQ(1000,0,-500,0)",
"/*153*/ TD()",
"/*154*/ TQ(2258.485281374239,750.0000000000001,-750,2)",
"/*155*/ TDrehen()",
"/*156*/ TDrehen()",
"/*157*/ TQ(0,24,56,3)",
"/*158*/ TA()",
"/*159*/ TQ(1000,0,0,0)",
"/*160*/ TS()",
"/*161*/ TQ(0,24,56,3)",
"/*162*/ TKopieren()",
"/*163*/ TVerschieben()",
"/*164*/ TQ(1000,0,0,0)",
"/*165*/ TA()",
"/*166*/ TQ(1999.9999999999998,1.1425957100746156e-13,-6.301387192917563e-13,1)",
"/*167*/ TS()",
"/*168*/ TQ(999.9999999999999,750.0000000000001,-250.00000000000003,0)",
"/*169*/ TD()",
"/*170*/ TQ(3500,-12,6,7)",
"/*171*/ TDrehen()",
"/*172*/ TQ(2000,0,-250,0)",
"/*173*/ TA()",
"/*174*/ TQ(999.9999999999999,750.0000000000001,-250.00000000000003,0)",
"/*175*/ TS()",
"/*176*/ TQ(0,0,-250,0)",
"/*177*/ TD()",
"/*178*/ TQ(994.0000000000016,2371.708245126285,-790.5694150420949,7)",
"/*179*/ TSchneiden()",
"/*180*/ TQ(999.9999999999998,701.9999999999995,-256,4)",
"/*181*/ TA()",
"/*182*/ TQ(1006.0000000000002,375,-125.00000000000003,7)",
"/*183*/ TSchneiden()",
"/*184*/ TQ(1000,0,0,0)",
"/*185*/ TA()",
"/*186*/ TQ(1250,24,62,3)",
"/*187*/ TS()",
"/*188*/ TQ(1006.0000000000002,352.23160084678767,-142.70875489694293,7)",
"/*189*/ TS()",
"/*190*/ TQ(1006.0000000000002,352.23160084678767,-142.70875489694293,7)",
"/*191*/ TS()",
"/*192*/ TQ(1000,0,-500,0)",
"/*193*/ TS()",
"/*194*/ TQ(994.0000000000002,375,-125,7)",
"/*195*/ TKopieren()",
"/*196*/ TVerschieben()",
"/*197*/ TQ(1000,0,-500,0)",
"/*198*/ TA()",
"/*199*/ TQ(2000,6.483614087384164e-14,-500,2)",
"/*200*/ TS()",
"/*201*/ TQ(1000,0,0,0)",
"/*202*/ TD()",
"/*203*/ TQ(1000,-7.589466384404106,-522.7683991532124,8)",
"/*204*/ TDrehen()",
"/*205*/ TDrehen()",
"/*206*/ TQ(0,0,56,3)",
"/*207*/ TA()",
"/*208*/ TQ(249.9999999999999,677.9999999999995,-250,4)",
"/*209*/ TS()",
"/*210*/ TQ(0,24,62,3)",
"/*211*/ TKopieren()",
"/*212*/ TVerschieben()",
"/*213*/ TQ(241.51471862576142,680.9870888207607,-250.00000000000003,5)",
"/*214*/ TA()",
"/*215*/ TQ(126.311264758123,335.37672721784577,-134.7965461323616,6)",
"/*216*/ TS()",
"/*217*/ TQ(2750,701.9999999999995,-244,9)",
"/*218*/ TKopieren()",
"/*219*/ TVerschieben()",
"/*220*/ TQ(2634.7965461323615,356.3896383970846,-128.79654613236158,10)",
"/*221*/ TKopieren()",
"/*222*/ TVerschieben()",
"/*223*/ TQ(134.79654613236147,356.3896383970846,-128.79654613236158,10)",
"/*224*/ TA()",
"/*225*/ TQ(125.00000000000003,375.00000000000006,-125,6)",
"/*226*/ TSchneiden()",
"/*227*/ TQ(19.593092264723055,-13.220723205830382,-25.593092264723154,11)",
"/*228*/ TA()",
"/*229*/ TQ(5.168210837322399,-6.273901016294456,-13.653492211560968,6)",
"/*230*/ TSchneiden()",
"/*231*/ TQ(2750,677.9999999999995,-244,9)",
];
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  LTeval(LT,0);
//for (var li in LT) eval(LT[li]);


  Logfile("das war Beispiel2");

  function render() {
    //ist erst hier, damit alle darin aufgerufenen Objekte schon definiert sind
    renderer.render(scene, camera);
    ////camera.position.x+=0.0;
    cube.position.copy(contr.target);
    contr.update();
    requestAnimationFrame(render);
    }    
  render();
  }
  </script>

<script>//Eingabefunktionen für Log2
var TQ=function(x,y,z,cmin) {//setzt Koordinaten von q und damit OBJ_X
  if ((Logtext2.length>0)&&(Logtext2[Logtext2.length-1]).slice(0,2)=="TQ") Logtext2.pop();
  Logtext2.push("TQ("+x+","+y+","+z+","+cmin+")");
  q.position.x=x/zoom;
  q.position.y=y/zoom;
  q.position.z=z/zoom;
  OBJ_X=Castlist[cmin];
  Logfile2();  
  }

var TA=function() {//setzt Punkt A auf Punkt Q
  Logtext2.push("TA()");
  PA.position.copy(q.position); OBJ_Y=OBJ_X;
  Logfile2();  
  }

var TS=function() {//setzt Punkt S auf Punkt Q
  Logtext2.push("TS()");
  PS.position.copy(q.position);
  VAS.geometry.verticesNeedUpdate = true;
  OBJ_Y=0;
  SCHNITTVEKTOR_AS=[[EGGT([PA.position.x-PS.position.x,PA.position.y-PS.position.y,PA.position.z-PS.position.z,-((PA.position.x-PS.position.x)*PA.position.x+(PA.position.y-PS.position.y)*PA.position.y+(PA.position.z-PS.position.z)*PA.position.z)*zoom])],[TEBN],[],[]];
  KDUMP(SCHNITTVEKTOR_AS);
  Logfile();
  Logfile2();  
  }

var TD=function() {//setzt Punkt D auf Punkt Q
  Logtext2.push("TD()");
  PD.position.copy(q.position);
  EASD.geometry.verticesNeedUpdate = true;
  OBJ_Y=0;
  SCHNITTVEKTOR_AS=0;
  SCHNITTEBENE_ASD=[[DREIPUNKTE([PA.position.x*zoom,PA.position.y*zoom,PA.position.z*zoom,1],[PD.position.x*zoom,PD.position.y*zoom,PD.position.z*zoom,1],[PS.position.x*zoom,PS.position.y*zoom,PS.position.z*zoom,1])],[TEBN],[],[]];
  Logfile2();  
  }

var TUmdrehen=function() {//AS oder AD umdrehen
  Logtext2.push("TUmdrehen()");
  if (SCHNITTVEKTOR_AS!=0) {
    SCHNITTVEKTOR_AS[0][0][0]=-SCHNITTVEKTOR_AS[0][0][0];
    SCHNITTVEKTOR_AS[0][0][1]=-SCHNITTVEKTOR_AS[0][0][1];
    SCHNITTVEKTOR_AS[0][0][2]=-SCHNITTVEKTOR_AS[0][0][2];
    SCHNITTVEKTOR_AS[0][0][3]=-SCHNITTVEKTOR_AS[0][0][3];
    PS.position.x=2*PA.position.x-PS.position.x;
    PS.position.y=2*PA.position.y-PS.position.y;
    PS.position.z=2*PA.position.z-PS.position.z;
    VAS.geometry.verticesNeedUpdate = true;
    Logtext="SCHNITTVEKTOR_AS nach -AS:\n";KDUMP(SCHNITTVEKTOR_AS);Logfile();
    } else if (SCHNITTEBENE_ASD!=0) {
      SCHNITTEBENE_ASD[0][0][0]=-SCHNITTEBENE_ASD[0][0][0];
      SCHNITTEBENE_ASD[0][0][1]=-SCHNITTEBENE_ASD[0][0][1];
      SCHNITTEBENE_ASD[0][0][2]=-SCHNITTEBENE_ASD[0][0][2];
      SCHNITTEBENE_ASD[0][0][3]=-SCHNITTEBENE_ASD[0][0][3];
      PD.position.x=2*PA.position.x-PD.position.x;
      PD.position.y=2*PA.position.y-PD.position.y;
      PD.position.z=2*PA.position.z-PD.position.z;
      EASD.geometry.verticesNeedUpdate = true;
      Logtext="SCHNITTEBENE_ASD nach -AD:\n";KDUMP(SCHNITTEBENE_ASD);Logfile();
      }
  }

var TMerken_Hilfsfunktion=function() {//
  if (SCHNITTVEKTOR_AS!=0) {
    MERKOBJEKT[0].push(SCHNITTVEKTOR_AS[0][0]);
    MERKOBJEKT[1].push(TEBN);
    if (MERKOBJEKT[0].length>1) MERKOBJEKT[1].push(TAND);
    } else if (SCHNITTEBENE_ASD!=0) {
      MERKOBJEKT[0].push(SCHNITTEBENE_ASD[0][0]);
      MERKOBJEKT[1].push(TEBN);
      if (MERKOBJEKT[0].length>1) MERKOBJEKT[1].push(TAND);
      }
  }

var TMerken=function() {//legt Ebene ASD fest
  Logtext2.push("TMerken()");
  TMerken_Hilfsfunktion();
  Logtext="MERKEBENE nach TMerken():\n";
  KDUMP(MERKOBJEKT);
  Logfile();
  Logfile2();  
  }

var TKopieren=function() {//verschiebt OBJ_X um Vektor AS
  Logtext2.push("TKopieren()");
  //OBJ_X=OBJ_X.slice();
  //OBJ_X[4]=[]; 
  OBJ_X=JSON.parse(JSON.stringify(OBJ_X.slice(0,4)));
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);
  SAMMELEBENE=[[],[],[],[]];
  Logfile();
  Logfile2();  
  }

var TVerschieben=function() {//verschiebt OBJ_X um Vektor AS
  Logtext2.push("TVerschieben()");
  scene.remove(OBJ_X[4]); 
  var cind=Castlist.indexOf(OBJ_X); 
  OBJ_X=TRANSFORM(OBJ_X,[[1,0,0,(PA.position.x-PS.position.x)*zoom],[0,1,0,(PA.position.y-PS.position.y)*zoom],[0,0,1,(PA.position.z-PS.position.z)*zoom],[0,0,0,1]]);
  KDUMP(OBJ_X);KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X); Castlist.pop(); 
  Castlist[cind]=OBJ_X;
  SAMMELEBENE=[[],[],[],[]];
  Logfile();
  Logfile2();  
  }

var TDrehen=function() {//dreht OBJ_X aus Vektor AS in Richtung AD erst yaw dann pitch
  Logtext2.push("TDrehen()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  OBJ_X=DrehenASD(OBJ_X);
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);Castlist.pop();
  Castlist[cind]=OBJ_X;
  SAMMELEBENE=[[],[],[],[]]
  Logfile();
  Logfile2();  
  }

var TSchneiden=function() {//schneidet von OBJ_X das Objekt SAMMELEBENE ab
  Logtext2.push("TSchneiden()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  if (OBJ_Y!=0) SAMMELEBENE=OBJ_Y; else {
    TMerken_Hilfsfunktion();
    SAMMELEBENE=MERKOBJEKT;
    }        
  OBJ_X=RUMPS(OBJ_X,SAMMELEBENE,1);
  KDUMP(OBJ_X);
  KPLOT([OBJ_X]);
  AddObjekt(scene,OBJ_X);Castlist.pop();
  Castlist[cind]=OBJ_X;
  MERKOBJEKT=[[],[],[],[]];
  Logfile();
  Logfile2();  
  }

var TLoeschen=function() {//schneidet von OBJ_X das Objekt SAMMELEBENE ab
  Logtext2.push("TLoeschen()");
  scene.remove(OBJ_X[4]);
  var cind=Castlist.indexOf(OBJ_X);
  Castlist[cind]=Castlist.pop();
  MERKOBJEKT=[[],[],[],[]];
  Logfile();
  Logfile2();  
  }

var TNeu=function(l,b,h,name) {//schneidet von OBJ_X das Objekt SAMMELEBENE ab
  Logtext2.push("TNeu("+l+","+b+","+h+")");
  PUNKT_A=[q.position.x*zoom,q.position.y*zoom,q.position.z*zoom,1];
  var NEU=QUADER(l,b,h); 
  KFILL(NEU); 
  NEU[5]=name;
  AddObjekt(scene,NEU);
  Logfile();
  Logfile2();  
  }
  </script>

<script>//Logfile
//gesammelten Logtext ausgeben
function Logfile(Resttext) {
  if (!Resttext) var Resttext="";
  document.getElementById("Log").innerHTML='<span style="white-space:pre; font-family:monospace">'+Logtext+Resttext+"</span>";
  Logtext="";
  }

function Logfile2(Resttext) {
  if (!Resttext) var Resttext="";
  var Log2element=document.getElementById("Log2");
  var Log2element_innerHTML='<span style="white-space:pre; font-family:monospace">\nLT=[\n';
  for (t in Logtext2) Log2element_innerHTML=Log2element_innerHTML+'<span onclick="alert('+t+')">"/*'+t+"*/ "+Logtext2[t]+'",</span>\n';
  Log2element_innerHTML=Log2element_innerHTML+Resttext+'];\n\  \n  </span>';
  Log2element.innerHTML=Log2element_innerHTML;
  Log2element.scrollTo({//mit dem geht Kopieren nicht
    top: 100000,
    left: 0,
    //behavior: 'smooth'
    });
  selectText("Log2");
  }

function selectText(element) { //Quelle: https://gist.github.com/gubatron/6599366
    var doc = document
        , text = doc.getElementById(element)
        , range, selection
    ;    
    if (doc.body.createTextRange) { //ms
        range = doc.body.createTextRange();
        range.moveToElementText(text);
        range.select();
    } else if (window.getSelection) { //all others
        selection = window.getSelection();        
        range = doc.createRange();
        range.selectNodeContents(text);
        selection.removeAllRanges();
        selection.addRange(range);
    }
}

var LTeval=function(LT,ltind) {
  eval(LT[ltind]);
  ltind=ltind+1;
  if (ltind<LT.length) setTimeout(LTeval,20,LT,ltind);
  }
  </script>
  
  
<script>//raycast
function raycast ( e ) {
  //raycaster.setFromCamera( mouse, camera ) aus three.pdf ging nicht
  //1. sets the mouse position with a coordinate system where the center
  //   of the screen is the origin
  //for (var i in e) alert(i);
  //mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
  //mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
  mouse.x = ( (event.clientX-event.target.getBoundingClientRect().left) / window.innerWidth ) * 2 - 1;
  mouse.y = - ( (event.clientY-event.target.getBoundingClientRect().top) / window.innerHeight/*event.target.height*/ ) * 2 + 1;
  mouse.z = 1;

  cmin=0;
  var dmin=0;
  var pk="p";
  var pmin=[[0,0,0,1],[0,0,0,1]];
  var mindist=Infinity;
  for (var c in Castlist) {
    for (var d in Castlist[c][2]) {
      var p=Castlist[c][2][d][3];
      var dist=(new THREE.Vector3(p[0]/zoom,p[1]/zoom,p[2]/zoom)).project(camera).distanceToSquared(mouse);
      if (dist<mindist) {pk="p"; mindist=dist; cmin=c; dmin=d; pmin=[p.slice(),p.slice()];}
      }
    for (var d in Castlist[c][3]) {
      var p=Castlist[c][2];
      var k=Castlist[c][3][d];
      var dist=(new THREE.Vector3(
        (p[k[0]][3][0]+p[k[1]][3][0])/2/zoom,
        (p[k[0]][3][1]+p[k[1]][3][1])/2/zoom,
        (p[k[0]][3][2]+p[k[1]][3][2])/2/zoom
        )).project(camera).distanceToSquared(mouse);
      if (dist<mindist) {pk="k"; mindist=dist; cmin=c; dmin=d; pmin=[p[k[0]][3].slice(),p[k[1]][3].slice()];}
      }
    }
  //alert("cmin="+cmin+", dmin="+dmin+",pmin="+JSON.stringify(pmin)+", mindist="+mindist);
  TQ((pmin[0][0]+pmin[1][0])/2,(pmin[0][1]+pmin[1][1])/2,(pmin[0][2]+pmin[1][2])/2,cmin);
  document.getElementById("Pdisp").firstChild.nodeValue=pk+dmin+"=["+[(q.position.x*zoom).toFixed(2),(q.position.y*zoom).toFixed(2),(q.position.z*zoom).toFixed(2)]+'] in "'+Castlist[cmin][5]+'"';
  }

  </script>

<!--script>//sonstige bisher vergebliche Versuche

//create a blue LineBasicMaterial
const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
const points = [];
points.push( new THREE.Vector3( - 10, 0, 0 ) );
points.push( new THREE.Vector3( 0, 10, 0 ) );
points.push( new THREE.Vector3( 10, 0, 0 ) );

var geometry = new THREE.BufferGeometry();//.setFromPoints( points );
var line = new THREE.Line( geometry, material );
scene.add( line );

//Bezier aus three-cookbook S.100?
var numPoints = 33;   
var start = new THREE.Vector3(-2, 1, 0);   
var middle = new THREE.Vector3(0, 0, 0);   
var end = new THREE.Vector3(2, 3, 0);
var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end); 
var tube = new THREE.TubeGeometry(curveQuad, numPoints, 0.1, 44, false);   
var mesh11 = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({opacity: 0.6,     transparent: true   }));   
cube.add(mesh11);

/*aus three.js/dok/edgesgeometry, will nicht gehen
var geometry9 = new THREE.BoxGeometry( 4, 7, 9 );alert(THREE.EdgesGeometry);
var edges9 = new THREE.EdgesGeometry( geometry9 );alert(8);
const line9 = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
  cube.add(line9);
*/

//von irgendwoher:
  var geometry = new THREE.BufferGeometry();
  var material = new THREE.LineBasicMaterial( { vertexColors: true } );
  //alert(JSON.stringify(material));
  var positions = [];
  var colors = [];
  var segments=6;
  var r=1;
  for ( var i = 0; i < segments; i ++ ) {
    var x = Math.random() * r - r / 2;
    var y = Math.random() * r - r / 2;
    var z = Math.random() * r - r / 2;
    // positions
    positions.push( x, y, z );
    // colors
    colors.push( ( x / r ) + 0.5 );
	colors.push( ( y / r ) + 0.5 );
	colors.push( ( z / r ) + 0.5 );
    }
//alert(geometry.setAttribute);
//				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
//				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
//				generateMorphTargets( geometry );
//				geometry.computeBoundingSphere();
				var line = new THREE.Line( geometry, material );
//				scene.add( line );




  </script-->

<script>
//alert(THREE.LineBasicMaterial);
function AddObjekt(OBJ1,OBJ2) {
  var temp_material = new THREE.LineBasicMaterial({ color: 0x0077f0, linewidth:2});
  var temp_geometry = new THREE.Geometry();
  temp_geometry.vertices = [new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0)];
  var temp = new THREE.Line(temp_geometry, temp_material);
  for (var iK in OBJ2[3]) { var K=OBJ2[3][iK];
    var numPoints = 2;   
    var start = new THREE.Vector3(OBJ2[2][K[0]][3][0]/zoom, OBJ2[2][K[0]][3][1]/zoom, OBJ2[2][K[0]][3][2]/zoom);   
    var middle = new THREE.Vector3(OBJ2[2][K[0]][3][0]/zoom, OBJ2[2][K[0]][3][1]/zoom, OBJ2[2][K[0]][3][2]/zoom);   
    var end = new THREE.Vector3(OBJ2[2][K[1]][3][0]/zoom, OBJ2[2][K[1]][3][1]/zoom, OBJ2[2][K[1]][3][2]/zoom);

    if (Linientyp==0) {
      var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end); 
      var tube = new THREE.TubeGeometry(curveQuad, numPoints, 0.05, 33, false);   
      var mesh11 = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({opacity: 0.99,     transparent: true   }));   
      temp.add(mesh11);
      } else {
        var materialline = new THREE.LineBasicMaterial({ color: 0x0077f0, linewidth:2});
        var geometryline = new THREE.Geometry();
        geometryline.vertices = [start,end];
        //var geometryline = new THREE.BufferGeometry().setFromPoints( [start,end] );
        var obj2line = new THREE.Line(geometryline, materialline);
        temp.add(obj2line);
        }

    }
  OBJ2[4]=temp;
  OBJ1.add(temp);
  Castlist.push(OBJ2);
  }
  </script>

<script>
function Testspline() {

var spline = new THREE.SplineCurve3([
     new THREE.Vector3(-10, -2, 10),
     new THREE.Vector3(-4, -2, 2),
     new THREE.Vector3(0, -2, -10),
     new THREE.Vector3(2, -2, -10),
     new THREE.Vector3(0,-4,0),
     new THREE.Vector3(7, -2, 1),
     new THREE.Vector3(10, -2, 3),
     new THREE.Vector3(-10, -2, 10)]);

   var geometry = new THREE.Geometry();
   var splinePoints = spline.getPoints(50);
   var material = new THREE.LineBasicMaterial({ color: 0xff00f0   });
//   geometry.vertices = [new THREE.Vector3(0, 2, 0),new THREE.Vector3(2, 0, 2)]; //splinePoints;
   geometry.vertices = splinePoints;
   var sline = new THREE.Line(geometry, material);
   sline.name='sline';
   return sline;
  }

  </script>

<script>
/*
  DRU X wählt ein OBJEKT X
  DRU C kopiert OBJEKT X an die gleiche Stelle
  DRU A wählt einen PUNKT A.
  DRU S wählt zu A einen VEKTOR AS.
  DRU D wählt zu AS eine EBENE ASD.
  DRU E verschiebt X entlang AS
  DRU Q dreht X von AS in Richtung AD
  DRU W AS pendelt um AD bis AS2
  DRU F EBENE ASD sägt OBJEKT X rechterhand ab
  DRU R VEKTOR AS sägt OBJEKT X linkerhand ab
  DRU Y wählt OBJEKT Y
  DRU T OBJEKT Y spart OBJEKT X aus.
  DRU mit Shifttaste ‹:
  DRU ‹C löscht Objekt X
  DRU ‹E dreht Vektor AS um.
  DRU ‹R hebt Sägeebene auf bis R oder F
  DRU ‹F hebt Sägeebene auf bis R oder F
  DRU ‹T Durchschnitt von Objekt X und Y
  DRU weitere Eingaben
  DRU G zur einzelnen Darstellung X und Y
  DRU 4 Vergrößerung (4:1)
  DRU 3 Vergrößerung (3:2)
  DRU 2 Verkleinerung (2:3)
  DRU 1 Verkleinerung (1:4)
  DRU J Blick von weiter links
  DRU K Blick von weiter rechts
  ;
*/



/*
FEHLERTEXT ( nr --> adr n )
  DUP 500 < IF FEHLERTEXT ELSE >R
    R 502 = IF U" OBJEKT X ist nicht markiert" ENDIF
    R 503 = IF U" OBJEKT Y ist nicht markiert" ENDIF
    R 504 = IF U" VEKTOR AS ist nicht markiert oder A fällt mit S zusammen" ENDIF
    R 505 = IF U" EBENE ASD ist nicht markiert oder A fällt mit S oder D zusammen" ENDIF
    R 506 = IF U" AS und AD sind parallel" ENDIF
    R 507 = IF U" AS2 und AD sind parallel" ENDIF
    R 508 = IF U" Wurzel aus negativer ganzen Zahl" ENDIF
    R 500 = IF U" Wurzel aus negativer rationalen Zahl" ENDIF
    R 501 = IF U" Fehler im Rechenausdruck" ENDIF
    R 508 > IF " ???" ENDIF
    R> DROP ENDIF
  ;
  */
  </script>
</body>
</html>
